//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.3
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from ./grammar/PlSql.g4 by ANTLR 4.5.3

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.3")]
[System.CLSCompliant(false)]
public partial class PlSqlParser : Parser {
	public const int
		T__0=1, PP_IF=2, PP_THEN=3, PP_ELSE=4, PP_ELSIF=5, PP_END=6, PP_ERROR=7, 
		A_LETTER=8, ADD=9, AFTER=10, AGENT=11, AGGREGATE=12, ALL=13, ALTER=14, 
		ANALYZE=15, AND=16, ANY=17, ARRAY=18, AS=19, ASC=20, ASSOCIATE=21, ASSOCIATION_OPERATOR=22, 
		AT=23, ATTRIBUTE=24, AUDIT=25, AUTHID=26, AUTO=27, AUTOMATIC=28, AUTONOMOUS_TRANSACTION=29, 
		BATCH=30, BEFORE=31, BEGIN=32, BETWEEN=33, BFILE=34, BINARY_DOUBLE=35, 
		BINARY_FLOAT=36, BINARY_INTEGER=37, BLOB=38, BLOCK=39, BODY=40, BOOLEAN=41, 
		BOTH=42, BREADTH=43, BULK=44, BY=45, BYTE=46, C_LETTER=47, CACHE=48, CALL=49, 
		CANONICAL=50, CASCADE=51, CASE=52, CAST=53, CHAR=54, CHAR_CS=55, CHARACTER=56, 
		CHECK=57, CHR=58, CLOB=59, CLOSE=60, CLUSTER=61, COLLECT=62, COLUMNS=63, 
		COMMENT=64, COMMIT=65, COMMITTED=66, COMPATIBILITY=67, COMPILE=68, COMPOUND=69, 
		CONNECT=70, CONNECT_BY_ROOT=71, CONSTANT=72, CONSTRAINT=73, CONSTRAINTS=74, 
		CONSTRUCTOR=75, CONTENT=76, CONTEXT=77, CONTINUE=78, CONVERT=79, CORRUPT_XID=80, 
		CORRUPT_XID_ALL=81, COST=82, COUNT=83, CREATE=84, CROSS=85, CUBE=86, CURRENT=87, 
		CURRENT_USER=88, CURSOR=89, CUSTOMDATUM=90, CYCLE=91, DATA=92, DATABASE=93, 
		DATE=94, DAY=95, DB_ROLE_CHANGE=96, DBTIMEZONE=97, DDL=98, DEBUG=99, DEC=100, 
		DECIMAL=101, DECLARE=102, DECOMPOSE=103, DECREMENT=104, DEFAULT=105, DEFAULTS=106, 
		DEFERRED=107, DEFINER=108, DELETE=109, DEPTH=110, DESC=111, DETERMINISTIC=112, 
		DIMENSION=113, DISABLE=114, DISASSOCIATE=115, DISTINCT=116, DOCUMENT=117, 
		DOUBLE=118, DROP=119, DSINTERVAL_UNCONSTRAINED=120, EACH=121, ELEMENT=122, 
		ELSE=123, ELSIF=124, EMPTY=125, ENABLE=126, ENCODING=127, END=128, ENTITYESCAPING=129, 
		ERRORS=130, ESCAPE=131, EXCEPT=132, EVALNAME=133, EXCEPTION=134, EXCEPTION_INIT=135, 
		EXCEPTIONS=136, EXCLUDE=137, EXCLUSIVE=138, EXECUTE=139, EXISTS=140, EXIT=141, 
		EXPLAIN=142, EXTERNAL=143, EXTEND=144, EXTRACT=145, FAILURE=146, FALSE=147, 
		FETCH=148, FINAL=149, FIRST=150, FIRST_VALUE=151, FLOAT=152, FOLLOWING=153, 
		FOLLOWS=154, FOR=155, FORALL=156, FORCE=157, FROM=158, FULL=159, FUNCTION=160, 
		GOTO=161, GRANT=162, GROUP=163, GROUPING=164, HASH=165, HAVING=166, HIDE=167, 
		HOUR=168, IF=169, IGNORE=170, IMMEDIATE=171, IN=172, INCLUDE=173, INCLUDING=174, 
		INCREMENT=175, INDENT=176, INDEX=177, INDEXED=178, INDICATOR=179, INDICES=180, 
		INFINITE=181, INLINE=182, INNER=183, INOUT=184, INSERT=185, INSTANTIABLE=186, 
		INSTEAD=187, INT=188, INTEGER=189, INTERSECT=190, INTERVAL=191, INTO=192, 
		INVALIDATE=193, IS=194, ISOLATION=195, ITERATE=196, JAVA=197, JOIN=198, 
		KEEP=199, LANGUAGE=200, LAST=201, LAST_VALUE=202, LEADING=203, LEFT=204, 
		LEVEL=205, LIBRARY=206, LIKE=207, LIKE2=208, LIKE4=209, LIKEC=210, LIMIT=211, 
		LOCAL=212, LOCK=213, LOCKED=214, LOG=215, LOGOFF=216, LOGON=217, LONG=218, 
		LOOP=219, MAIN=220, MAP=221, MATCHED=222, MAXVALUE=223, MEASURES=224, 
		MEMBER=225, MERGE=226, MINUS=227, MINUTE=228, MINVALUE=229, MLSLABEL=230, 
		MOD=231, MODE=232, MODEL=233, MODIFY=234, MONTH=235, MULTISET=236, NAME=237, 
		NAN=238, NATURAL=239, NATURALN=240, NAV=241, NCHAR=242, NCHAR_CS=243, 
		NCLOB=244, NESTED=245, NEW=246, NEXT=247, NO=248, NOAUDIT=249, NOCACHE=250, 
		NOCOPY=251, NOCYCLE=252, NOENTITYESCAPING=253, NOMAXVALUE=254, NOMINVALUE=255, 
		NONE=256, NOORDER=257, NOSCHEMACHECK=258, NOT=259, NOWAIT=260, NULL=261, 
		NULLS=262, NUMBER=263, NUMERIC=264, NVARCHAR2=265, OBJECT=266, OF=267, 
		OFF=268, OID=269, OLD=270, ON=271, ONLY=272, OPEN=273, OPTION=274, OR=275, 
		ORADATA=276, ORDER=277, ORDINALITY=278, OSERROR=279, OUT=280, OUTER=281, 
		OVER=282, OVERRIDING=283, PACKAGE=284, PARALLEL_ENABLE=285, PARAMETERS=286, 
		PARENT=287, PARTITION=288, PASSING=289, PATH=290, PERCENT_ISOPEN=291, 
		PERCENT_ROWTYPE=292, PERCENT_TYPE=293, PERCENT_FOUND=294, PERCENT_NOTFOUND=295, 
		PERCENT_ROWCOUNT=296, PIPELINED=297, PIPE=298, PIVOT=299, PLAN=300, PLS_INTEGER=301, 
		POSITIVE=302, POSITIVEN=303, PRAGMA=304, PRECEDING=305, PRECISION=306, 
		PRESENT=307, PRIOR=308, PROCEDURE=309, RAISE=310, RANGE=311, RAW=312, 
		READ=313, REAL=314, RECORD=315, REF=316, REFERENCE=317, REFERENCING=318, 
		REJECT=319, RELIES_ON=320, RENAME=321, REPLACE=322, RESPECT=323, RESTRICT_REFERENCES=324, 
		RESULT=325, RESULT_CACHE=326, RETURN=327, RETURNING=328, REUSE=329, REVERSE=330, 
		REVOKE=331, RIGHT=332, ROLLBACK=333, ROLLUP=334, ROW=335, ROWID=336, ROWS=337, 
		RULES=338, SAMPLE=339, SAVE=340, SAVEPOINT=341, SCHEMA=342, SCHEMACHECK=343, 
		SCN=344, SEARCH=345, SECOND=346, SEED=347, SEGMENT=348, SELECT=349, SELF=350, 
		SEQUENCE=351, SEQUENTIAL=352, SERIALIZABLE=353, SERIALLY_REUSABLE=354, 
		SERVERERROR=355, SESSIONTIMEZONE=356, SET=357, SETS=358, SETTINGS=359, 
		SHARE=360, SHOW=361, SHUTDOWN=362, SIBLINGS=363, SIGNTYPE=364, SIMPLE_INTEGER=365, 
		SINGLE=366, SIZE=367, SKIP_=368, SMALLINT=369, SNAPSHOT=370, SOME=371, 
		SPECIFICATION=372, SQLDATA=373, SQLERROR=374, SQL_PERCENT_ROWCOUNT=375, 
		STANDALONE=376, START=377, STARTUP=378, STATEMENT=379, STATEMENT_ID=380, 
		STATIC=381, STATISTICS=382, STRING=383, SUBMULTISET=384, SUBPARTITION=385, 
		SUBSTITUTABLE=386, SUBTYPE=387, SUCCESS=388, SUSPEND=389, TABLE=390, THE=391, 
		THEN=392, TIME=393, TIMESTAMP=394, TIMESTAMP_LTZ_UNCONSTRAINED=395, TIMESTAMP_TZ_UNCONSTRAINED=396, 
		TIMESTAMP_UNCONSTRAINED=397, TIMEZONE_ABBR=398, TIMEZONE_HOUR=399, TIMEZONE_MINUTE=400, 
		TIMEZONE_REGION=401, TO=402, TO_CHAR=403, TO_NUMBER=404, TRAILING=405, 
		TRANSACTION=406, TRANSLATE=407, TREAT=408, TRIGGER=409, TRIM=410, TRUE=411, 
		TRUNCATE=412, TYPE=413, UNBOUNDED=414, UNDER=415, UNION=416, UNIQUE=417, 
		UNLIMITED=418, UNPIVOT=419, UNTIL=420, UPDATE=421, UPDATED=422, UPSERT=423, 
		UROWID=424, USE=425, USING=426, VALIDATE=427, VALUE=428, VALUES=429, VARCHAR=430, 
		VARCHAR2=431, VARIABLE=432, VARRAY=433, VARYING=434, VERSION=435, VERSIONS=436, 
		WAIT=437, WARNING=438, WELLFORMED=439, WHEN=440, WHENEVER=441, WHERE=442, 
		WHILE=443, WITH=444, WITHIN=445, WORK=446, WRITE=447, XML=448, XMLAGG=449, 
		XMLATTRIBUTES=450, XMLCAST=451, XMLCOLATTVAL=452, XMLELEMENT=453, XMLEXISTS=454, 
		XMLFOREST=455, XMLNAMESPACES=456, XMLPARSE=457, XMLPI=458, XMLQUERY=459, 
		XMLROOT=460, XMLSERIALIZE=461, XMLTABLE=462, YEAR=463, YES=464, YMINTERVAL_UNCONSTRAINED=465, 
		ZONE=466, PREDICTION=467, PREDICTION_BOUNDS=468, PREDICTION_COST=469, 
		PREDICTION_DETAILS=470, PREDICTION_PROBABILITY=471, PREDICTION_SET=472, 
		CUME_DIST=473, DENSE_RANK=474, LISTAGG=475, PERCENT_RANK=476, PERCENTILE_CONT=477, 
		PERCENTILE_DISC=478, RANK=479, AVG=480, CORR=481, LAG=482, LEAD=483, MAX=484, 
		MEDIAN=485, MIN=486, NTILE=487, RATIO_TO_REPORT=488, ROW_NUMBER=489, SUM=490, 
		VARIANCE=491, REGR_=492, STDDEV=493, VAR_=494, COVAR_=495, PROMPT=496, 
		NATIONAL_CHAR_STRING_LIT=497, BIT_STRING_LIT=498, HEX_STRING_LIT=499, 
		DOUBLE_PERIOD=500, PERIOD=501, UNSIGNED_INTEGER=502, APPROXIMATE_NUM_LIT=503, 
		CHAR_STRING=504, DELIMITED_ID=505, PERCENT=506, AMPERSAND=507, LEFT_PAREN=508, 
		RIGHT_PAREN=509, DOUBLE_ASTERISK=510, ASTERISK=511, PLUS_SIGN=512, MINUS_SIGN=513, 
		COMMA=514, SOLIDUS=515, AT_SIGN=516, ASSIGN_OP=517, BINDVAR=518, COLON=519, 
		SEMICOLON=520, LESS_THAN_OR_EQUALS_OP=521, LESS_THAN_OP=522, GREATER_THAN_OR_EQUALS_OP=523, 
		NOT_EQUAL_OP=524, CARRET_OPERATOR_PART=525, TILDE_OPERATOR_PART=526, EXCLAMATION_OPERATOR_PART=527, 
		GREATER_THAN_OP=528, CONCATENATION_OP=529, VERTICAL_BAR=530, EQUALS_OP=531, 
		LEFT_BRACKET=532, RIGHT_BRACKET=533, INTRODUCER=534, SPACES=535, SINGLE_LINE_COMMENT=536, 
		MULTI_LINE_COMMENT=537, SQL92_RESERVED_ALL=538, SQL92_RESERVED_ALTER=539, 
		SQL92_RESERVED_AND=540, SQL92_RESERVED_ANY=541, SQL92_RESERVED_AS=542, 
		SQL92_RESERVED_ASC=543, SQL92_RESERVED_BEGIN=544, SQL92_RESERVED_BETWEEN=545, 
		SQL92_RESERVED_BY=546, SQL92_RESERVED_CASE=547, SQL92_RESERVED_CHECK=548, 
		PLSQL_RESERVED_CLUSTERS=549, PLSQL_RESERVED_COLAUTH=550, PLSQL_RESERVED_COMPRESS=551, 
		SQL92_RESERVED_CONNECT=552, PLSQL_NON_RESERVED_CONNECT_BY_ROOT=553, PLSQL_RESERVED_CRASH=554, 
		SQL92_RESERVED_CREATE=555, SQL92_RESERVED_CURRENT=556, SQL92_RESERVED_CURSOR=557, 
		SQL92_RESERVED_DATE=558, SQL92_RESERVED_DECLARE=559, SQL92_RESERVED_DEFAULT=560, 
		SQL92_RESERVED_DELETE=561, SQL92_RESERVED_DESC=562, SQL92_RESERVED_DISTINCT=563, 
		SQL92_RESERVED_DROP=564, SQL92_RESERVED_ELSE=565, SQL92_RESERVED_END=566, 
		SQL92_RESERVED_EXCEPTION=567, PLSQL_RESERVED_EXCLUSIVE=568, SQL92_RESERVED_EXISTS=569, 
		SQL92_RESERVED_FALSE=570, SQL92_RESERVED_FETCH=571, SQL92_RESERVED_FOR=572, 
		SQL92_RESERVED_FROM=573, SQL92_RESERVED_GOTO=574, SQL92_RESERVED_GRANT=575, 
		SQL92_RESERVED_GROUP=576, SQL92_RESERVED_HAVING=577, PLSQL_RESERVED_IDENTIFIED=578, 
		PLSQL_RESERVED_IF=579, SQL92_RESERVED_IN=580, PLSQL_RESERVED_INDEX=581, 
		PLSQL_RESERVED_INDEXES=582, SQL92_RESERVED_INSERT=583, SQL92_RESERVED_INTERSECT=584, 
		SQL92_RESERVED_INTO=585, SQL92_RESERVED_IS=586, SQL92_RESERVED_LIKE=587, 
		PLSQL_RESERVED_LOCK=588, PLSQL_RESERVED_MINUS=589, PLSQL_RESERVED_MODE=590, 
		PLSQL_RESERVED_NOCOMPRESS=591, SQL92_RESERVED_NOT=592, PLSQL_RESERVED_NOWAIT=593, 
		SQL92_RESERVED_NULL=594, SQL92_RESERVED_OF=595, SQL92_RESERVED_ON=596, 
		SQL92_RESERVED_OPTION=597, SQL92_RESERVED_OR=598, SQL92_RESERVED_ORDER=599, 
		SQL92_RESERVED_OVERLAPS=600, SQL92_RESERVED_PRIOR=601, SQL92_RESERVED_PROCEDURE=602, 
		SQL92_RESERVED_PUBLIC=603, PLSQL_RESERVED_RESOURCE=604, SQL92_RESERVED_REVOKE=605, 
		SQL92_RESERVED_SELECT=606, PLSQL_RESERVED_SHARE=607, SQL92_RESERVED_SIZE=608, 
		PLSQL_RESERVED_START=609, PLSQL_RESERVED_TABAUTH=610, SQL92_RESERVED_TABLE=611, 
		SQL92_RESERVED_THE=612, SQL92_RESERVED_THEN=613, SQL92_RESERVED_TO=614, 
		SQL92_RESERVED_TRUE=615, SQL92_RESERVED_UNION=616, SQL92_RESERVED_UNIQUE=617, 
		SQL92_RESERVED_UPDATE=618, SQL92_RESERVED_VALUES=619, SQL92_RESERVED_VIEW=620, 
		PLSQL_RESERVED_VIEWS=621, SQL92_RESERVED_WHEN=622, SQL92_RESERVED_WHERE=623, 
		SQL92_RESERVED_WITH=624, PLSQL_NON_RESERVED_USING=625, PLSQL_NON_RESERVED_MODEL=626, 
		PLSQL_NON_RESERVED_ELSIF=627, PLSQL_NON_RESERVED_PIVOT=628, PLSQL_NON_RESERVED_UNPIVOT=629, 
		REGULAR_ID=630, ZV=631;
	public const int
		RULE_swallow_to_semi = 0, RULE_compilation_unit = 1, RULE_sql_script = 2, 
		RULE_unit_statement = 3, RULE_declare_wrapper = 4, RULE_is_or_as = 5, 
		RULE_drop_function = 6, RULE_alter_function = 7, RULE_create_function_body = 8, 
		RULE_function_spec = 9, RULE_parallel_enable_clause = 10, RULE_partition_by_clause = 11, 
		RULE_result_cache_clause = 12, RULE_relies_on_part = 13, RULE_streaming_clause = 14, 
		RULE_drop_package = 15, RULE_alter_package = 16, RULE_create_package = 17, 
		RULE_package_body = 18, RULE_package_spec = 19, RULE_package_obj_spec = 20, 
		RULE_package_obj_body = 21, RULE_drop_procedure = 22, RULE_alter_procedure = 23, 
		RULE_create_procedure_body = 24, RULE_procedure_spec = 25, RULE_drop_trigger = 26, 
		RULE_alter_trigger = 27, RULE_create_trigger = 28, RULE_trigger_follows_clause = 29, 
		RULE_trigger_when_clause = 30, RULE_simple_dml_trigger = 31, RULE_for_each_row = 32, 
		RULE_compound_dml_trigger = 33, RULE_non_dml_trigger = 34, RULE_trigger_body = 35, 
		RULE_routine_clause = 36, RULE_compound_trigger_block = 37, RULE_timing_point_section = 38, 
		RULE_non_dml_event = 39, RULE_dml_event_clause = 40, RULE_dml_event_element = 41, 
		RULE_dml_event_nested_clause = 42, RULE_referencing_clause = 43, RULE_referencing_element = 44, 
		RULE_drop_type = 45, RULE_alter_type = 46, RULE_compile_type_clause = 47, 
		RULE_replace_type_clause = 48, RULE_alter_method_spec = 49, RULE_alter_method_element = 50, 
		RULE_alter_attribute_definition = 51, RULE_attribute_definition = 52, 
		RULE_alter_collection_clauses = 53, RULE_dependent_handling_clause = 54, 
		RULE_dependent_exceptions_part = 55, RULE_create_type = 56, RULE_type_definition = 57, 
		RULE_object_type_def = 58, RULE_object_as_part = 59, RULE_object_under_part = 60, 
		RULE_nested_table_type_def = 61, RULE_sqlj_object_type = 62, RULE_type_body = 63, 
		RULE_type_body_elements = 64, RULE_map_order_func_declaration = 65, RULE_subprog_decl_in_type = 66, 
		RULE_proc_decl_in_type = 67, RULE_func_decl_in_type = 68, RULE_constructor_declaration = 69, 
		RULE_modifier_clause = 70, RULE_object_member_spec = 71, RULE_sqlj_object_type_attr = 72, 
		RULE_element_spec = 73, RULE_element_spec_options = 74, RULE_subprogram_spec = 75, 
		RULE_type_procedure_spec = 76, RULE_type_function_spec = 77, RULE_constructor_spec = 78, 
		RULE_map_order_function_spec = 79, RULE_pragma_clause = 80, RULE_pragma_elements = 81, 
		RULE_type_elements_parameter = 82, RULE_drop_sequence = 83, RULE_alter_sequence = 84, 
		RULE_create_sequence = 85, RULE_sequence_spec = 86, RULE_sequence_start_clause = 87, 
		RULE_invoker_rights_clause = 88, RULE_compiler_parameters_clause = 89, 
		RULE_call_spec = 90, RULE_java_spec = 91, RULE_c_spec = 92, RULE_c_agent_in_clause = 93, 
		RULE_c_parameters_clause = 94, RULE_parameter = 95, RULE_default_value_part = 96, 
		RULE_declare_spec = 97, RULE_variable_declaration = 98, RULE_subtype_declaration = 99, 
		RULE_cursor_declaration = 100, RULE_parameter_spec = 101, RULE_exception_declaration = 102, 
		RULE_pragma_declaration = 103, RULE_record_declaration = 104, RULE_record_type_dec = 105, 
		RULE_field_spec = 106, RULE_record_var_dec = 107, RULE_table_declaration = 108, 
		RULE_table_type_dec = 109, RULE_table_indexed_by_part = 110, RULE_varray_type_def = 111, 
		RULE_table_var_dec = 112, RULE_seq_of_statements = 113, RULE_label_declaration = 114, 
		RULE_statement = 115, RULE_assignment_statement = 116, RULE_continue_statement = 117, 
		RULE_exit_statement = 118, RULE_goto_statement = 119, RULE_if_statement = 120, 
		RULE_elsif_part = 121, RULE_else_part = 122, RULE_loop_statement = 123, 
		RULE_cursor_loop_param = 124, RULE_forall_statement = 125, RULE_bounds_clause = 126, 
		RULE_between_bound = 127, RULE_lower_bound = 128, RULE_upper_bound = 129, 
		RULE_null_statement = 130, RULE_raise_statement = 131, RULE_return_statement = 132, 
		RULE_function_call = 133, RULE_body = 134, RULE_collection_statement = 135, 
		RULE_pipe_row = 136, RULE_exception_clause = 137, RULE_exception_handler = 138, 
		RULE_trigger_block = 139, RULE_block = 140, RULE_sql_statement = 141, 
		RULE_execute_immediate = 142, RULE_dynamic_returning_clause = 143, RULE_data_manipulation_language_statements = 144, 
		RULE_cursor_manipulation_statements = 145, RULE_close_statement = 146, 
		RULE_open_statement = 147, RULE_fetch_statement = 148, RULE_open_for_statement = 149, 
		RULE_transaction_control_statements = 150, RULE_set_transaction_command = 151, 
		RULE_set_constraint_command = 152, RULE_commit_statement = 153, RULE_write_clause = 154, 
		RULE_rollback_statement = 155, RULE_savepoint_statement = 156, RULE_explain_statement = 157, 
		RULE_select_statement = 158, RULE_subquery_factoring_clause = 159, RULE_factoring_element = 160, 
		RULE_search_clause = 161, RULE_cycle_clause = 162, RULE_subquery = 163, 
		RULE_subquery_operation_part = 164, RULE_subquery_basic_elements = 165, 
		RULE_query_block = 166, RULE_selected_element = 167, RULE_from_clause = 168, 
		RULE_select_list_elements = 169, RULE_table_ref_list = 170, RULE_table_ref = 171, 
		RULE_table_ref_aux = 172, RULE_join_clause = 173, RULE_join_on_part = 174, 
		RULE_join_using_part = 175, RULE_outer_join_type = 176, RULE_query_partition_clause = 177, 
		RULE_flashback_query_clause = 178, RULE_pivot_clause = 179, RULE_pivot_element = 180, 
		RULE_pivot_for_clause = 181, RULE_pivot_in_clause = 182, RULE_pivot_in_clause_element = 183, 
		RULE_pivot_in_clause_elements = 184, RULE_unpivot_clause = 185, RULE_unpivot_in_clause = 186, 
		RULE_unpivot_in_elements = 187, RULE_hierarchical_query_clause = 188, 
		RULE_start_part = 189, RULE_group_by_clause = 190, RULE_group_by_elements = 191, 
		RULE_rollup_cube_clause = 192, RULE_grouping_sets_clause = 193, RULE_grouping_sets_elements = 194, 
		RULE_having_clause = 195, RULE_model_clause = 196, RULE_cell_reference_options = 197, 
		RULE_return_rows_clause = 198, RULE_reference_model = 199, RULE_main_model = 200, 
		RULE_model_column_clauses = 201, RULE_model_column_partition_part = 202, 
		RULE_model_column_list = 203, RULE_model_column = 204, RULE_model_rules_clause = 205, 
		RULE_model_rules_part = 206, RULE_model_rules_element = 207, RULE_cell_assignment = 208, 
		RULE_model_iterate_clause = 209, RULE_until_part = 210, RULE_order_by_clause = 211, 
		RULE_order_by_elements = 212, RULE_for_update_clause = 213, RULE_for_update_of_part = 214, 
		RULE_for_update_options = 215, RULE_update_statement = 216, RULE_update_set_clause = 217, 
		RULE_column_based_update_set_clause = 218, RULE_delete_statement = 219, 
		RULE_insert_statement = 220, RULE_single_table_insert = 221, RULE_multi_table_insert = 222, 
		RULE_multi_table_element = 223, RULE_conditional_insert_clause = 224, 
		RULE_conditional_insert_when_part = 225, RULE_conditional_insert_else_part = 226, 
		RULE_insert_into_clause = 227, RULE_values_clause = 228, RULE_merge_statement = 229, 
		RULE_merge_update_clause = 230, RULE_merge_element = 231, RULE_merge_update_delete_part = 232, 
		RULE_merge_insert_clause = 233, RULE_selected_tableview = 234, RULE_lock_table_statement = 235, 
		RULE_wait_nowait_part = 236, RULE_lock_table_element = 237, RULE_lock_mode = 238, 
		RULE_general_table_ref = 239, RULE_static_returning_clause = 240, RULE_error_logging_clause = 241, 
		RULE_error_logging_into_part = 242, RULE_error_logging_reject_part = 243, 
		RULE_dml_table_expression_clause = 244, RULE_table_collection_expression = 245, 
		RULE_subquery_restriction_clause = 246, RULE_sample_clause = 247, RULE_seed_part = 248, 
		RULE_cursor_expression = 249, RULE_sql_cursor_expression = 250, RULE_collection_assoc_expression = 251, 
		RULE_collection_type_expression = 252, RULE_expression_list = 253, RULE_condition = 254, 
		RULE_condition_wrapper = 255, RULE_expression = 256, RULE_expression_wrapper = 257, 
		RULE_logical_and_expression = 258, RULE_negated_expression = 259, RULE_equality_expression = 260, 
		RULE_multiset_part = 261, RULE_multiset_expression = 262, RULE_multiset_type = 263, 
		RULE_relational_expression = 264, RULE_compound_expression = 265, RULE_like_type = 266, 
		RULE_like_escape_part = 267, RULE_in_elements = 268, RULE_between_elements = 269, 
		RULE_concatenation = 270, RULE_concatenation_wrapper = 271, RULE_additive_expression = 272, 
		RULE_multiply_expression = 273, RULE_datetime_expression = 274, RULE_interval_expression = 275, 
		RULE_model_expression = 276, RULE_model_expression_element = 277, RULE_single_column_for_loop = 278, 
		RULE_for_like_part = 279, RULE_for_increment_decrement_type = 280, RULE_multi_column_for_loop = 281, 
		RULE_unary_expression = 282, RULE_case_statement = 283, RULE_simple_case_statement = 284, 
		RULE_simple_case_when_part = 285, RULE_searched_case_statement = 286, 
		RULE_searched_case_when_part = 287, RULE_case_else_part = 288, RULE_atom = 289, 
		RULE_expression_or_vector = 290, RULE_vector_expr = 291, RULE_quantified_expression = 292, 
		RULE_plsql_type_conversion = 293, RULE_sql_type_conversion = 294, RULE_xml_table_columns = 295, 
		RULE_xml_table = 296, RULE_standard_function = 297, RULE_over_clause_keyword = 298, 
		RULE_within_or_over_clause_keyword = 299, RULE_standard_prediction_function_keyword = 300, 
		RULE_over_clause = 301, RULE_windowing_clause = 302, RULE_windowing_type = 303, 
		RULE_windowing_elements = 304, RULE_using_clause = 305, RULE_using_element = 306, 
		RULE_collect_order_by_part = 307, RULE_within_or_over_part = 308, RULE_cost_matrix_clause = 309, 
		RULE_xml_passing_clause = 310, RULE_xml_attributes_clause = 311, RULE_xml_namespaces_clause = 312, 
		RULE_xml_table_column = 313, RULE_xml_general_default_part = 314, RULE_xml_multiuse_expression_element = 315, 
		RULE_xmlroot_param_version_part = 316, RULE_xmlroot_param_standalone_part = 317, 
		RULE_xmlserialize_param_enconding_part = 318, RULE_xmlserialize_param_version_part = 319, 
		RULE_xmlserialize_param_ident_part = 320, RULE_boolean_static_expression = 321, 
		RULE_preprocessor_internal_statement = 322, RULE_preprocessor_statement = 323, 
		RULE_partition_extension_clause = 324, RULE_column_alias = 325, RULE_table_alias = 326, 
		RULE_alias_quoted_string = 327, RULE_where_clause = 328, RULE_current_of_clause = 329, 
		RULE_into_clause_variable = 330, RULE_into_clause = 331, RULE_xml_column_name = 332, 
		RULE_cost_class_name = 333, RULE_attribute_name = 334, RULE_savepoint_name = 335, 
		RULE_rollback_segment_name = 336, RULE_table_var_name = 337, RULE_schema_name = 338, 
		RULE_routine_name = 339, RULE_package_name = 340, RULE_implementation_type_name = 341, 
		RULE_parameter_name = 342, RULE_reference_model_name = 343, RULE_main_model_name = 344, 
		RULE_aggregate_function_name = 345, RULE_query_name = 346, RULE_constraint_name = 347, 
		RULE_label_name = 348, RULE_type_name = 349, RULE_sequence_name = 350, 
		RULE_exception_name = 351, RULE_function_name = 352, RULE_procedure_name = 353, 
		RULE_trigger_name = 354, RULE_variable_name = 355, RULE_index_name = 356, 
		RULE_cursor_name = 357, RULE_record_name = 358, RULE_collection_name = 359, 
		RULE_link_name = 360, RULE_column_name = 361, RULE_tableview_name = 362, 
		RULE_char_set_name = 363, RULE_keep_clause = 364, RULE_function_argument = 365, 
		RULE_function_argument_analytic = 366, RULE_function_argument_modeling = 367, 
		RULE_respect_or_ignore_nulls = 368, RULE_argument = 369, RULE_type_spec = 370, 
		RULE_datatype = 371, RULE_precision_part = 372, RULE_native_datatype_element = 373, 
		RULE_bind_variable = 374, RULE_general_element = 375, RULE_general_element_part = 376, 
		RULE_table_element = 377, RULE_constant = 378, RULE_numeric = 379, RULE_quoted_string = 380, 
		RULE_id = 381, RULE_id_expression = 382, RULE_not_equal_op = 383, RULE_greater_than_or_equals_op = 384, 
		RULE_less_than_or_equals_op = 385, RULE_concatenation_op = 386, RULE_outer_join_sign = 387, 
		RULE_regular_id = 388;
	public static readonly string[] ruleNames = {
		"swallow_to_semi", "compilation_unit", "sql_script", "unit_statement", 
		"declare_wrapper", "is_or_as", "drop_function", "alter_function", "create_function_body", 
		"function_spec", "parallel_enable_clause", "partition_by_clause", "result_cache_clause", 
		"relies_on_part", "streaming_clause", "drop_package", "alter_package", 
		"create_package", "package_body", "package_spec", "package_obj_spec", 
		"package_obj_body", "drop_procedure", "alter_procedure", "create_procedure_body", 
		"procedure_spec", "drop_trigger", "alter_trigger", "create_trigger", "trigger_follows_clause", 
		"trigger_when_clause", "simple_dml_trigger", "for_each_row", "compound_dml_trigger", 
		"non_dml_trigger", "trigger_body", "routine_clause", "compound_trigger_block", 
		"timing_point_section", "non_dml_event", "dml_event_clause", "dml_event_element", 
		"dml_event_nested_clause", "referencing_clause", "referencing_element", 
		"drop_type", "alter_type", "compile_type_clause", "replace_type_clause", 
		"alter_method_spec", "alter_method_element", "alter_attribute_definition", 
		"attribute_definition", "alter_collection_clauses", "dependent_handling_clause", 
		"dependent_exceptions_part", "create_type", "type_definition", "object_type_def", 
		"object_as_part", "object_under_part", "nested_table_type_def", "sqlj_object_type", 
		"type_body", "type_body_elements", "map_order_func_declaration", "subprog_decl_in_type", 
		"proc_decl_in_type", "func_decl_in_type", "constructor_declaration", "modifier_clause", 
		"object_member_spec", "sqlj_object_type_attr", "element_spec", "element_spec_options", 
		"subprogram_spec", "type_procedure_spec", "type_function_spec", "constructor_spec", 
		"map_order_function_spec", "pragma_clause", "pragma_elements", "type_elements_parameter", 
		"drop_sequence", "alter_sequence", "create_sequence", "sequence_spec", 
		"sequence_start_clause", "invoker_rights_clause", "compiler_parameters_clause", 
		"call_spec", "java_spec", "c_spec", "c_agent_in_clause", "c_parameters_clause", 
		"parameter", "default_value_part", "declare_spec", "variable_declaration", 
		"subtype_declaration", "cursor_declaration", "parameter_spec", "exception_declaration", 
		"pragma_declaration", "record_declaration", "record_type_dec", "field_spec", 
		"record_var_dec", "table_declaration", "table_type_dec", "table_indexed_by_part", 
		"varray_type_def", "table_var_dec", "seq_of_statements", "label_declaration", 
		"statement", "assignment_statement", "continue_statement", "exit_statement", 
		"goto_statement", "if_statement", "elsif_part", "else_part", "loop_statement", 
		"cursor_loop_param", "forall_statement", "bounds_clause", "between_bound", 
		"lower_bound", "upper_bound", "null_statement", "raise_statement", "return_statement", 
		"function_call", "body", "collection_statement", "pipe_row", "exception_clause", 
		"exception_handler", "trigger_block", "block", "sql_statement", "execute_immediate", 
		"dynamic_returning_clause", "data_manipulation_language_statements", "cursor_manipulation_statements", 
		"close_statement", "open_statement", "fetch_statement", "open_for_statement", 
		"transaction_control_statements", "set_transaction_command", "set_constraint_command", 
		"commit_statement", "write_clause", "rollback_statement", "savepoint_statement", 
		"explain_statement", "select_statement", "subquery_factoring_clause", 
		"factoring_element", "search_clause", "cycle_clause", "subquery", "subquery_operation_part", 
		"subquery_basic_elements", "query_block", "selected_element", "from_clause", 
		"select_list_elements", "table_ref_list", "table_ref", "table_ref_aux", 
		"join_clause", "join_on_part", "join_using_part", "outer_join_type", "query_partition_clause", 
		"flashback_query_clause", "pivot_clause", "pivot_element", "pivot_for_clause", 
		"pivot_in_clause", "pivot_in_clause_element", "pivot_in_clause_elements", 
		"unpivot_clause", "unpivot_in_clause", "unpivot_in_elements", "hierarchical_query_clause", 
		"start_part", "group_by_clause", "group_by_elements", "rollup_cube_clause", 
		"grouping_sets_clause", "grouping_sets_elements", "having_clause", "model_clause", 
		"cell_reference_options", "return_rows_clause", "reference_model", "main_model", 
		"model_column_clauses", "model_column_partition_part", "model_column_list", 
		"model_column", "model_rules_clause", "model_rules_part", "model_rules_element", 
		"cell_assignment", "model_iterate_clause", "until_part", "order_by_clause", 
		"order_by_elements", "for_update_clause", "for_update_of_part", "for_update_options", 
		"update_statement", "update_set_clause", "column_based_update_set_clause", 
		"delete_statement", "insert_statement", "single_table_insert", "multi_table_insert", 
		"multi_table_element", "conditional_insert_clause", "conditional_insert_when_part", 
		"conditional_insert_else_part", "insert_into_clause", "values_clause", 
		"merge_statement", "merge_update_clause", "merge_element", "merge_update_delete_part", 
		"merge_insert_clause", "selected_tableview", "lock_table_statement", "wait_nowait_part", 
		"lock_table_element", "lock_mode", "general_table_ref", "static_returning_clause", 
		"error_logging_clause", "error_logging_into_part", "error_logging_reject_part", 
		"dml_table_expression_clause", "table_collection_expression", "subquery_restriction_clause", 
		"sample_clause", "seed_part", "cursor_expression", "sql_cursor_expression", 
		"collection_assoc_expression", "collection_type_expression", "expression_list", 
		"condition", "condition_wrapper", "expression", "expression_wrapper", 
		"logical_and_expression", "negated_expression", "equality_expression", 
		"multiset_part", "multiset_expression", "multiset_type", "relational_expression", 
		"compound_expression", "like_type", "like_escape_part", "in_elements", 
		"between_elements", "concatenation", "concatenation_wrapper", "additive_expression", 
		"multiply_expression", "datetime_expression", "interval_expression", "model_expression", 
		"model_expression_element", "single_column_for_loop", "for_like_part", 
		"for_increment_decrement_type", "multi_column_for_loop", "unary_expression", 
		"case_statement", "simple_case_statement", "simple_case_when_part", "searched_case_statement", 
		"searched_case_when_part", "case_else_part", "atom", "expression_or_vector", 
		"vector_expr", "quantified_expression", "plsql_type_conversion", "sql_type_conversion", 
		"xml_table_columns", "xml_table", "standard_function", "over_clause_keyword", 
		"within_or_over_clause_keyword", "standard_prediction_function_keyword", 
		"over_clause", "windowing_clause", "windowing_type", "windowing_elements", 
		"using_clause", "using_element", "collect_order_by_part", "within_or_over_part", 
		"cost_matrix_clause", "xml_passing_clause", "xml_attributes_clause", "xml_namespaces_clause", 
		"xml_table_column", "xml_general_default_part", "xml_multiuse_expression_element", 
		"xmlroot_param_version_part", "xmlroot_param_standalone_part", "xmlserialize_param_enconding_part", 
		"xmlserialize_param_version_part", "xmlserialize_param_ident_part", "boolean_static_expression", 
		"preprocessor_internal_statement", "preprocessor_statement", "partition_extension_clause", 
		"column_alias", "table_alias", "alias_quoted_string", "where_clause", 
		"current_of_clause", "into_clause_variable", "into_clause", "xml_column_name", 
		"cost_class_name", "attribute_name", "savepoint_name", "rollback_segment_name", 
		"table_var_name", "schema_name", "routine_name", "package_name", "implementation_type_name", 
		"parameter_name", "reference_model_name", "main_model_name", "aggregate_function_name", 
		"query_name", "constraint_name", "label_name", "type_name", "sequence_name", 
		"exception_name", "function_name", "procedure_name", "trigger_name", "variable_name", 
		"index_name", "cursor_name", "record_name", "collection_name", "link_name", 
		"column_name", "tableview_name", "char_set_name", "keep_clause", "function_argument", 
		"function_argument_analytic", "function_argument_modeling", "respect_or_ignore_nulls", 
		"argument", "type_spec", "datatype", "precision_part", "native_datatype_element", 
		"bind_variable", "general_element", "general_element_part", "table_element", 
		"constant", "numeric", "quoted_string", "id", "id_expression", "not_equal_op", 
		"greater_than_or_equals_op", "less_than_or_equals_op", "concatenation_op", 
		"outer_join_sign", "regular_id"
	};

	private static readonly string[] _LiteralNames = {
		null, "'..'", null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, "'=>'", null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, "'.'", null, null, 
		null, null, "'%'", "'&'", "'('", "')'", "'**'", "'*'", "'+'", "'-'", "','", 
		"'/'", "'@'", "':='", null, "':'", "';'", "'<='", "'<'", "'>='", null, 
		"'^'", "'~'", "'!'", "'>'", "'||'", "'|'", "'='", "'['", "']'", "'_'", 
		null, null, null, "'all'", "'alter'", "'and'", "'any'", "'as'", "'asc'", 
		"'begin'", "'between'", "'by'", "'case'", "'check'", "'clusters'", "'colauth'", 
		"'compress'", "'connect'", "'connect_by_root'", "'crash'", "'create'", 
		"'current'", "'cursor'", "'date'", "'declare'", "'default'", "'delete'", 
		"'desc'", "'distinct'", "'drop'", "'else'", "'end'", "'exception'", "'exclusive'", 
		"'exists'", "'false'", "'fetch'", "'for'", "'from'", "'goto'", "'grant'", 
		"'group'", "'having'", "'identified'", "'if'", "'in'", "'index'", "'indexes'", 
		"'insert'", "'intersect'", "'into'", "'is'", "'like'", "'lock'", "'minus'", 
		"'mode'", "'nocompress'", "'not'", "'nowait'", "'null'", "'of'", "'on'", 
		"'option'", "'or'", "'order'", "'overlaps'", "'prior'", "'procedure'", 
		"'public'", "'resource'", "'revoke'", "'select'", "'share'", "'size'", 
		"'start'", "'tabauth'", "'table'", "'the'", "'then'", "'to'", "'true'", 
		"'union'", "'unique'", "'update'", "'values'", "'view'", "'views'", "'when'", 
		"'where'", "'with'", "'using'", "'model'", "'elsif'", "'pivot'", "'unpivot'", 
		null, "'@!'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, "PP_IF", "PP_THEN", "PP_ELSE", "PP_ELSIF", "PP_END", "PP_ERROR", 
		"A_LETTER", "ADD", "AFTER", "AGENT", "AGGREGATE", "ALL", "ALTER", "ANALYZE", 
		"AND", "ANY", "ARRAY", "AS", "ASC", "ASSOCIATE", "ASSOCIATION_OPERATOR", 
		"AT", "ATTRIBUTE", "AUDIT", "AUTHID", "AUTO", "AUTOMATIC", "AUTONOMOUS_TRANSACTION", 
		"BATCH", "BEFORE", "BEGIN", "BETWEEN", "BFILE", "BINARY_DOUBLE", "BINARY_FLOAT", 
		"BINARY_INTEGER", "BLOB", "BLOCK", "BODY", "BOOLEAN", "BOTH", "BREADTH", 
		"BULK", "BY", "BYTE", "C_LETTER", "CACHE", "CALL", "CANONICAL", "CASCADE", 
		"CASE", "CAST", "CHAR", "CHAR_CS", "CHARACTER", "CHECK", "CHR", "CLOB", 
		"CLOSE", "CLUSTER", "COLLECT", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", 
		"COMPATIBILITY", "COMPILE", "COMPOUND", "CONNECT", "CONNECT_BY_ROOT", 
		"CONSTANT", "CONSTRAINT", "CONSTRAINTS", "CONSTRUCTOR", "CONTENT", "CONTEXT", 
		"CONTINUE", "CONVERT", "CORRUPT_XID", "CORRUPT_XID_ALL", "COST", "COUNT", 
		"CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_USER", "CURSOR", "CUSTOMDATUM", 
		"CYCLE", "DATA", "DATABASE", "DATE", "DAY", "DB_ROLE_CHANGE", "DBTIMEZONE", 
		"DDL", "DEBUG", "DEC", "DECIMAL", "DECLARE", "DECOMPOSE", "DECREMENT", 
		"DEFAULT", "DEFAULTS", "DEFERRED", "DEFINER", "DELETE", "DEPTH", "DESC", 
		"DETERMINISTIC", "DIMENSION", "DISABLE", "DISASSOCIATE", "DISTINCT", "DOCUMENT", 
		"DOUBLE", "DROP", "DSINTERVAL_UNCONSTRAINED", "EACH", "ELEMENT", "ELSE", 
		"ELSIF", "EMPTY", "ENABLE", "ENCODING", "END", "ENTITYESCAPING", "ERRORS", 
		"ESCAPE", "EXCEPT", "EVALNAME", "EXCEPTION", "EXCEPTION_INIT", "EXCEPTIONS", 
		"EXCLUDE", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXPLAIN", "EXTERNAL", 
		"EXTEND", "EXTRACT", "FAILURE", "FALSE", "FETCH", "FINAL", "FIRST", "FIRST_VALUE", 
		"FLOAT", "FOLLOWING", "FOLLOWS", "FOR", "FORALL", "FORCE", "FROM", "FULL", 
		"FUNCTION", "GOTO", "GRANT", "GROUP", "GROUPING", "HASH", "HAVING", "HIDE", 
		"HOUR", "IF", "IGNORE", "IMMEDIATE", "IN", "INCLUDE", "INCLUDING", "INCREMENT", 
		"INDENT", "INDEX", "INDEXED", "INDICATOR", "INDICES", "INFINITE", "INLINE", 
		"INNER", "INOUT", "INSERT", "INSTANTIABLE", "INSTEAD", "INT", "INTEGER", 
		"INTERSECT", "INTERVAL", "INTO", "INVALIDATE", "IS", "ISOLATION", "ITERATE", 
		"JAVA", "JOIN", "KEEP", "LANGUAGE", "LAST", "LAST_VALUE", "LEADING", "LEFT", 
		"LEVEL", "LIBRARY", "LIKE", "LIKE2", "LIKE4", "LIKEC", "LIMIT", "LOCAL", 
		"LOCK", "LOCKED", "LOG", "LOGOFF", "LOGON", "LONG", "LOOP", "MAIN", "MAP", 
		"MATCHED", "MAXVALUE", "MEASURES", "MEMBER", "MERGE", "MINUS", "MINUTE", 
		"MINVALUE", "MLSLABEL", "MOD", "MODE", "MODEL", "MODIFY", "MONTH", "MULTISET", 
		"NAME", "NAN", "NATURAL", "NATURALN", "NAV", "NCHAR", "NCHAR_CS", "NCLOB", 
		"NESTED", "NEW", "NEXT", "NO", "NOAUDIT", "NOCACHE", "NOCOPY", "NOCYCLE", 
		"NOENTITYESCAPING", "NOMAXVALUE", "NOMINVALUE", "NONE", "NOORDER", "NOSCHEMACHECK", 
		"NOT", "NOWAIT", "NULL", "NULLS", "NUMBER", "NUMERIC", "NVARCHAR2", "OBJECT", 
		"OF", "OFF", "OID", "OLD", "ON", "ONLY", "OPEN", "OPTION", "OR", "ORADATA", 
		"ORDER", "ORDINALITY", "OSERROR", "OUT", "OUTER", "OVER", "OVERRIDING", 
		"PACKAGE", "PARALLEL_ENABLE", "PARAMETERS", "PARENT", "PARTITION", "PASSING", 
		"PATH", "PERCENT_ISOPEN", "PERCENT_ROWTYPE", "PERCENT_TYPE", "PERCENT_FOUND", 
		"PERCENT_NOTFOUND", "PERCENT_ROWCOUNT", "PIPELINED", "PIPE", "PIVOT", 
		"PLAN", "PLS_INTEGER", "POSITIVE", "POSITIVEN", "PRAGMA", "PRECEDING", 
		"PRECISION", "PRESENT", "PRIOR", "PROCEDURE", "RAISE", "RANGE", "RAW", 
		"READ", "REAL", "RECORD", "REF", "REFERENCE", "REFERENCING", "REJECT", 
		"RELIES_ON", "RENAME", "REPLACE", "RESPECT", "RESTRICT_REFERENCES", "RESULT", 
		"RESULT_CACHE", "RETURN", "RETURNING", "REUSE", "REVERSE", "REVOKE", "RIGHT", 
		"ROLLBACK", "ROLLUP", "ROW", "ROWID", "ROWS", "RULES", "SAMPLE", "SAVE", 
		"SAVEPOINT", "SCHEMA", "SCHEMACHECK", "SCN", "SEARCH", "SECOND", "SEED", 
		"SEGMENT", "SELECT", "SELF", "SEQUENCE", "SEQUENTIAL", "SERIALIZABLE", 
		"SERIALLY_REUSABLE", "SERVERERROR", "SESSIONTIMEZONE", "SET", "SETS", 
		"SETTINGS", "SHARE", "SHOW", "SHUTDOWN", "SIBLINGS", "SIGNTYPE", "SIMPLE_INTEGER", 
		"SINGLE", "SIZE", "SKIP_", "SMALLINT", "SNAPSHOT", "SOME", "SPECIFICATION", 
		"SQLDATA", "SQLERROR", "SQL_PERCENT_ROWCOUNT", "STANDALONE", "START", 
		"STARTUP", "STATEMENT", "STATEMENT_ID", "STATIC", "STATISTICS", "STRING", 
		"SUBMULTISET", "SUBPARTITION", "SUBSTITUTABLE", "SUBTYPE", "SUCCESS", 
		"SUSPEND", "TABLE", "THE", "THEN", "TIME", "TIMESTAMP", "TIMESTAMP_LTZ_UNCONSTRAINED", 
		"TIMESTAMP_TZ_UNCONSTRAINED", "TIMESTAMP_UNCONSTRAINED", "TIMEZONE_ABBR", 
		"TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TIMEZONE_REGION", "TO", "TO_CHAR", 
		"TO_NUMBER", "TRAILING", "TRANSACTION", "TRANSLATE", "TREAT", "TRIGGER", 
		"TRIM", "TRUE", "TRUNCATE", "TYPE", "UNBOUNDED", "UNDER", "UNION", "UNIQUE", 
		"UNLIMITED", "UNPIVOT", "UNTIL", "UPDATE", "UPDATED", "UPSERT", "UROWID", 
		"USE", "USING", "VALIDATE", "VALUE", "VALUES", "VARCHAR", "VARCHAR2", 
		"VARIABLE", "VARRAY", "VARYING", "VERSION", "VERSIONS", "WAIT", "WARNING", 
		"WELLFORMED", "WHEN", "WHENEVER", "WHERE", "WHILE", "WITH", "WITHIN", 
		"WORK", "WRITE", "XML", "XMLAGG", "XMLATTRIBUTES", "XMLCAST", "XMLCOLATTVAL", 
		"XMLELEMENT", "XMLEXISTS", "XMLFOREST", "XMLNAMESPACES", "XMLPARSE", "XMLPI", 
		"XMLQUERY", "XMLROOT", "XMLSERIALIZE", "XMLTABLE", "YEAR", "YES", "YMINTERVAL_UNCONSTRAINED", 
		"ZONE", "PREDICTION", "PREDICTION_BOUNDS", "PREDICTION_COST", "PREDICTION_DETAILS", 
		"PREDICTION_PROBABILITY", "PREDICTION_SET", "CUME_DIST", "DENSE_RANK", 
		"LISTAGG", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", 
		"AVG", "CORR", "LAG", "LEAD", "MAX", "MEDIAN", "MIN", "NTILE", "RATIO_TO_REPORT", 
		"ROW_NUMBER", "SUM", "VARIANCE", "REGR_", "STDDEV", "VAR_", "COVAR_", 
		"PROMPT", "NATIONAL_CHAR_STRING_LIT", "BIT_STRING_LIT", "HEX_STRING_LIT", 
		"DOUBLE_PERIOD", "PERIOD", "UNSIGNED_INTEGER", "APPROXIMATE_NUM_LIT", 
		"CHAR_STRING", "DELIMITED_ID", "PERCENT", "AMPERSAND", "LEFT_PAREN", "RIGHT_PAREN", 
		"DOUBLE_ASTERISK", "ASTERISK", "PLUS_SIGN", "MINUS_SIGN", "COMMA", "SOLIDUS", 
		"AT_SIGN", "ASSIGN_OP", "BINDVAR", "COLON", "SEMICOLON", "LESS_THAN_OR_EQUALS_OP", 
		"LESS_THAN_OP", "GREATER_THAN_OR_EQUALS_OP", "NOT_EQUAL_OP", "CARRET_OPERATOR_PART", 
		"TILDE_OPERATOR_PART", "EXCLAMATION_OPERATOR_PART", "GREATER_THAN_OP", 
		"CONCATENATION_OP", "VERTICAL_BAR", "EQUALS_OP", "LEFT_BRACKET", "RIGHT_BRACKET", 
		"INTRODUCER", "SPACES", "SINGLE_LINE_COMMENT", "MULTI_LINE_COMMENT", "SQL92_RESERVED_ALL", 
		"SQL92_RESERVED_ALTER", "SQL92_RESERVED_AND", "SQL92_RESERVED_ANY", "SQL92_RESERVED_AS", 
		"SQL92_RESERVED_ASC", "SQL92_RESERVED_BEGIN", "SQL92_RESERVED_BETWEEN", 
		"SQL92_RESERVED_BY", "SQL92_RESERVED_CASE", "SQL92_RESERVED_CHECK", "PLSQL_RESERVED_CLUSTERS", 
		"PLSQL_RESERVED_COLAUTH", "PLSQL_RESERVED_COMPRESS", "SQL92_RESERVED_CONNECT", 
		"PLSQL_NON_RESERVED_CONNECT_BY_ROOT", "PLSQL_RESERVED_CRASH", "SQL92_RESERVED_CREATE", 
		"SQL92_RESERVED_CURRENT", "SQL92_RESERVED_CURSOR", "SQL92_RESERVED_DATE", 
		"SQL92_RESERVED_DECLARE", "SQL92_RESERVED_DEFAULT", "SQL92_RESERVED_DELETE", 
		"SQL92_RESERVED_DESC", "SQL92_RESERVED_DISTINCT", "SQL92_RESERVED_DROP", 
		"SQL92_RESERVED_ELSE", "SQL92_RESERVED_END", "SQL92_RESERVED_EXCEPTION", 
		"PLSQL_RESERVED_EXCLUSIVE", "SQL92_RESERVED_EXISTS", "SQL92_RESERVED_FALSE", 
		"SQL92_RESERVED_FETCH", "SQL92_RESERVED_FOR", "SQL92_RESERVED_FROM", "SQL92_RESERVED_GOTO", 
		"SQL92_RESERVED_GRANT", "SQL92_RESERVED_GROUP", "SQL92_RESERVED_HAVING", 
		"PLSQL_RESERVED_IDENTIFIED", "PLSQL_RESERVED_IF", "SQL92_RESERVED_IN", 
		"PLSQL_RESERVED_INDEX", "PLSQL_RESERVED_INDEXES", "SQL92_RESERVED_INSERT", 
		"SQL92_RESERVED_INTERSECT", "SQL92_RESERVED_INTO", "SQL92_RESERVED_IS", 
		"SQL92_RESERVED_LIKE", "PLSQL_RESERVED_LOCK", "PLSQL_RESERVED_MINUS", 
		"PLSQL_RESERVED_MODE", "PLSQL_RESERVED_NOCOMPRESS", "SQL92_RESERVED_NOT", 
		"PLSQL_RESERVED_NOWAIT", "SQL92_RESERVED_NULL", "SQL92_RESERVED_OF", "SQL92_RESERVED_ON", 
		"SQL92_RESERVED_OPTION", "SQL92_RESERVED_OR", "SQL92_RESERVED_ORDER", 
		"SQL92_RESERVED_OVERLAPS", "SQL92_RESERVED_PRIOR", "SQL92_RESERVED_PROCEDURE", 
		"SQL92_RESERVED_PUBLIC", "PLSQL_RESERVED_RESOURCE", "SQL92_RESERVED_REVOKE", 
		"SQL92_RESERVED_SELECT", "PLSQL_RESERVED_SHARE", "SQL92_RESERVED_SIZE", 
		"PLSQL_RESERVED_START", "PLSQL_RESERVED_TABAUTH", "SQL92_RESERVED_TABLE", 
		"SQL92_RESERVED_THE", "SQL92_RESERVED_THEN", "SQL92_RESERVED_TO", "SQL92_RESERVED_TRUE", 
		"SQL92_RESERVED_UNION", "SQL92_RESERVED_UNIQUE", "SQL92_RESERVED_UPDATE", 
		"SQL92_RESERVED_VALUES", "SQL92_RESERVED_VIEW", "PLSQL_RESERVED_VIEWS", 
		"SQL92_RESERVED_WHEN", "SQL92_RESERVED_WHERE", "SQL92_RESERVED_WITH", 
		"PLSQL_NON_RESERVED_USING", "PLSQL_NON_RESERVED_MODEL", "PLSQL_NON_RESERVED_ELSIF", 
		"PLSQL_NON_RESERVED_PIVOT", "PLSQL_NON_RESERVED_UNPIVOT", "REGULAR_ID", 
		"ZV"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "PlSql.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public PlSqlParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class Swallow_to_semiContext : ParserRuleContext {
		public Swallow_to_semiContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_swallow_to_semi; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSwallow_to_semi(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSwallow_to_semi(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSwallow_to_semi(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Swallow_to_semiContext swallow_to_semi() {
		Swallow_to_semiContext _localctx = new Swallow_to_semiContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_swallow_to_semi);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 779;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 778;
				_la = _input.La(1);
				if ( _la <= 0 || (_la==SEMICOLON) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
				}
				State = 781;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__0) | (1L << PP_IF) | (1L << PP_THEN) | (1L << PP_ELSE) | (1L << PP_ELSIF) | (1L << PP_END) | (1L << PP_ERROR) | (1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << ASSOCIATION_OPERATOR) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTEND - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MOD - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PERCENT_ISOPEN - 256)) | (1L << (PERCENT_ROWTYPE - 256)) | (1L << (PERCENT_TYPE - 256)) | (1L << (PERCENT_FOUND - 256)) | (1L << (PERCENT_NOTFOUND - 256)) | (1L << (PERCENT_ROWCOUNT - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIPE - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TO_NUMBER - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (PROMPT - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (BIT_STRING_LIT - 448)) | (1L << (HEX_STRING_LIT - 448)) | (1L << (DOUBLE_PERIOD - 448)) | (1L << (PERIOD - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (PERCENT - 448)) | (1L << (AMPERSAND - 448)) | (1L << (LEFT_PAREN - 448)) | (1L << (RIGHT_PAREN - 448)) | (1L << (DOUBLE_ASTERISK - 448)) | (1L << (ASTERISK - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (PLUS_SIGN - 512)) | (1L << (MINUS_SIGN - 512)) | (1L << (COMMA - 512)) | (1L << (SOLIDUS - 512)) | (1L << (AT_SIGN - 512)) | (1L << (ASSIGN_OP - 512)) | (1L << (BINDVAR - 512)) | (1L << (COLON - 512)) | (1L << (LESS_THAN_OR_EQUALS_OP - 512)) | (1L << (LESS_THAN_OP - 512)) | (1L << (GREATER_THAN_OR_EQUALS_OP - 512)) | (1L << (NOT_EQUAL_OP - 512)) | (1L << (CARRET_OPERATOR_PART - 512)) | (1L << (TILDE_OPERATOR_PART - 512)) | (1L << (EXCLAMATION_OPERATOR_PART - 512)) | (1L << (GREATER_THAN_OP - 512)) | (1L << (CONCATENATION_OP - 512)) | (1L << (VERTICAL_BAR - 512)) | (1L << (EQUALS_OP - 512)) | (1L << (LEFT_BRACKET - 512)) | (1L << (RIGHT_BRACKET - 512)) | (1L << (INTRODUCER - 512)) | (1L << (SPACES - 512)) | (1L << (SINGLE_LINE_COMMENT - 512)) | (1L << (MULTI_LINE_COMMENT - 512)) | (1L << (SQL92_RESERVED_ALL - 512)) | (1L << (SQL92_RESERVED_ALTER - 512)) | (1L << (SQL92_RESERVED_AND - 512)) | (1L << (SQL92_RESERVED_ANY - 512)) | (1L << (SQL92_RESERVED_AS - 512)) | (1L << (SQL92_RESERVED_ASC - 512)) | (1L << (SQL92_RESERVED_BEGIN - 512)) | (1L << (SQL92_RESERVED_BETWEEN - 512)) | (1L << (SQL92_RESERVED_BY - 512)) | (1L << (SQL92_RESERVED_CASE - 512)) | (1L << (SQL92_RESERVED_CHECK - 512)) | (1L << (PLSQL_RESERVED_CLUSTERS - 512)) | (1L << (PLSQL_RESERVED_COLAUTH - 512)) | (1L << (PLSQL_RESERVED_COMPRESS - 512)) | (1L << (SQL92_RESERVED_CONNECT - 512)) | (1L << (PLSQL_NON_RESERVED_CONNECT_BY_ROOT - 512)) | (1L << (PLSQL_RESERVED_CRASH - 512)) | (1L << (SQL92_RESERVED_CREATE - 512)) | (1L << (SQL92_RESERVED_CURRENT - 512)) | (1L << (SQL92_RESERVED_CURSOR - 512)) | (1L << (SQL92_RESERVED_DATE - 512)) | (1L << (SQL92_RESERVED_DECLARE - 512)) | (1L << (SQL92_RESERVED_DEFAULT - 512)) | (1L << (SQL92_RESERVED_DELETE - 512)) | (1L << (SQL92_RESERVED_DESC - 512)) | (1L << (SQL92_RESERVED_DISTINCT - 512)) | (1L << (SQL92_RESERVED_DROP - 512)) | (1L << (SQL92_RESERVED_ELSE - 512)) | (1L << (SQL92_RESERVED_END - 512)) | (1L << (SQL92_RESERVED_EXCEPTION - 512)) | (1L << (PLSQL_RESERVED_EXCLUSIVE - 512)) | (1L << (SQL92_RESERVED_EXISTS - 512)) | (1L << (SQL92_RESERVED_FALSE - 512)) | (1L << (SQL92_RESERVED_FETCH - 512)) | (1L << (SQL92_RESERVED_FOR - 512)) | (1L << (SQL92_RESERVED_FROM - 512)) | (1L << (SQL92_RESERVED_GOTO - 512)) | (1L << (SQL92_RESERVED_GRANT - 512)))) != 0) || ((((_la - 576)) & ~0x3f) == 0 && ((1L << (_la - 576)) & ((1L << (SQL92_RESERVED_GROUP - 576)) | (1L << (SQL92_RESERVED_HAVING - 576)) | (1L << (PLSQL_RESERVED_IDENTIFIED - 576)) | (1L << (PLSQL_RESERVED_IF - 576)) | (1L << (SQL92_RESERVED_IN - 576)) | (1L << (PLSQL_RESERVED_INDEX - 576)) | (1L << (PLSQL_RESERVED_INDEXES - 576)) | (1L << (SQL92_RESERVED_INSERT - 576)) | (1L << (SQL92_RESERVED_INTERSECT - 576)) | (1L << (SQL92_RESERVED_INTO - 576)) | (1L << (SQL92_RESERVED_IS - 576)) | (1L << (SQL92_RESERVED_LIKE - 576)) | (1L << (PLSQL_RESERVED_LOCK - 576)) | (1L << (PLSQL_RESERVED_MINUS - 576)) | (1L << (PLSQL_RESERVED_MODE - 576)) | (1L << (PLSQL_RESERVED_NOCOMPRESS - 576)) | (1L << (SQL92_RESERVED_NOT - 576)) | (1L << (PLSQL_RESERVED_NOWAIT - 576)) | (1L << (SQL92_RESERVED_NULL - 576)) | (1L << (SQL92_RESERVED_OF - 576)) | (1L << (SQL92_RESERVED_ON - 576)) | (1L << (SQL92_RESERVED_OPTION - 576)) | (1L << (SQL92_RESERVED_OR - 576)) | (1L << (SQL92_RESERVED_ORDER - 576)) | (1L << (SQL92_RESERVED_OVERLAPS - 576)) | (1L << (SQL92_RESERVED_PRIOR - 576)) | (1L << (SQL92_RESERVED_PROCEDURE - 576)) | (1L << (SQL92_RESERVED_PUBLIC - 576)) | (1L << (PLSQL_RESERVED_RESOURCE - 576)) | (1L << (SQL92_RESERVED_REVOKE - 576)) | (1L << (SQL92_RESERVED_SELECT - 576)) | (1L << (PLSQL_RESERVED_SHARE - 576)) | (1L << (SQL92_RESERVED_SIZE - 576)) | (1L << (PLSQL_RESERVED_START - 576)) | (1L << (PLSQL_RESERVED_TABAUTH - 576)) | (1L << (SQL92_RESERVED_TABLE - 576)) | (1L << (SQL92_RESERVED_THE - 576)) | (1L << (SQL92_RESERVED_THEN - 576)) | (1L << (SQL92_RESERVED_TO - 576)) | (1L << (SQL92_RESERVED_TRUE - 576)) | (1L << (SQL92_RESERVED_UNION - 576)) | (1L << (SQL92_RESERVED_UNIQUE - 576)) | (1L << (SQL92_RESERVED_UPDATE - 576)) | (1L << (SQL92_RESERVED_VALUES - 576)) | (1L << (SQL92_RESERVED_VIEW - 576)) | (1L << (PLSQL_RESERVED_VIEWS - 576)) | (1L << (SQL92_RESERVED_WHEN - 576)) | (1L << (SQL92_RESERVED_WHERE - 576)) | (1L << (SQL92_RESERVED_WITH - 576)) | (1L << (PLSQL_NON_RESERVED_USING - 576)) | (1L << (PLSQL_NON_RESERVED_MODEL - 576)) | (1L << (PLSQL_NON_RESERVED_ELSIF - 576)) | (1L << (PLSQL_NON_RESERVED_PIVOT - 576)) | (1L << (PLSQL_NON_RESERVED_UNPIVOT - 576)) | (1L << (REGULAR_ID - 576)) | (1L << (ZV - 576)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compilation_unitContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(PlSqlParser.Eof, 0); }
		public Unit_statementContext[] unit_statement() {
			return GetRuleContexts<Unit_statementContext>();
		}
		public Unit_statementContext unit_statement(int i) {
			return GetRuleContext<Unit_statementContext>(i);
		}
		public Compilation_unitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compilation_unit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCompilation_unit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCompilation_unit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompilation_unit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compilation_unitContext compilation_unit() {
		Compilation_unitContext _localctx = new Compilation_unitContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_compilation_unit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 786;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ALTER || _la==BEGIN || ((((_la - 84)) & ~0x3f) == 0 && ((1L << (_la - 84)) & ((1L << (CREATE - 84)) | (1L << (DECLARE - 84)) | (1L << (DELETE - 84)) | (1L << (DROP - 84)) | (1L << (EXPLAIN - 84)))) != 0) || ((((_la - 160)) & ~0x3f) == 0 && ((1L << (_la - 160)) & ((1L << (FUNCTION - 160)) | (1L << (INSERT - 160)) | (1L << (LOCK - 160)))) != 0) || _la==MERGE || _la==PROCEDURE || _la==SELECT || _la==UPDATE || _la==WITH || _la==LEFT_PAREN) {
				{
				{
				State = 783; unit_statement();
				}
				}
				State = 788;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 789; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sql_scriptContext : ParserRuleContext {
		public Preprocessor_statementContext[] preprocessor_statement() {
			return GetRuleContexts<Preprocessor_statementContext>();
		}
		public Preprocessor_statementContext preprocessor_statement(int i) {
			return GetRuleContext<Preprocessor_statementContext>(i);
		}
		public ITerminalNode SPACES() { return GetToken(PlSqlParser.SPACES, 0); }
		public ITerminalNode Eof() { return GetToken(PlSqlParser.Eof, 0); }
		public Unit_statementContext[] unit_statement() {
			return GetRuleContexts<Unit_statementContext>();
		}
		public Unit_statementContext unit_statement(int i) {
			return GetRuleContext<Unit_statementContext>(i);
		}
		public Sql_scriptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sql_script; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSql_script(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSql_script(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSql_script(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sql_scriptContext sql_script() {
		Sql_scriptContext _localctx = new Sql_scriptContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_sql_script);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 805;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << PP_IF) | (1L << ALTER) | (1L << BEGIN))) != 0) || ((((_la - 84)) & ~0x3f) == 0 && ((1L << (_la - 84)) & ((1L << (CREATE - 84)) | (1L << (DECLARE - 84)) | (1L << (DELETE - 84)) | (1L << (DROP - 84)) | (1L << (EXPLAIN - 84)))) != 0) || ((((_la - 160)) & ~0x3f) == 0 && ((1L << (_la - 160)) & ((1L << (FUNCTION - 160)) | (1L << (INSERT - 160)) | (1L << (LOCK - 160)))) != 0) || _la==MERGE || _la==PROCEDURE || _la==SELECT || _la==UPDATE || _la==WITH || _la==LEFT_PAREN) {
				{
				State = 803;
				switch (_input.La(1)) {
				case ALTER:
				case BEGIN:
				case CREATE:
				case DECLARE:
				case DELETE:
				case DROP:
				case EXPLAIN:
				case FUNCTION:
				case INSERT:
				case LOCK:
				case MERGE:
				case PROCEDURE:
				case SELECT:
				case UPDATE:
				case WITH:
				case LEFT_PAREN:
					{
					{
					State = 791; unit_statement();
					State = 796;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,2,_ctx);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
						if ( _alt==1 ) {
							{
							{
							State = 792; Match(SEMICOLON);
							State = 793; unit_statement();
							}
							} 
						}
						State = 798;
						_errHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(_input,2,_ctx);
					}
					State = 800;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,3,_ctx) ) {
					case 1:
						{
						State = 799; Match(SEMICOLON);
						}
						break;
					}
					}
					}
					break;
				case PP_IF:
					{
					State = 802; preprocessor_statement();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 807;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 809;
			_la = _input.La(1);
			if (_la==Eof || _la==SEMICOLON || _la==SPACES) {
				{
				State = 808;
				_la = _input.La(1);
				if ( !(_la==Eof || _la==SEMICOLON || _la==SPACES) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unit_statementContext : ParserRuleContext {
		public Alter_functionContext alter_function() {
			return GetRuleContext<Alter_functionContext>(0);
		}
		public Alter_packageContext alter_package() {
			return GetRuleContext<Alter_packageContext>(0);
		}
		public Alter_procedureContext alter_procedure() {
			return GetRuleContext<Alter_procedureContext>(0);
		}
		public Alter_sequenceContext alter_sequence() {
			return GetRuleContext<Alter_sequenceContext>(0);
		}
		public Alter_triggerContext alter_trigger() {
			return GetRuleContext<Alter_triggerContext>(0);
		}
		public Alter_typeContext alter_type() {
			return GetRuleContext<Alter_typeContext>(0);
		}
		public Create_function_bodyContext create_function_body() {
			return GetRuleContext<Create_function_bodyContext>(0);
		}
		public Create_procedure_bodyContext create_procedure_body() {
			return GetRuleContext<Create_procedure_bodyContext>(0);
		}
		public Create_packageContext create_package() {
			return GetRuleContext<Create_packageContext>(0);
		}
		public Create_sequenceContext create_sequence() {
			return GetRuleContext<Create_sequenceContext>(0);
		}
		public Create_triggerContext create_trigger() {
			return GetRuleContext<Create_triggerContext>(0);
		}
		public Create_typeContext create_type() {
			return GetRuleContext<Create_typeContext>(0);
		}
		public Drop_functionContext drop_function() {
			return GetRuleContext<Drop_functionContext>(0);
		}
		public Drop_packageContext drop_package() {
			return GetRuleContext<Drop_packageContext>(0);
		}
		public Drop_procedureContext drop_procedure() {
			return GetRuleContext<Drop_procedureContext>(0);
		}
		public Drop_sequenceContext drop_sequence() {
			return GetRuleContext<Drop_sequenceContext>(0);
		}
		public Drop_triggerContext drop_trigger() {
			return GetRuleContext<Drop_triggerContext>(0);
		}
		public Drop_typeContext drop_type() {
			return GetRuleContext<Drop_typeContext>(0);
		}
		public Data_manipulation_language_statementsContext data_manipulation_language_statements() {
			return GetRuleContext<Data_manipulation_language_statementsContext>(0);
		}
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public Unit_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unit_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterUnit_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitUnit_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnit_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unit_statementContext unit_statement() {
		Unit_statementContext _localctx = new Unit_statementContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_unit_statement);
		try {
			State = 834;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,7,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 811; alter_function();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 812; alter_package();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 813; alter_procedure();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 814; alter_sequence();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 815; alter_trigger();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 816; alter_type();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 817; create_function_body();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 818; create_procedure_body();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 819; create_package();
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 820; create_sequence();
				}
				break;

			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 821; create_trigger();
				}
				break;

			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 822; create_type();
				}
				break;

			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 823; drop_function();
				}
				break;

			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 824; drop_package();
				}
				break;

			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 825; drop_procedure();
				}
				break;

			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 826; drop_sequence();
				}
				break;

			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 827; drop_trigger();
				}
				break;

			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 828; drop_type();
				}
				break;

			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 829; data_manipulation_language_statements();
				}
				break;

			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 830; block();
				State = 831; Match(SEMICOLON);
				State = 832; Match(SOLIDUS);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Declare_wrapperContext : ParserRuleContext {
		public ITerminalNode DECLARE() { return GetToken(PlSqlParser.DECLARE, 0); }
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Declare_wrapperContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declare_wrapper; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDeclare_wrapper(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDeclare_wrapper(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclare_wrapper(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Declare_wrapperContext declare_wrapper() {
		Declare_wrapperContext _localctx = new Declare_wrapperContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_declare_wrapper);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 836; Match(DECLARE);
			State = 840;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,8,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 837; declare_spec();
					}
					} 
				}
				State = 842;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,8,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Is_or_asContext : ParserRuleContext {
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Is_or_asContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_is_or_as; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterIs_or_as(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitIs_or_as(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIs_or_as(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Is_or_asContext is_or_as() {
		Is_or_asContext _localctx = new Is_or_asContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_is_or_as);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 843;
			_la = _input.La(1);
			if ( !(_la==AS || _la==IS) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_functionContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public Drop_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDrop_function(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDrop_function(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_functionContext drop_function() {
		Drop_functionContext _localctx = new Drop_functionContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_drop_function);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 845; Match(DROP);
			State = 846; Match(FUNCTION);
			State = 847; function_name();
			State = 848; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_functionContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode COMPILE() { return GetToken(PlSqlParser.COMPILE, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlSqlParser.SETTINGS, 0); }
		public Alter_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAlter_function(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAlter_function(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_functionContext alter_function() {
		Alter_functionContext _localctx = new Alter_functionContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_alter_function);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 850; Match(ALTER);
			State = 851; Match(FUNCTION);
			State = 852; function_name();
			State = 853; Match(COMPILE);
			State = 855;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,9,_ctx) ) {
			case 1:
				{
				State = 854; Match(DEBUG);
				}
				break;
			}
			State = 860;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,10,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 857; compiler_parameters_clause();
					}
					} 
				}
				State = 862;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,10,_ctx);
			}
			State = 865;
			_la = _input.La(1);
			if (_la==REUSE) {
				{
				State = 863; Match(REUSE);
				State = 864; Match(SETTINGS);
				}
			}

			State = 867; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_function_bodyContext : ParserRuleContext {
		public Function_specContext function_spec() {
			return GetRuleContext<Function_specContext>(0);
		}
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public Create_function_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_function_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCreate_function_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCreate_function_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_function_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_function_bodyContext create_function_body() {
		Create_function_bodyContext _localctx = new Create_function_bodyContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_create_function_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 874;
			_la = _input.La(1);
			if (_la==CREATE) {
				{
				State = 869; Match(CREATE);
				State = 872;
				_la = _input.La(1);
				if (_la==OR) {
					{
					State = 870; Match(OR);
					State = 871; Match(REPLACE);
					}
				}

				}
			}

			State = 876; function_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_specContext : ParserRuleContext {
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public Invoker_rights_clauseContext[] invoker_rights_clause() {
			return GetRuleContexts<Invoker_rights_clauseContext>();
		}
		public Invoker_rights_clauseContext invoker_rights_clause(int i) {
			return GetRuleContext<Invoker_rights_clauseContext>(i);
		}
		public Parallel_enable_clauseContext[] parallel_enable_clause() {
			return GetRuleContexts<Parallel_enable_clauseContext>();
		}
		public Parallel_enable_clauseContext parallel_enable_clause(int i) {
			return GetRuleContext<Parallel_enable_clauseContext>(i);
		}
		public Result_cache_clauseContext[] result_cache_clause() {
			return GetRuleContexts<Result_cache_clauseContext>();
		}
		public Result_cache_clauseContext result_cache_clause(int i) {
			return GetRuleContext<Result_cache_clauseContext>(i);
		}
		public ITerminalNode[] DETERMINISTIC() { return GetTokens(PlSqlParser.DETERMINISTIC); }
		public ITerminalNode DETERMINISTIC(int i) {
			return GetToken(PlSqlParser.DETERMINISTIC, i);
		}
		public ITerminalNode[] PIPELINED() { return GetTokens(PlSqlParser.PIPELINED); }
		public ITerminalNode PIPELINED(int i) {
			return GetToken(PlSqlParser.PIPELINED, i);
		}
		public ITerminalNode[] AGGREGATE() { return GetTokens(PlSqlParser.AGGREGATE); }
		public ITerminalNode AGGREGATE(int i) {
			return GetToken(PlSqlParser.AGGREGATE, i);
		}
		public ITerminalNode[] USING() { return GetTokens(PlSqlParser.USING); }
		public ITerminalNode USING(int i) {
			return GetToken(PlSqlParser.USING, i);
		}
		public Implementation_type_nameContext[] implementation_type_name() {
			return GetRuleContexts<Implementation_type_nameContext>();
		}
		public Implementation_type_nameContext implementation_type_name(int i) {
			return GetRuleContext<Implementation_type_nameContext>(i);
		}
		public Is_or_asContext is_or_as() {
			return GetRuleContext<Is_or_asContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Function_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFunction_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFunction_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_specContext function_spec() {
		Function_specContext _localctx = new Function_specContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_function_spec);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 878; Match(FUNCTION);
			State = 879; function_name();
			State = 891;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 880; Match(LEFT_PAREN);
				State = 881; parameter();
				State = 886;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 882; Match(COMMA);
					State = 883; parameter();
					}
					}
					State = 888;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 889; Match(RIGHT_PAREN);
				}
			}

			State = 893; Match(RETURN);
			State = 894; type_spec();
			State = 905;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==AGGREGATE || _la==AUTHID || _la==DETERMINISTIC || ((((_la - 285)) & ~0x3f) == 0 && ((1L << (_la - 285)) & ((1L << (PARALLEL_ENABLE - 285)) | (1L << (PIPELINED - 285)) | (1L << (RESULT_CACHE - 285)))) != 0)) {
				{
				State = 903;
				switch (_input.La(1)) {
				case AUTHID:
					{
					State = 895; invoker_rights_clause();
					}
					break;
				case PARALLEL_ENABLE:
					{
					State = 896; parallel_enable_clause();
					}
					break;
				case RESULT_CACHE:
					{
					State = 897; result_cache_clause();
					}
					break;
				case DETERMINISTIC:
					{
					State = 898; Match(DETERMINISTIC);
					}
					break;
				case PIPELINED:
					{
					State = 899; Match(PIPELINED);
					}
					break;
				case AGGREGATE:
					{
					State = 900; Match(AGGREGATE);
					State = 901; Match(USING);
					State = 902; implementation_type_name();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 907;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 919;
			_la = _input.La(1);
			if (_la==AS || _la==IS) {
				{
				State = 908; is_or_as();
				State = 917;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,19,_ctx) ) {
				case 1:
					{
					State = 912;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,18,_ctx);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
						if ( _alt==1 ) {
							{
							{
							State = 909; declare_spec();
							}
							} 
						}
						State = 914;
						_errHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(_input,18,_ctx);
					}
					State = 915; body();
					}
					break;

				case 2:
					{
					State = 916; call_spec();
					}
					break;
				}
				}
			}

			State = 921; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parallel_enable_clauseContext : ParserRuleContext {
		public ITerminalNode PARALLEL_ENABLE() { return GetToken(PlSqlParser.PARALLEL_ENABLE, 0); }
		public Partition_by_clauseContext partition_by_clause() {
			return GetRuleContext<Partition_by_clauseContext>(0);
		}
		public Parallel_enable_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parallel_enable_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterParallel_enable_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitParallel_enable_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParallel_enable_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parallel_enable_clauseContext parallel_enable_clause() {
		Parallel_enable_clauseContext _localctx = new Parallel_enable_clauseContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_parallel_enable_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 923; Match(PARALLEL_ENABLE);
			State = 925;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 924; partition_by_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partition_by_clauseContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode ANY() { return GetToken(PlSqlParser.ANY, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode HASH() { return GetToken(PlSqlParser.HASH, 0); }
		public ITerminalNode RANGE() { return GetToken(PlSqlParser.RANGE, 0); }
		public Streaming_clauseContext streaming_clause() {
			return GetRuleContext<Streaming_clauseContext>(0);
		}
		public Partition_by_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partition_by_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPartition_by_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPartition_by_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartition_by_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Partition_by_clauseContext partition_by_clause() {
		Partition_by_clauseContext _localctx = new Partition_by_clauseContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_partition_by_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 927; Match(LEFT_PAREN);
			State = 928; Match(PARTITION);
			State = 929; expression();
			State = 930; Match(BY);
			State = 944;
			switch (_input.La(1)) {
			case ANY:
				{
				State = 931; Match(ANY);
				}
				break;
			case HASH:
			case RANGE:
				{
				State = 932;
				_la = _input.La(1);
				if ( !(_la==HASH || _la==RANGE) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 933; Match(LEFT_PAREN);
				State = 934; column_name();
				State = 939;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 935; Match(COMMA);
					State = 936; column_name();
					}
					}
					State = 941;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 942; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 947;
			_la = _input.La(1);
			if (_la==CLUSTER || _la==ORDER) {
				{
				State = 946; streaming_clause();
				}
			}

			State = 949; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Result_cache_clauseContext : ParserRuleContext {
		public ITerminalNode RESULT_CACHE() { return GetToken(PlSqlParser.RESULT_CACHE, 0); }
		public Relies_on_partContext relies_on_part() {
			return GetRuleContext<Relies_on_partContext>(0);
		}
		public Result_cache_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_result_cache_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterResult_cache_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitResult_cache_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitResult_cache_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Result_cache_clauseContext result_cache_clause() {
		Result_cache_clauseContext _localctx = new Result_cache_clauseContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_result_cache_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 951; Match(RESULT_CACHE);
			State = 953;
			_la = _input.La(1);
			if (_la==RELIES_ON) {
				{
				State = 952; relies_on_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Relies_on_partContext : ParserRuleContext {
		public ITerminalNode RELIES_ON() { return GetToken(PlSqlParser.RELIES_ON, 0); }
		public Tableview_nameContext[] tableview_name() {
			return GetRuleContexts<Tableview_nameContext>();
		}
		public Tableview_nameContext tableview_name(int i) {
			return GetRuleContext<Tableview_nameContext>(i);
		}
		public Relies_on_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relies_on_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRelies_on_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRelies_on_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelies_on_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Relies_on_partContext relies_on_part() {
		Relies_on_partContext _localctx = new Relies_on_partContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_relies_on_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 955; Match(RELIES_ON);
			State = 956; Match(LEFT_PAREN);
			State = 957; tableview_name();
			State = 962;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 958; Match(COMMA);
				State = 959; tableview_name();
				}
				}
				State = 964;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 965; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Streaming_clauseContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public ITerminalNode CLUSTER() { return GetToken(PlSqlParser.CLUSTER, 0); }
		public Streaming_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_streaming_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterStreaming_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitStreaming_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStreaming_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Streaming_clauseContext streaming_clause() {
		Streaming_clauseContext _localctx = new Streaming_clauseContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_streaming_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 967;
			_la = _input.La(1);
			if ( !(_la==CLUSTER || _la==ORDER) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 968; expression();
			State = 969; Match(BY);
			State = 970; Match(LEFT_PAREN);
			State = 971; column_name();
			State = 976;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 972; Match(COMMA);
				State = 973; column_name();
				}
				}
				State = 978;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 979; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_packageContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode PACKAGE() { return GetToken(PlSqlParser.PACKAGE, 0); }
		public Package_nameContext package_name() {
			return GetRuleContext<Package_nameContext>(0);
		}
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public Drop_packageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_package; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDrop_package(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDrop_package(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_package(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_packageContext drop_package() {
		Drop_packageContext _localctx = new Drop_packageContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_drop_package);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 981; Match(DROP);
			State = 982; Match(PACKAGE);
			State = 984;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,28,_ctx) ) {
			case 1:
				{
				State = 983; Match(BODY);
				}
				break;
			}
			State = 986; package_name();
			State = 987; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_packageContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode[] PACKAGE() { return GetTokens(PlSqlParser.PACKAGE); }
		public ITerminalNode PACKAGE(int i) {
			return GetToken(PlSqlParser.PACKAGE, i);
		}
		public Package_nameContext package_name() {
			return GetRuleContext<Package_nameContext>(0);
		}
		public ITerminalNode COMPILE() { return GetToken(PlSqlParser.COMPILE, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlSqlParser.SETTINGS, 0); }
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public ITerminalNode SPECIFICATION() { return GetToken(PlSqlParser.SPECIFICATION, 0); }
		public Alter_packageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_package; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAlter_package(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAlter_package(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_package(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_packageContext alter_package() {
		Alter_packageContext _localctx = new Alter_packageContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_alter_package);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 989; Match(ALTER);
			State = 990; Match(PACKAGE);
			State = 991; package_name();
			State = 992; Match(COMPILE);
			State = 994;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,29,_ctx) ) {
			case 1:
				{
				State = 993; Match(DEBUG);
				}
				break;
			}
			State = 997;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,30,_ctx) ) {
			case 1:
				{
				State = 996;
				_la = _input.La(1);
				if ( !(_la==BODY || _la==PACKAGE || _la==SPECIFICATION) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
				break;
			}
			State = 1002;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,31,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 999; compiler_parameters_clause();
					}
					} 
				}
				State = 1004;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,31,_ctx);
			}
			State = 1007;
			_la = _input.La(1);
			if (_la==REUSE) {
				{
				State = 1005; Match(REUSE);
				State = 1006; Match(SETTINGS);
				}
			}

			State = 1009; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_packageContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode PACKAGE() { return GetToken(PlSqlParser.PACKAGE, 0); }
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public Package_specContext package_spec() {
			return GetRuleContext<Package_specContext>(0);
		}
		public Package_bodyContext package_body() {
			return GetRuleContext<Package_bodyContext>(0);
		}
		public Create_packageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_package; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCreate_package(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCreate_package(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_package(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_packageContext create_package() {
		Create_packageContext _localctx = new Create_packageContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_create_package);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1011; Match(CREATE);
			State = 1014;
			_la = _input.La(1);
			if (_la==OR) {
				{
				State = 1012; Match(OR);
				State = 1013; Match(REPLACE);
				}
			}

			State = 1016; Match(PACKAGE);
			State = 1019;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,34,_ctx) ) {
			case 1:
				{
				State = 1017; package_spec();
				}
				break;

			case 2:
				{
				State = 1018; package_body();
				}
				break;
			}
			State = 1021; Match(SEMICOLON);
			State = 1022; Match(SOLIDUS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_bodyContext : ParserRuleContext {
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public Package_nameContext[] package_name() {
			return GetRuleContexts<Package_nameContext>();
		}
		public Package_nameContext package_name(int i) {
			return GetRuleContext<Package_nameContext>(i);
		}
		public Is_or_asContext is_or_as() {
			return GetRuleContext<Is_or_asContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public Package_obj_bodyContext[] package_obj_body() {
			return GetRuleContexts<Package_obj_bodyContext>();
		}
		public Package_obj_bodyContext package_obj_body(int i) {
			return GetRuleContext<Package_obj_bodyContext>(i);
		}
		public ITerminalNode BEGIN() { return GetToken(PlSqlParser.BEGIN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Exception_clauseContext exception_clause() {
			return GetRuleContext<Exception_clauseContext>(0);
		}
		public Package_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPackage_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPackage_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPackage_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Package_bodyContext package_body() {
		Package_bodyContext _localctx = new Package_bodyContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_package_body);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1024; Match(BODY);
			State = 1025; package_name();
			State = 1026; is_or_as();
			State = 1030;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,35,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1027; package_obj_body();
					}
					} 
				}
				State = 1032;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,35,_ctx);
			}
			State = 1035;
			_la = _input.La(1);
			if (_la==BEGIN) {
				{
				State = 1033; Match(BEGIN);
				State = 1034; seq_of_statements();
				}
			}

			State = 1038;
			_la = _input.La(1);
			if (_la==EXCEPTION) {
				{
				State = 1037; exception_clause();
				}
			}

			State = 1040; Match(END);
			State = 1042;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (DELIMITED_ID - 448)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 1041; package_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_specContext : ParserRuleContext {
		public Package_nameContext[] package_name() {
			return GetRuleContexts<Package_nameContext>();
		}
		public Package_nameContext package_name(int i) {
			return GetRuleContext<Package_nameContext>(i);
		}
		public Is_or_asContext is_or_as() {
			return GetRuleContext<Is_or_asContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public Package_obj_specContext[] package_obj_spec() {
			return GetRuleContexts<Package_obj_specContext>();
		}
		public Package_obj_specContext package_obj_spec(int i) {
			return GetRuleContext<Package_obj_specContext>(i);
		}
		public Package_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPackage_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPackage_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPackage_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Package_specContext package_spec() {
		Package_specContext _localctx = new Package_specContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_package_spec);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1044; package_name();
			State = 1046;
			_la = _input.La(1);
			if (_la==AUTHID) {
				{
				State = 1045; invoker_rights_clause();
				}
			}

			State = 1048; is_or_as();
			State = 1052;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,40,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1049; package_obj_spec();
					}
					} 
				}
				State = 1054;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,40,_ctx);
			}
			State = 1055; Match(END);
			State = 1057;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (DELIMITED_ID - 448)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 1056; package_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_obj_specContext : ParserRuleContext {
		public Variable_declarationContext variable_declaration() {
			return GetRuleContext<Variable_declarationContext>(0);
		}
		public Subtype_declarationContext subtype_declaration() {
			return GetRuleContext<Subtype_declarationContext>(0);
		}
		public Cursor_declarationContext cursor_declaration() {
			return GetRuleContext<Cursor_declarationContext>(0);
		}
		public Exception_declarationContext exception_declaration() {
			return GetRuleContext<Exception_declarationContext>(0);
		}
		public Pragma_declarationContext pragma_declaration() {
			return GetRuleContext<Pragma_declarationContext>(0);
		}
		public Record_declarationContext record_declaration() {
			return GetRuleContext<Record_declarationContext>(0);
		}
		public Table_declarationContext table_declaration() {
			return GetRuleContext<Table_declarationContext>(0);
		}
		public Procedure_specContext procedure_spec() {
			return GetRuleContext<Procedure_specContext>(0);
		}
		public Function_specContext function_spec() {
			return GetRuleContext<Function_specContext>(0);
		}
		public Preprocessor_statementContext preprocessor_statement() {
			return GetRuleContext<Preprocessor_statementContext>(0);
		}
		public Package_obj_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_obj_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPackage_obj_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPackage_obj_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPackage_obj_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Package_obj_specContext package_obj_spec() {
		Package_obj_specContext _localctx = new Package_obj_specContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_package_obj_spec);
		try {
			State = 1069;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,42,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1059; variable_declaration();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1060; subtype_declaration();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1061; cursor_declaration();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1062; exception_declaration();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1063; pragma_declaration();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1064; record_declaration();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1065; table_declaration();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1066; procedure_spec();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1067; function_spec();
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1068; preprocessor_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_obj_bodyContext : ParserRuleContext {
		public Variable_declarationContext variable_declaration() {
			return GetRuleContext<Variable_declarationContext>(0);
		}
		public Subtype_declarationContext subtype_declaration() {
			return GetRuleContext<Subtype_declarationContext>(0);
		}
		public Cursor_declarationContext cursor_declaration() {
			return GetRuleContext<Cursor_declarationContext>(0);
		}
		public Exception_declarationContext exception_declaration() {
			return GetRuleContext<Exception_declarationContext>(0);
		}
		public Pragma_declarationContext pragma_declaration() {
			return GetRuleContext<Pragma_declarationContext>(0);
		}
		public Record_declarationContext record_declaration() {
			return GetRuleContext<Record_declarationContext>(0);
		}
		public Table_declarationContext table_declaration() {
			return GetRuleContext<Table_declarationContext>(0);
		}
		public Create_procedure_bodyContext create_procedure_body() {
			return GetRuleContext<Create_procedure_bodyContext>(0);
		}
		public Create_function_bodyContext create_function_body() {
			return GetRuleContext<Create_function_bodyContext>(0);
		}
		public Preprocessor_statementContext preprocessor_statement() {
			return GetRuleContext<Preprocessor_statementContext>(0);
		}
		public Package_obj_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_obj_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPackage_obj_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPackage_obj_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPackage_obj_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Package_obj_bodyContext package_obj_body() {
		Package_obj_bodyContext _localctx = new Package_obj_bodyContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_package_obj_body);
		try {
			State = 1081;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,43,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1071; variable_declaration();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1072; subtype_declaration();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1073; cursor_declaration();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1074; exception_declaration();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1075; pragma_declaration();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1076; record_declaration();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1077; table_declaration();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1078; create_procedure_body();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1079; create_function_body();
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1080; preprocessor_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_procedureContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public Drop_procedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_procedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDrop_procedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDrop_procedure(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_procedure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_procedureContext drop_procedure() {
		Drop_procedureContext _localctx = new Drop_procedureContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_drop_procedure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1083; Match(DROP);
			State = 1084; Match(PROCEDURE);
			State = 1085; procedure_name();
			State = 1086; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_procedureContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public ITerminalNode COMPILE() { return GetToken(PlSqlParser.COMPILE, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlSqlParser.SETTINGS, 0); }
		public Alter_procedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_procedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAlter_procedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAlter_procedure(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_procedure(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_procedureContext alter_procedure() {
		Alter_procedureContext _localctx = new Alter_procedureContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_alter_procedure);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1088; Match(ALTER);
			State = 1089; Match(PROCEDURE);
			State = 1090; procedure_name();
			State = 1091; Match(COMPILE);
			State = 1093;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,44,_ctx) ) {
			case 1:
				{
				State = 1092; Match(DEBUG);
				}
				break;
			}
			State = 1098;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,45,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1095; compiler_parameters_clause();
					}
					} 
				}
				State = 1100;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,45,_ctx);
			}
			State = 1103;
			_la = _input.La(1);
			if (_la==REUSE) {
				{
				State = 1101; Match(REUSE);
				State = 1102; Match(SETTINGS);
				}
			}

			State = 1105; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_procedure_bodyContext : ParserRuleContext {
		public Procedure_specContext procedure_spec() {
			return GetRuleContext<Procedure_specContext>(0);
		}
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public Create_procedure_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_procedure_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCreate_procedure_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCreate_procedure_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_procedure_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_procedure_bodyContext create_procedure_body() {
		Create_procedure_bodyContext _localctx = new Create_procedure_bodyContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_create_procedure_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1112;
			_la = _input.La(1);
			if (_la==CREATE) {
				{
				State = 1107; Match(CREATE);
				State = 1110;
				_la = _input.La(1);
				if (_la==OR) {
					{
					State = 1108; Match(OR);
					State = 1109; Match(REPLACE);
					}
				}

				}
			}

			State = 1114; procedure_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Procedure_specContext : ParserRuleContext {
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public Is_or_asContext is_or_as() {
			return GetRuleContext<Is_or_asContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode EXTERNAL() { return GetToken(PlSqlParser.EXTERNAL, 0); }
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Procedure_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedure_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterProcedure_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitProcedure_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedure_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Procedure_specContext procedure_spec() {
		Procedure_specContext _localctx = new Procedure_specContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_procedure_spec);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1116; Match(PROCEDURE);
			State = 1117; procedure_name();
			State = 1129;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1118; Match(LEFT_PAREN);
				State = 1119; parameter();
				State = 1124;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1120; Match(COMMA);
					State = 1121; parameter();
					}
					}
					State = 1126;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1127; Match(RIGHT_PAREN);
				}
			}

			State = 1146;
			_la = _input.La(1);
			if (_la==AS || _la==AUTHID || _la==IS) {
				{
				State = 1132;
				_la = _input.La(1);
				if (_la==AUTHID) {
					{
					State = 1131; invoker_rights_clause();
					}
				}

				State = 1134; is_or_as();
				State = 1144;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,53,_ctx) ) {
				case 1:
					{
					State = 1138;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,52,_ctx);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
						if ( _alt==1 ) {
							{
							{
							State = 1135; declare_spec();
							}
							} 
						}
						State = 1140;
						_errHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(_input,52,_ctx);
					}
					State = 1141; body();
					}
					break;

				case 2:
					{
					State = 1142; call_spec();
					}
					break;

				case 3:
					{
					State = 1143; Match(EXTERNAL);
					}
					break;
				}
				}
			}

			State = 1148; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_triggerContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlSqlParser.TRIGGER, 0); }
		public Trigger_nameContext trigger_name() {
			return GetRuleContext<Trigger_nameContext>(0);
		}
		public Drop_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDrop_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDrop_trigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_triggerContext drop_trigger() {
		Drop_triggerContext _localctx = new Drop_triggerContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_drop_trigger);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1150; Match(DROP);
			State = 1151; Match(TRIGGER);
			State = 1152; trigger_name();
			State = 1153; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_triggerContext : ParserRuleContext {
		public Trigger_nameContext tn1;
		public Trigger_nameContext tn2;
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlSqlParser.TRIGGER, 0); }
		public Trigger_nameContext[] trigger_name() {
			return GetRuleContexts<Trigger_nameContext>();
		}
		public Trigger_nameContext trigger_name(int i) {
			return GetRuleContext<Trigger_nameContext>(i);
		}
		public ITerminalNode RENAME() { return GetToken(PlSqlParser.RENAME, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ITerminalNode COMPILE() { return GetToken(PlSqlParser.COMPILE, 0); }
		public ITerminalNode ENABLE() { return GetToken(PlSqlParser.ENABLE, 0); }
		public ITerminalNode DISABLE() { return GetToken(PlSqlParser.DISABLE, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlSqlParser.SETTINGS, 0); }
		public Alter_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAlter_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAlter_trigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_triggerContext alter_trigger() {
		Alter_triggerContext _localctx = new Alter_triggerContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_alter_trigger);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1155; Match(ALTER);
			State = 1156; Match(TRIGGER);
			State = 1157; _localctx.tn1 = trigger_name();
			State = 1176;
			switch (_input.La(1)) {
			case DISABLE:
			case ENABLE:
				{
				State = 1158;
				_la = _input.La(1);
				if ( !(_la==DISABLE || _la==ENABLE) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
				break;
			case RENAME:
				{
				State = 1159; Match(RENAME);
				State = 1160; Match(TO);
				State = 1161; _localctx.tn2 = trigger_name();
				}
				break;
			case COMPILE:
				{
				State = 1162; Match(COMPILE);
				State = 1164;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,55,_ctx) ) {
				case 1:
					{
					State = 1163; Match(DEBUG);
					}
					break;
				}
				State = 1169;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,56,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 1166; compiler_parameters_clause();
						}
						} 
					}
					State = 1171;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,56,_ctx);
				}
				State = 1174;
				_la = _input.La(1);
				if (_la==REUSE) {
					{
					State = 1172; Match(REUSE);
					State = 1173; Match(SETTINGS);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1178; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_triggerContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlSqlParser.TRIGGER, 0); }
		public Trigger_nameContext trigger_name() {
			return GetRuleContext<Trigger_nameContext>(0);
		}
		public Trigger_bodyContext trigger_body() {
			return GetRuleContext<Trigger_bodyContext>(0);
		}
		public Simple_dml_triggerContext simple_dml_trigger() {
			return GetRuleContext<Simple_dml_triggerContext>(0);
		}
		public Compound_dml_triggerContext compound_dml_trigger() {
			return GetRuleContext<Compound_dml_triggerContext>(0);
		}
		public Non_dml_triggerContext non_dml_trigger() {
			return GetRuleContext<Non_dml_triggerContext>(0);
		}
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public Trigger_follows_clauseContext trigger_follows_clause() {
			return GetRuleContext<Trigger_follows_clauseContext>(0);
		}
		public Trigger_when_clauseContext trigger_when_clause() {
			return GetRuleContext<Trigger_when_clauseContext>(0);
		}
		public ITerminalNode ENABLE() { return GetToken(PlSqlParser.ENABLE, 0); }
		public ITerminalNode DISABLE() { return GetToken(PlSqlParser.DISABLE, 0); }
		public Create_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCreate_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCreate_trigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_triggerContext create_trigger() {
		Create_triggerContext _localctx = new Create_triggerContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_create_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1180; Match(CREATE);
			State = 1183;
			_la = _input.La(1);
			if (_la==OR) {
				{
				State = 1181; Match(OR);
				State = 1182; Match(REPLACE);
				}
			}

			State = 1185; Match(TRIGGER);
			State = 1186; trigger_name();
			State = 1190;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,60,_ctx) ) {
			case 1:
				{
				State = 1187; simple_dml_trigger();
				}
				break;

			case 2:
				{
				State = 1188; compound_dml_trigger();
				}
				break;

			case 3:
				{
				State = 1189; non_dml_trigger();
				}
				break;
			}
			State = 1193;
			_la = _input.La(1);
			if (_la==FOLLOWS) {
				{
				State = 1192; trigger_follows_clause();
				}
			}

			State = 1196;
			_la = _input.La(1);
			if (_la==DISABLE || _la==ENABLE) {
				{
				State = 1195;
				_la = _input.La(1);
				if ( !(_la==DISABLE || _la==ENABLE) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
			}

			State = 1199;
			_la = _input.La(1);
			if (_la==WHEN) {
				{
				State = 1198; trigger_when_clause();
				}
			}

			State = 1201; trigger_body();
			State = 1202; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_follows_clauseContext : ParserRuleContext {
		public ITerminalNode FOLLOWS() { return GetToken(PlSqlParser.FOLLOWS, 0); }
		public Trigger_nameContext[] trigger_name() {
			return GetRuleContexts<Trigger_nameContext>();
		}
		public Trigger_nameContext trigger_name(int i) {
			return GetRuleContext<Trigger_nameContext>(i);
		}
		public Trigger_follows_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_follows_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTrigger_follows_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTrigger_follows_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_follows_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_follows_clauseContext trigger_follows_clause() {
		Trigger_follows_clauseContext _localctx = new Trigger_follows_clauseContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_trigger_follows_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1204; Match(FOLLOWS);
			State = 1205; trigger_name();
			State = 1210;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1206; Match(COMMA);
				State = 1207; trigger_name();
				}
				}
				State = 1212;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_when_clauseContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Trigger_when_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_when_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTrigger_when_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTrigger_when_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_when_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_when_clauseContext trigger_when_clause() {
		Trigger_when_clauseContext _localctx = new Trigger_when_clauseContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_trigger_when_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1213; Match(WHEN);
			State = 1214; Match(LEFT_PAREN);
			State = 1215; condition();
			State = 1216; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Simple_dml_triggerContext : ParserRuleContext {
		public Dml_event_clauseContext dml_event_clause() {
			return GetRuleContext<Dml_event_clauseContext>(0);
		}
		public ITerminalNode BEFORE() { return GetToken(PlSqlParser.BEFORE, 0); }
		public ITerminalNode AFTER() { return GetToken(PlSqlParser.AFTER, 0); }
		public ITerminalNode INSTEAD() { return GetToken(PlSqlParser.INSTEAD, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Referencing_clauseContext referencing_clause() {
			return GetRuleContext<Referencing_clauseContext>(0);
		}
		public For_each_rowContext for_each_row() {
			return GetRuleContext<For_each_rowContext>(0);
		}
		public Simple_dml_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple_dml_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSimple_dml_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSimple_dml_trigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimple_dml_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Simple_dml_triggerContext simple_dml_trigger() {
		Simple_dml_triggerContext _localctx = new Simple_dml_triggerContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_simple_dml_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1222;
			switch (_input.La(1)) {
			case BEFORE:
				{
				State = 1218; Match(BEFORE);
				}
				break;
			case AFTER:
				{
				State = 1219; Match(AFTER);
				}
				break;
			case INSTEAD:
				{
				State = 1220; Match(INSTEAD);
				State = 1221; Match(OF);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1224; dml_event_clause();
			State = 1226;
			_la = _input.La(1);
			if (_la==REFERENCING) {
				{
				State = 1225; referencing_clause();
				}
			}

			State = 1229;
			_la = _input.La(1);
			if (_la==FOR) {
				{
				State = 1228; for_each_row();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_each_rowContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public ITerminalNode EACH() { return GetToken(PlSqlParser.EACH, 0); }
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public For_each_rowContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_each_row; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFor_each_row(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFor_each_row(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_each_row(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_each_rowContext for_each_row() {
		For_each_rowContext _localctx = new For_each_rowContext(_ctx, State);
		EnterRule(_localctx, 64, RULE_for_each_row);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1231; Match(FOR);
			State = 1232; Match(EACH);
			State = 1233; Match(ROW);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compound_dml_triggerContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Dml_event_clauseContext dml_event_clause() {
			return GetRuleContext<Dml_event_clauseContext>(0);
		}
		public Referencing_clauseContext referencing_clause() {
			return GetRuleContext<Referencing_clauseContext>(0);
		}
		public Compound_dml_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compound_dml_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCompound_dml_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCompound_dml_trigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompound_dml_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compound_dml_triggerContext compound_dml_trigger() {
		Compound_dml_triggerContext _localctx = new Compound_dml_triggerContext(_ctx, State);
		EnterRule(_localctx, 66, RULE_compound_dml_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1235; Match(FOR);
			State = 1236; dml_event_clause();
			State = 1238;
			_la = _input.La(1);
			if (_la==REFERENCING) {
				{
				State = 1237; referencing_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_dml_triggerContext : ParserRuleContext {
		public Non_dml_eventContext[] non_dml_event() {
			return GetRuleContexts<Non_dml_eventContext>();
		}
		public Non_dml_eventContext non_dml_event(int i) {
			return GetRuleContext<Non_dml_eventContext>(i);
		}
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode BEFORE() { return GetToken(PlSqlParser.BEFORE, 0); }
		public ITerminalNode AFTER() { return GetToken(PlSqlParser.AFTER, 0); }
		public ITerminalNode DATABASE() { return GetToken(PlSqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(PlSqlParser.SCHEMA, 0); }
		public ITerminalNode[] OR() { return GetTokens(PlSqlParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(PlSqlParser.OR, i);
		}
		public Schema_nameContext schema_name() {
			return GetRuleContext<Schema_nameContext>(0);
		}
		public Non_dml_triggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_dml_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterNon_dml_trigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitNon_dml_trigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_dml_trigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_dml_triggerContext non_dml_trigger() {
		Non_dml_triggerContext _localctx = new Non_dml_triggerContext(_ctx, State);
		EnterRule(_localctx, 68, RULE_non_dml_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1240;
			_la = _input.La(1);
			if ( !(_la==AFTER || _la==BEFORE) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 1241; non_dml_event();
			State = 1246;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==OR) {
				{
				{
				State = 1242; Match(OR);
				State = 1243; non_dml_event();
				}
				}
				State = 1248;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1249; Match(ON);
			State = 1257;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,71,_ctx) ) {
			case 1:
				{
				State = 1250; Match(DATABASE);
				}
				break;

			case 2:
				{
				State = 1254;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,70,_ctx) ) {
				case 1:
					{
					State = 1251; schema_name();
					State = 1252; Match(PERIOD);
					}
					break;
				}
				State = 1256; Match(SCHEMA);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_bodyContext : ParserRuleContext {
		public ITerminalNode COMPOUND() { return GetToken(PlSqlParser.COMPOUND, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlSqlParser.TRIGGER, 0); }
		public ITerminalNode CALL() { return GetToken(PlSqlParser.CALL, 0); }
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Trigger_blockContext trigger_block() {
			return GetRuleContext<Trigger_blockContext>(0);
		}
		public Trigger_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTrigger_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTrigger_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_bodyContext trigger_body() {
		Trigger_bodyContext _localctx = new Trigger_bodyContext(_ctx, State);
		EnterRule(_localctx, 70, RULE_trigger_body);
		try {
			State = 1264;
			switch (_input.La(1)) {
			case COMPOUND:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1259; Match(COMPOUND);
				State = 1260; Match(TRIGGER);
				}
				break;
			case CALL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1261; Match(CALL);
				State = 1262; id();
				}
				break;
			case BEGIN:
			case DECLARE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1263; trigger_block();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Routine_clauseContext : ParserRuleContext {
		public Routine_nameContext routine_name() {
			return GetRuleContext<Routine_nameContext>(0);
		}
		public Function_argumentContext function_argument() {
			return GetRuleContext<Function_argumentContext>(0);
		}
		public Routine_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routine_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRoutine_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRoutine_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoutine_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Routine_clauseContext routine_clause() {
		Routine_clauseContext _localctx = new Routine_clauseContext(_ctx, State);
		EnterRule(_localctx, 72, RULE_routine_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1266; routine_name();
			State = 1268;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1267; function_argument();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compound_trigger_blockContext : ParserRuleContext {
		public ITerminalNode COMPOUND() { return GetToken(PlSqlParser.COMPOUND, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlSqlParser.TRIGGER, 0); }
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public Trigger_nameContext trigger_name() {
			return GetRuleContext<Trigger_nameContext>(0);
		}
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Timing_point_sectionContext[] timing_point_section() {
			return GetRuleContexts<Timing_point_sectionContext>();
		}
		public Timing_point_sectionContext timing_point_section(int i) {
			return GetRuleContext<Timing_point_sectionContext>(i);
		}
		public Compound_trigger_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compound_trigger_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCompound_trigger_block(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCompound_trigger_block(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompound_trigger_block(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compound_trigger_blockContext compound_trigger_block() {
		Compound_trigger_blockContext _localctx = new Compound_trigger_blockContext(_ctx, State);
		EnterRule(_localctx, 74, RULE_compound_trigger_block);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1270; Match(COMPOUND);
			State = 1271; Match(TRIGGER);
			State = 1275;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,74,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1272; declare_spec();
					}
					} 
				}
				State = 1277;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,74,_ctx);
			}
			State = 1279;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 1278; timing_point_section();
				}
				}
				State = 1281;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==AFTER || _la==BEFORE );
			State = 1283; Match(END);
			State = 1284; trigger_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Timing_point_sectionContext : ParserRuleContext {
		public IToken bk;
		public IToken ak;
		public ITerminalNode[] STATEMENT() { return GetTokens(PlSqlParser.STATEMENT); }
		public ITerminalNode STATEMENT(int i) {
			return GetToken(PlSqlParser.STATEMENT, i);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public Trigger_blockContext trigger_block() {
			return GetRuleContext<Trigger_blockContext>(0);
		}
		public ITerminalNode[] BEFORE() { return GetTokens(PlSqlParser.BEFORE); }
		public ITerminalNode BEFORE(int i) {
			return GetToken(PlSqlParser.BEFORE, i);
		}
		public ITerminalNode[] EACH() { return GetTokens(PlSqlParser.EACH); }
		public ITerminalNode EACH(int i) {
			return GetToken(PlSqlParser.EACH, i);
		}
		public ITerminalNode[] ROW() { return GetTokens(PlSqlParser.ROW); }
		public ITerminalNode ROW(int i) {
			return GetToken(PlSqlParser.ROW, i);
		}
		public ITerminalNode[] AFTER() { return GetTokens(PlSqlParser.AFTER); }
		public ITerminalNode AFTER(int i) {
			return GetToken(PlSqlParser.AFTER, i);
		}
		public Timing_point_sectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timing_point_section; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTiming_point_section(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTiming_point_section(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTiming_point_section(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Timing_point_sectionContext timing_point_section() {
		Timing_point_sectionContext _localctx = new Timing_point_sectionContext(_ctx, State);
		EnterRule(_localctx, 76, RULE_timing_point_section);
		try {
			State = 1322;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,76,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1286; _localctx.bk = Match(BEFORE);
				State = 1287; Match(STATEMENT);
				State = 1288; Match(IS);
				State = 1289; trigger_block();
				State = 1290; Match(BEFORE);
				State = 1291; Match(STATEMENT);
				State = 1292; Match(SEMICOLON);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1294; _localctx.bk = Match(BEFORE);
				State = 1295; Match(EACH);
				State = 1296; Match(ROW);
				State = 1297; Match(IS);
				State = 1298; trigger_block();
				State = 1299; Match(BEFORE);
				State = 1300; Match(EACH);
				State = 1301; Match(ROW);
				State = 1302; Match(SEMICOLON);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1304; _localctx.ak = Match(AFTER);
				State = 1305; Match(STATEMENT);
				State = 1306; Match(IS);
				State = 1307; trigger_block();
				State = 1308; Match(AFTER);
				State = 1309; Match(STATEMENT);
				State = 1310; Match(SEMICOLON);
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1312; _localctx.ak = Match(AFTER);
				State = 1313; Match(EACH);
				State = 1314; Match(ROW);
				State = 1315; Match(IS);
				State = 1316; trigger_block();
				State = 1317; Match(AFTER);
				State = 1318; Match(EACH);
				State = 1319; Match(ROW);
				State = 1320; Match(SEMICOLON);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_dml_eventContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode ANALYZE() { return GetToken(PlSqlParser.ANALYZE, 0); }
		public ITerminalNode ASSOCIATE() { return GetToken(PlSqlParser.ASSOCIATE, 0); }
		public ITerminalNode STATISTICS() { return GetToken(PlSqlParser.STATISTICS, 0); }
		public ITerminalNode AUDIT() { return GetToken(PlSqlParser.AUDIT, 0); }
		public ITerminalNode COMMENT() { return GetToken(PlSqlParser.COMMENT, 0); }
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode DISASSOCIATE() { return GetToken(PlSqlParser.DISASSOCIATE, 0); }
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode GRANT() { return GetToken(PlSqlParser.GRANT, 0); }
		public ITerminalNode NOAUDIT() { return GetToken(PlSqlParser.NOAUDIT, 0); }
		public ITerminalNode RENAME() { return GetToken(PlSqlParser.RENAME, 0); }
		public ITerminalNode REVOKE() { return GetToken(PlSqlParser.REVOKE, 0); }
		public ITerminalNode TRUNCATE() { return GetToken(PlSqlParser.TRUNCATE, 0); }
		public ITerminalNode DDL() { return GetToken(PlSqlParser.DDL, 0); }
		public ITerminalNode STARTUP() { return GetToken(PlSqlParser.STARTUP, 0); }
		public ITerminalNode SHUTDOWN() { return GetToken(PlSqlParser.SHUTDOWN, 0); }
		public ITerminalNode DB_ROLE_CHANGE() { return GetToken(PlSqlParser.DB_ROLE_CHANGE, 0); }
		public ITerminalNode LOGON() { return GetToken(PlSqlParser.LOGON, 0); }
		public ITerminalNode LOGOFF() { return GetToken(PlSqlParser.LOGOFF, 0); }
		public ITerminalNode SERVERERROR() { return GetToken(PlSqlParser.SERVERERROR, 0); }
		public ITerminalNode SUSPEND() { return GetToken(PlSqlParser.SUSPEND, 0); }
		public ITerminalNode DATABASE() { return GetToken(PlSqlParser.DATABASE, 0); }
		public ITerminalNode SCHEMA() { return GetToken(PlSqlParser.SCHEMA, 0); }
		public ITerminalNode FOLLOWS() { return GetToken(PlSqlParser.FOLLOWS, 0); }
		public Non_dml_eventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_dml_event; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterNon_dml_event(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitNon_dml_event(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_dml_event(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_dml_eventContext non_dml_event() {
		Non_dml_eventContext _localctx = new Non_dml_eventContext(_ctx, State);
		EnterRule(_localctx, 78, RULE_non_dml_event);
		try {
			State = 1350;
			switch (_input.La(1)) {
			case ALTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1324; Match(ALTER);
				}
				break;
			case ANALYZE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1325; Match(ANALYZE);
				}
				break;
			case ASSOCIATE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1326; Match(ASSOCIATE);
				State = 1327; Match(STATISTICS);
				}
				break;
			case AUDIT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1328; Match(AUDIT);
				}
				break;
			case COMMENT:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1329; Match(COMMENT);
				}
				break;
			case CREATE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1330; Match(CREATE);
				}
				break;
			case DISASSOCIATE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1331; Match(DISASSOCIATE);
				State = 1332; Match(STATISTICS);
				}
				break;
			case DROP:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1333; Match(DROP);
				}
				break;
			case GRANT:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1334; Match(GRANT);
				}
				break;
			case NOAUDIT:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1335; Match(NOAUDIT);
				}
				break;
			case RENAME:
				EnterOuterAlt(_localctx, 11);
				{
				State = 1336; Match(RENAME);
				}
				break;
			case REVOKE:
				EnterOuterAlt(_localctx, 12);
				{
				State = 1337; Match(REVOKE);
				}
				break;
			case TRUNCATE:
				EnterOuterAlt(_localctx, 13);
				{
				State = 1338; Match(TRUNCATE);
				}
				break;
			case DDL:
				EnterOuterAlt(_localctx, 14);
				{
				State = 1339; Match(DDL);
				}
				break;
			case STARTUP:
				EnterOuterAlt(_localctx, 15);
				{
				State = 1340; Match(STARTUP);
				}
				break;
			case SHUTDOWN:
				EnterOuterAlt(_localctx, 16);
				{
				State = 1341; Match(SHUTDOWN);
				}
				break;
			case DB_ROLE_CHANGE:
				EnterOuterAlt(_localctx, 17);
				{
				State = 1342; Match(DB_ROLE_CHANGE);
				}
				break;
			case LOGON:
				EnterOuterAlt(_localctx, 18);
				{
				State = 1343; Match(LOGON);
				}
				break;
			case LOGOFF:
				EnterOuterAlt(_localctx, 19);
				{
				State = 1344; Match(LOGOFF);
				}
				break;
			case SERVERERROR:
				EnterOuterAlt(_localctx, 20);
				{
				State = 1345; Match(SERVERERROR);
				}
				break;
			case SUSPEND:
				EnterOuterAlt(_localctx, 21);
				{
				State = 1346; Match(SUSPEND);
				}
				break;
			case DATABASE:
				EnterOuterAlt(_localctx, 22);
				{
				State = 1347; Match(DATABASE);
				}
				break;
			case SCHEMA:
				EnterOuterAlt(_localctx, 23);
				{
				State = 1348; Match(SCHEMA);
				}
				break;
			case FOLLOWS:
				EnterOuterAlt(_localctx, 24);
				{
				State = 1349; Match(FOLLOWS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_event_clauseContext : ParserRuleContext {
		public Dml_event_elementContext[] dml_event_element() {
			return GetRuleContexts<Dml_event_elementContext>();
		}
		public Dml_event_elementContext dml_event_element(int i) {
			return GetRuleContext<Dml_event_elementContext>(i);
		}
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode[] OR() { return GetTokens(PlSqlParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(PlSqlParser.OR, i);
		}
		public Dml_event_nested_clauseContext dml_event_nested_clause() {
			return GetRuleContext<Dml_event_nested_clauseContext>(0);
		}
		public Dml_event_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_event_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDml_event_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDml_event_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDml_event_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dml_event_clauseContext dml_event_clause() {
		Dml_event_clauseContext _localctx = new Dml_event_clauseContext(_ctx, State);
		EnterRule(_localctx, 80, RULE_dml_event_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1352; dml_event_element();
			State = 1357;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==OR) {
				{
				{
				State = 1353; Match(OR);
				State = 1354; dml_event_element();
				}
				}
				State = 1359;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1360; Match(ON);
			State = 1362;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,79,_ctx) ) {
			case 1:
				{
				State = 1361; dml_event_nested_clause();
				}
				break;
			}
			State = 1364; tableview_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_event_elementContext : ParserRuleContext {
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public ITerminalNode INSERT() { return GetToken(PlSqlParser.INSERT, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Dml_event_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_event_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDml_event_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDml_event_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDml_event_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dml_event_elementContext dml_event_element() {
		Dml_event_elementContext _localctx = new Dml_event_elementContext(_ctx, State);
		EnterRule(_localctx, 82, RULE_dml_event_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1366;
			_la = _input.La(1);
			if ( !(_la==DELETE || _la==INSERT || _la==UPDATE) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 1376;
			_la = _input.La(1);
			if (_la==OF) {
				{
				State = 1367; Match(OF);
				State = 1368; column_name();
				State = 1373;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1369; Match(COMMA);
					State = 1370; column_name();
					}
					}
					State = 1375;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_event_nested_clauseContext : ParserRuleContext {
		public ITerminalNode NESTED() { return GetToken(PlSqlParser.NESTED, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Dml_event_nested_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_event_nested_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDml_event_nested_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDml_event_nested_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDml_event_nested_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dml_event_nested_clauseContext dml_event_nested_clause() {
		Dml_event_nested_clauseContext _localctx = new Dml_event_nested_clauseContext(_ctx, State);
		EnterRule(_localctx, 84, RULE_dml_event_nested_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1378; Match(NESTED);
			State = 1379; Match(TABLE);
			State = 1380; tableview_name();
			State = 1381; Match(OF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Referencing_clauseContext : ParserRuleContext {
		public ITerminalNode REFERENCING() { return GetToken(PlSqlParser.REFERENCING, 0); }
		public Referencing_elementContext[] referencing_element() {
			return GetRuleContexts<Referencing_elementContext>();
		}
		public Referencing_elementContext referencing_element(int i) {
			return GetRuleContext<Referencing_elementContext>(i);
		}
		public Referencing_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referencing_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterReferencing_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitReferencing_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReferencing_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Referencing_clauseContext referencing_clause() {
		Referencing_clauseContext _localctx = new Referencing_clauseContext(_ctx, State);
		EnterRule(_localctx, 86, RULE_referencing_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1383; Match(REFERENCING);
			State = 1385;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 1384; referencing_element();
				}
				}
				State = 1387;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( ((((_la - 246)) & ~0x3f) == 0 && ((1L << (_la - 246)) & ((1L << (NEW - 246)) | (1L << (OLD - 246)) | (1L << (PARENT - 246)))) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Referencing_elementContext : ParserRuleContext {
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public ITerminalNode NEW() { return GetToken(PlSqlParser.NEW, 0); }
		public ITerminalNode OLD() { return GetToken(PlSqlParser.OLD, 0); }
		public ITerminalNode PARENT() { return GetToken(PlSqlParser.PARENT, 0); }
		public Referencing_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_referencing_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterReferencing_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitReferencing_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReferencing_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Referencing_elementContext referencing_element() {
		Referencing_elementContext _localctx = new Referencing_elementContext(_ctx, State);
		EnterRule(_localctx, 88, RULE_referencing_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1389;
			_la = _input.La(1);
			if ( !(((((_la - 246)) & ~0x3f) == 0 && ((1L << (_la - 246)) & ((1L << (NEW - 246)) | (1L << (OLD - 246)) | (1L << (PARENT - 246)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 1390; column_alias();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_typeContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public ITerminalNode VALIDATE() { return GetToken(PlSqlParser.VALIDATE, 0); }
		public Drop_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDrop_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDrop_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_typeContext drop_type() {
		Drop_typeContext _localctx = new Drop_typeContext(_ctx, State);
		EnterRule(_localctx, 90, RULE_drop_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1392; Match(DROP);
			State = 1393; Match(TYPE);
			State = 1395;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,83,_ctx) ) {
			case 1:
				{
				State = 1394; Match(BODY);
				}
				break;
			}
			State = 1397; type_name();
			State = 1399;
			_la = _input.La(1);
			if (_la==FORCE || _la==VALIDATE) {
				{
				State = 1398;
				_la = _input.La(1);
				if ( !(_la==FORCE || _la==VALIDATE) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
			}

			State = 1401; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_typeContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public Compile_type_clauseContext compile_type_clause() {
			return GetRuleContext<Compile_type_clauseContext>(0);
		}
		public Replace_type_clauseContext replace_type_clause() {
			return GetRuleContext<Replace_type_clauseContext>(0);
		}
		public Alter_method_specContext alter_method_spec() {
			return GetRuleContext<Alter_method_specContext>(0);
		}
		public Alter_collection_clausesContext alter_collection_clauses() {
			return GetRuleContext<Alter_collection_clausesContext>(0);
		}
		public Modifier_clauseContext modifier_clause() {
			return GetRuleContext<Modifier_clauseContext>(0);
		}
		public Dependent_handling_clauseContext dependent_handling_clause() {
			return GetRuleContext<Dependent_handling_clauseContext>(0);
		}
		public Alter_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAlter_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAlter_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_typeContext alter_type() {
		Alter_typeContext _localctx = new Alter_typeContext(_ctx, State);
		EnterRule(_localctx, 92, RULE_alter_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1403; Match(ALTER);
			State = 1404; Match(TYPE);
			State = 1405; type_name();
			State = 1411;
			switch (_input.La(1)) {
			case COMPILE:
				{
				State = 1406; compile_type_clause();
				}
				break;
			case REPLACE:
				{
				State = 1407; replace_type_clause();
				}
				break;
			case ADD:
			case DROP:
				{
				State = 1408; alter_method_spec();
				}
				break;
			case MODIFY:
				{
				State = 1409; alter_collection_clauses();
				}
				break;
			case FINAL:
			case INSTANTIABLE:
			case NOT:
			case OVERRIDING:
				{
				State = 1410; modifier_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1414;
			_la = _input.La(1);
			if (_la==CASCADE || _la==INVALIDATE) {
				{
				State = 1413; dependent_handling_clause();
				}
			}

			State = 1416; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compile_type_clauseContext : ParserRuleContext {
		public ITerminalNode COMPILE() { return GetToken(PlSqlParser.COMPILE, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public Compiler_parameters_clauseContext[] compiler_parameters_clause() {
			return GetRuleContexts<Compiler_parameters_clauseContext>();
		}
		public Compiler_parameters_clauseContext compiler_parameters_clause(int i) {
			return GetRuleContext<Compiler_parameters_clauseContext>(i);
		}
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlSqlParser.SETTINGS, 0); }
		public ITerminalNode SPECIFICATION() { return GetToken(PlSqlParser.SPECIFICATION, 0); }
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public Compile_type_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compile_type_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCompile_type_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCompile_type_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompile_type_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compile_type_clauseContext compile_type_clause() {
		Compile_type_clauseContext _localctx = new Compile_type_clauseContext(_ctx, State);
		EnterRule(_localctx, 94, RULE_compile_type_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1418; Match(COMPILE);
			State = 1420;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,87,_ctx) ) {
			case 1:
				{
				State = 1419; Match(DEBUG);
				}
				break;
			}
			State = 1423;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,88,_ctx) ) {
			case 1:
				{
				State = 1422;
				_la = _input.La(1);
				if ( !(_la==BODY || _la==SPECIFICATION) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
				break;
			}
			State = 1428;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,89,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1425; compiler_parameters_clause();
					}
					} 
				}
				State = 1430;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,89,_ctx);
			}
			State = 1433;
			_la = _input.La(1);
			if (_la==REUSE) {
				{
				State = 1431; Match(REUSE);
				State = 1432; Match(SETTINGS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Replace_type_clauseContext : ParserRuleContext {
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode OBJECT() { return GetToken(PlSqlParser.OBJECT, 0); }
		public Object_member_specContext[] object_member_spec() {
			return GetRuleContexts<Object_member_specContext>();
		}
		public Object_member_specContext object_member_spec(int i) {
			return GetRuleContext<Object_member_specContext>(i);
		}
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public Replace_type_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_replace_type_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterReplace_type_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitReplace_type_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReplace_type_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Replace_type_clauseContext replace_type_clause() {
		Replace_type_clauseContext _localctx = new Replace_type_clauseContext(_ctx, State);
		EnterRule(_localctx, 96, RULE_replace_type_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1435; Match(REPLACE);
			State = 1437;
			_la = _input.La(1);
			if (_la==AUTHID) {
				{
				State = 1436; invoker_rights_clause();
				}
			}

			State = 1439; Match(AS);
			State = 1440; Match(OBJECT);
			State = 1441; Match(LEFT_PAREN);
			State = 1442; object_member_spec();
			State = 1447;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1443; Match(COMMA);
				State = 1444; object_member_spec();
				}
				}
				State = 1449;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1450; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_method_specContext : ParserRuleContext {
		public Alter_method_elementContext[] alter_method_element() {
			return GetRuleContexts<Alter_method_elementContext>();
		}
		public Alter_method_elementContext alter_method_element(int i) {
			return GetRuleContext<Alter_method_elementContext>(i);
		}
		public Alter_method_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_method_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAlter_method_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAlter_method_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_method_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_method_specContext alter_method_spec() {
		Alter_method_specContext _localctx = new Alter_method_specContext(_ctx, State);
		EnterRule(_localctx, 98, RULE_alter_method_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1452; alter_method_element();
			State = 1457;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1453; Match(COMMA);
				State = 1454; alter_method_element();
				}
				}
				State = 1459;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_method_elementContext : ParserRuleContext {
		public ITerminalNode ADD() { return GetToken(PlSqlParser.ADD, 0); }
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public Map_order_function_specContext map_order_function_spec() {
			return GetRuleContext<Map_order_function_specContext>(0);
		}
		public Subprogram_specContext subprogram_spec() {
			return GetRuleContext<Subprogram_specContext>(0);
		}
		public Alter_method_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_method_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAlter_method_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAlter_method_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_method_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_method_elementContext alter_method_element() {
		Alter_method_elementContext _localctx = new Alter_method_elementContext(_ctx, State);
		EnterRule(_localctx, 100, RULE_alter_method_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1460;
			_la = _input.La(1);
			if ( !(_la==ADD || _la==DROP) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 1463;
			switch (_input.La(1)) {
			case MAP:
			case ORDER:
				{
				State = 1461; map_order_function_spec();
				}
				break;
			case MEMBER:
			case STATIC:
				{
				State = 1462; subprogram_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_attribute_definitionContext : ParserRuleContext {
		public ITerminalNode ATTRIBUTE() { return GetToken(PlSqlParser.ATTRIBUTE, 0); }
		public ITerminalNode ADD() { return GetToken(PlSqlParser.ADD, 0); }
		public ITerminalNode MODIFY() { return GetToken(PlSqlParser.MODIFY, 0); }
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public Attribute_definitionContext[] attribute_definition() {
			return GetRuleContexts<Attribute_definitionContext>();
		}
		public Attribute_definitionContext attribute_definition(int i) {
			return GetRuleContext<Attribute_definitionContext>(i);
		}
		public Alter_attribute_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_attribute_definition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAlter_attribute_definition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAlter_attribute_definition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_attribute_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_attribute_definitionContext alter_attribute_definition() {
		Alter_attribute_definitionContext _localctx = new Alter_attribute_definitionContext(_ctx, State);
		EnterRule(_localctx, 102, RULE_alter_attribute_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1465;
			_la = _input.La(1);
			if ( !(_la==ADD || _la==DROP || _la==MODIFY) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 1466; Match(ATTRIBUTE);
			State = 1479;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 1467; attribute_definition();
				}
				break;
			case LEFT_PAREN:
				{
				State = 1468; Match(LEFT_PAREN);
				State = 1469; attribute_definition();
				State = 1474;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1470; Match(COMMA);
					State = 1471; attribute_definition();
					}
					}
					State = 1476;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1477; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Attribute_definitionContext : ParserRuleContext {
		public Attribute_nameContext attribute_name() {
			return GetRuleContext<Attribute_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Attribute_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attribute_definition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAttribute_definition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAttribute_definition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAttribute_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Attribute_definitionContext attribute_definition() {
		Attribute_definitionContext _localctx = new Attribute_definitionContext(_ctx, State);
		EnterRule(_localctx, 104, RULE_attribute_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1481; attribute_name();
			State = 1483;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (DELIMITED_ID - 448)))) != 0) || _la==REGULAR_ID) {
				{
				State = 1482; type_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_collection_clausesContext : ParserRuleContext {
		public ITerminalNode MODIFY() { return GetToken(PlSqlParser.MODIFY, 0); }
		public ITerminalNode LIMIT() { return GetToken(PlSqlParser.LIMIT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ELEMENT() { return GetToken(PlSqlParser.ELEMENT, 0); }
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Alter_collection_clausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_collection_clauses; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAlter_collection_clauses(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAlter_collection_clauses(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_collection_clauses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_collection_clausesContext alter_collection_clauses() {
		Alter_collection_clausesContext _localctx = new Alter_collection_clausesContext(_ctx, State);
		EnterRule(_localctx, 106, RULE_alter_collection_clauses);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1485; Match(MODIFY);
			State = 1491;
			switch (_input.La(1)) {
			case LIMIT:
				{
				State = 1486; Match(LIMIT);
				State = 1487; expression();
				}
				break;
			case ELEMENT:
				{
				State = 1488; Match(ELEMENT);
				State = 1489; Match(TYPE);
				State = 1490; type_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dependent_handling_clauseContext : ParserRuleContext {
		public ITerminalNode INVALIDATE() { return GetToken(PlSqlParser.INVALIDATE, 0); }
		public ITerminalNode CASCADE() { return GetToken(PlSqlParser.CASCADE, 0); }
		public ITerminalNode CONVERT() { return GetToken(PlSqlParser.CONVERT, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ITerminalNode SUBSTITUTABLE() { return GetToken(PlSqlParser.SUBSTITUTABLE, 0); }
		public ITerminalNode INCLUDING() { return GetToken(PlSqlParser.INCLUDING, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public ITerminalNode DATA() { return GetToken(PlSqlParser.DATA, 0); }
		public Dependent_exceptions_partContext dependent_exceptions_part() {
			return GetRuleContext<Dependent_exceptions_partContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public Dependent_handling_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dependent_handling_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDependent_handling_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDependent_handling_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDependent_handling_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dependent_handling_clauseContext dependent_handling_clause() {
		Dependent_handling_clauseContext _localctx = new Dependent_handling_clauseContext(_ctx, State);
		EnterRule(_localctx, 108, RULE_dependent_handling_clause);
		int _la;
		try {
			State = 1509;
			switch (_input.La(1)) {
			case INVALIDATE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1493; Match(INVALIDATE);
				}
				break;
			case CASCADE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1494; Match(CASCADE);
				State = 1504;
				switch (_input.La(1)) {
				case CONVERT:
					{
					State = 1495; Match(CONVERT);
					State = 1496; Match(TO);
					State = 1497; Match(SUBSTITUTABLE);
					}
					break;
				case INCLUDING:
				case NOT:
					{
					State = 1499;
					_la = _input.La(1);
					if (_la==NOT) {
						{
						State = 1498; Match(NOT);
						}
					}

					State = 1501; Match(INCLUDING);
					State = 1502; Match(TABLE);
					State = 1503; Match(DATA);
					}
					break;
				case EXCEPTIONS:
				case FORCE:
				case SEMICOLON:
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1507;
				_la = _input.La(1);
				if (_la==EXCEPTIONS || _la==FORCE) {
					{
					State = 1506; dependent_exceptions_part();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dependent_exceptions_partContext : ParserRuleContext {
		public ITerminalNode EXCEPTIONS() { return GetToken(PlSqlParser.EXCEPTIONS, 0); }
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public Dependent_exceptions_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dependent_exceptions_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDependent_exceptions_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDependent_exceptions_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDependent_exceptions_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dependent_exceptions_partContext dependent_exceptions_part() {
		Dependent_exceptions_partContext _localctx = new Dependent_exceptions_partContext(_ctx, State);
		EnterRule(_localctx, 110, RULE_dependent_exceptions_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1512;
			_la = _input.La(1);
			if (_la==FORCE) {
				{
				State = 1511; Match(FORCE);
				}
			}

			State = 1514; Match(EXCEPTIONS);
			State = 1515; Match(INTO);
			State = 1516; tableview_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_typeContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public Type_definitionContext type_definition() {
			return GetRuleContext<Type_definitionContext>(0);
		}
		public Type_bodyContext type_body() {
			return GetRuleContext<Type_bodyContext>(0);
		}
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public Create_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCreate_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCreate_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_typeContext create_type() {
		Create_typeContext _localctx = new Create_typeContext(_ctx, State);
		EnterRule(_localctx, 112, RULE_create_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1518; Match(CREATE);
			State = 1521;
			_la = _input.La(1);
			if (_la==OR) {
				{
				State = 1519; Match(OR);
				State = 1520; Match(REPLACE);
				}
			}

			State = 1523; Match(TYPE);
			State = 1526;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,105,_ctx) ) {
			case 1:
				{
				State = 1524; type_definition();
				}
				break;

			case 2:
				{
				State = 1525; type_body();
				}
				break;
			}
			State = 1528; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_definitionContext : ParserRuleContext {
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode OID() { return GetToken(PlSqlParser.OID, 0); }
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public Object_type_defContext object_type_def() {
			return GetRuleContext<Object_type_defContext>(0);
		}
		public Type_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_definition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterType_definition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitType_definition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_definitionContext type_definition() {
		Type_definitionContext _localctx = new Type_definitionContext(_ctx, State);
		EnterRule(_localctx, 114, RULE_type_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1530; type_name();
			State = 1533;
			_la = _input.La(1);
			if (_la==OID) {
				{
				State = 1531; Match(OID);
				State = 1532; Match(CHAR_STRING);
				}
			}

			State = 1536;
			_la = _input.La(1);
			if (_la==AS || _la==AUTHID || _la==IS || _la==UNDER) {
				{
				State = 1535; object_type_def();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_type_defContext : ParserRuleContext {
		public Object_as_partContext object_as_part() {
			return GetRuleContext<Object_as_partContext>(0);
		}
		public Object_under_partContext object_under_part() {
			return GetRuleContext<Object_under_partContext>(0);
		}
		public Invoker_rights_clauseContext invoker_rights_clause() {
			return GetRuleContext<Invoker_rights_clauseContext>(0);
		}
		public Sqlj_object_typeContext sqlj_object_type() {
			return GetRuleContext<Sqlj_object_typeContext>(0);
		}
		public Object_member_specContext[] object_member_spec() {
			return GetRuleContexts<Object_member_specContext>();
		}
		public Object_member_specContext object_member_spec(int i) {
			return GetRuleContext<Object_member_specContext>(i);
		}
		public Modifier_clauseContext[] modifier_clause() {
			return GetRuleContexts<Modifier_clauseContext>();
		}
		public Modifier_clauseContext modifier_clause(int i) {
			return GetRuleContext<Modifier_clauseContext>(i);
		}
		public Object_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_type_def; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterObject_type_def(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitObject_type_def(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_type_defContext object_type_def() {
		Object_type_defContext _localctx = new Object_type_defContext(_ctx, State);
		EnterRule(_localctx, 116, RULE_object_type_def);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1539;
			_la = _input.La(1);
			if (_la==AUTHID) {
				{
				State = 1538; invoker_rights_clause();
				}
			}

			State = 1543;
			switch (_input.La(1)) {
			case AS:
			case IS:
				{
				State = 1541; object_as_part();
				}
				break;
			case UNDER:
				{
				State = 1542; object_under_part();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1546;
			_la = _input.La(1);
			if (_la==EXTERNAL) {
				{
				State = 1545; sqlj_object_type();
				}
			}

			State = 1559;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1548; Match(LEFT_PAREN);
				State = 1549; object_member_spec();
				State = 1554;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1550; Match(COMMA);
					State = 1551; object_member_spec();
					}
					}
					State = 1556;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1557; Match(RIGHT_PAREN);
				}
			}

			State = 1564;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==FINAL || _la==INSTANTIABLE || _la==NOT || _la==OVERRIDING) {
				{
				{
				State = 1561; modifier_clause();
				}
				}
				State = 1566;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_as_partContext : ParserRuleContext {
		public Is_or_asContext is_or_as() {
			return GetRuleContext<Is_or_asContext>(0);
		}
		public ITerminalNode OBJECT() { return GetToken(PlSqlParser.OBJECT, 0); }
		public Varray_type_defContext varray_type_def() {
			return GetRuleContext<Varray_type_defContext>(0);
		}
		public Nested_table_type_defContext nested_table_type_def() {
			return GetRuleContext<Nested_table_type_defContext>(0);
		}
		public Object_as_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_as_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterObject_as_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitObject_as_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_as_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_as_partContext object_as_part() {
		Object_as_partContext _localctx = new Object_as_partContext(_ctx, State);
		EnterRule(_localctx, 118, RULE_object_as_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1567; is_or_as();
			State = 1571;
			switch (_input.La(1)) {
			case OBJECT:
				{
				State = 1568; Match(OBJECT);
				}
				break;
			case VARRAY:
			case VARYING:
				{
				State = 1569; varray_type_def();
				}
				break;
			case TABLE:
				{
				State = 1570; nested_table_type_def();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_under_partContext : ParserRuleContext {
		public ITerminalNode UNDER() { return GetToken(PlSqlParser.UNDER, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Object_under_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_under_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterObject_under_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitObject_under_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_under_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_under_partContext object_under_part() {
		Object_under_partContext _localctx = new Object_under_partContext(_ctx, State);
		EnterRule(_localctx, 120, RULE_object_under_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1573; Match(UNDER);
			State = 1574; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Nested_table_type_defContext : ParserRuleContext {
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Nested_table_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nested_table_type_def; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterNested_table_type_def(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitNested_table_type_def(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNested_table_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Nested_table_type_defContext nested_table_type_def() {
		Nested_table_type_defContext _localctx = new Nested_table_type_defContext(_ctx, State);
		EnterRule(_localctx, 122, RULE_nested_table_type_def);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1576; Match(TABLE);
			State = 1577; Match(OF);
			State = 1578; type_spec();
			State = 1581;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,115,_ctx) ) {
			case 1:
				{
				State = 1579; Match(NOT);
				State = 1580; Match(NULL);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sqlj_object_typeContext : ParserRuleContext {
		public ITerminalNode EXTERNAL() { return GetToken(PlSqlParser.EXTERNAL, 0); }
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode LANGUAGE() { return GetToken(PlSqlParser.LANGUAGE, 0); }
		public ITerminalNode JAVA() { return GetToken(PlSqlParser.JAVA, 0); }
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode SQLDATA() { return GetToken(PlSqlParser.SQLDATA, 0); }
		public ITerminalNode CUSTOMDATUM() { return GetToken(PlSqlParser.CUSTOMDATUM, 0); }
		public ITerminalNode ORADATA() { return GetToken(PlSqlParser.ORADATA, 0); }
		public Sqlj_object_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlj_object_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSqlj_object_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSqlj_object_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqlj_object_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sqlj_object_typeContext sqlj_object_type() {
		Sqlj_object_typeContext _localctx = new Sqlj_object_typeContext(_ctx, State);
		EnterRule(_localctx, 124, RULE_sqlj_object_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1583; Match(EXTERNAL);
			State = 1584; Match(NAME);
			State = 1585; expression();
			State = 1586; Match(LANGUAGE);
			State = 1587; Match(JAVA);
			State = 1588; Match(USING);
			State = 1589;
			_la = _input.La(1);
			if ( !(_la==CUSTOMDATUM || _la==ORADATA || _la==SQLDATA) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_bodyContext : ParserRuleContext {
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public Is_or_asContext is_or_as() {
			return GetRuleContext<Is_or_asContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public Type_body_elementsContext[] type_body_elements() {
			return GetRuleContexts<Type_body_elementsContext>();
		}
		public Type_body_elementsContext type_body_elements(int i) {
			return GetRuleContext<Type_body_elementsContext>(i);
		}
		public Type_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterType_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitType_body(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_body(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_bodyContext type_body() {
		Type_bodyContext _localctx = new Type_bodyContext(_ctx, State);
		EnterRule(_localctx, 126, RULE_type_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1591; Match(BODY);
			State = 1592; type_name();
			State = 1593; is_or_as();
			State = 1595;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 1594; type_body_elements();
				}
				}
				State = 1597;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( ((((_la - 221)) & ~0x3f) == 0 && ((1L << (_la - 221)) & ((1L << (MAP - 221)) | (1L << (MEMBER - 221)) | (1L << (ORDER - 221)))) != 0) || _la==STATIC );
			State = 1599; Match(END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_body_elementsContext : ParserRuleContext {
		public Map_order_func_declarationContext map_order_func_declaration() {
			return GetRuleContext<Map_order_func_declarationContext>(0);
		}
		public Subprog_decl_in_typeContext subprog_decl_in_type() {
			return GetRuleContext<Subprog_decl_in_typeContext>(0);
		}
		public Type_body_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_body_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterType_body_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitType_body_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_body_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_body_elementsContext type_body_elements() {
		Type_body_elementsContext _localctx = new Type_body_elementsContext(_ctx, State);
		EnterRule(_localctx, 128, RULE_type_body_elements);
		try {
			State = 1603;
			switch (_input.La(1)) {
			case MAP:
			case ORDER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1601; map_order_func_declaration();
				}
				break;
			case MEMBER:
			case STATIC:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1602; subprog_decl_in_type();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Map_order_func_declarationContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(PlSqlParser.MEMBER, 0); }
		public Func_decl_in_typeContext func_decl_in_type() {
			return GetRuleContext<Func_decl_in_typeContext>(0);
		}
		public ITerminalNode MAP() { return GetToken(PlSqlParser.MAP, 0); }
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public Map_order_func_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_map_order_func_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMap_order_func_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMap_order_func_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMap_order_func_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Map_order_func_declarationContext map_order_func_declaration() {
		Map_order_func_declarationContext _localctx = new Map_order_func_declarationContext(_ctx, State);
		EnterRule(_localctx, 130, RULE_map_order_func_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1605;
			_la = _input.La(1);
			if ( !(_la==MAP || _la==ORDER) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 1606; Match(MEMBER);
			State = 1607; func_decl_in_type();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subprog_decl_in_typeContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(PlSqlParser.MEMBER, 0); }
		public ITerminalNode STATIC() { return GetToken(PlSqlParser.STATIC, 0); }
		public Proc_decl_in_typeContext proc_decl_in_type() {
			return GetRuleContext<Proc_decl_in_typeContext>(0);
		}
		public Func_decl_in_typeContext func_decl_in_type() {
			return GetRuleContext<Func_decl_in_typeContext>(0);
		}
		public Constructor_declarationContext constructor_declaration() {
			return GetRuleContext<Constructor_declarationContext>(0);
		}
		public Subprog_decl_in_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subprog_decl_in_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSubprog_decl_in_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSubprog_decl_in_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubprog_decl_in_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subprog_decl_in_typeContext subprog_decl_in_type() {
		Subprog_decl_in_typeContext _localctx = new Subprog_decl_in_typeContext(_ctx, State);
		EnterRule(_localctx, 132, RULE_subprog_decl_in_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1609;
			_la = _input.La(1);
			if ( !(_la==MEMBER || _la==STATIC) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 1613;
			switch (_input.La(1)) {
			case PROCEDURE:
				{
				State = 1610; proc_decl_in_type();
				}
				break;
			case FUNCTION:
				{
				State = 1611; func_decl_in_type();
				}
				break;
			case CONSTRUCTOR:
			case FINAL:
			case INSTANTIABLE:
				{
				State = 1612; constructor_declaration();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Proc_decl_in_typeContext : ParserRuleContext {
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public Is_or_asContext is_or_as() {
			return GetRuleContext<Is_or_asContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Proc_decl_in_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proc_decl_in_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterProc_decl_in_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitProc_decl_in_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProc_decl_in_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Proc_decl_in_typeContext proc_decl_in_type() {
		Proc_decl_in_typeContext _localctx = new Proc_decl_in_typeContext(_ctx, State);
		EnterRule(_localctx, 134, RULE_proc_decl_in_type);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1615; Match(PROCEDURE);
			State = 1616; procedure_name();
			State = 1617; Match(LEFT_PAREN);
			State = 1618; type_elements_parameter();
			State = 1623;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1619; Match(COMMA);
				State = 1620; type_elements_parameter();
				}
				}
				State = 1625;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1626; Match(RIGHT_PAREN);
			State = 1627; is_or_as();
			State = 1638;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,121,_ctx) ) {
			case 1:
				{
				State = 1628; call_spec();
				}
				break;

			case 2:
				{
				State = 1632;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,120,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 1629; declare_spec();
						}
						} 
					}
					State = 1634;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,120,_ctx);
				}
				State = 1635; body();
				State = 1636; Match(SEMICOLON);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Func_decl_in_typeContext : ParserRuleContext {
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Is_or_asContext is_or_as() {
			return GetRuleContext<Is_or_asContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Func_decl_in_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_func_decl_in_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFunc_decl_in_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFunc_decl_in_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunc_decl_in_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Func_decl_in_typeContext func_decl_in_type() {
		Func_decl_in_typeContext _localctx = new Func_decl_in_typeContext(_ctx, State);
		EnterRule(_localctx, 136, RULE_func_decl_in_type);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1640; Match(FUNCTION);
			State = 1641; function_name();
			State = 1653;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1642; Match(LEFT_PAREN);
				State = 1643; type_elements_parameter();
				State = 1648;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1644; Match(COMMA);
					State = 1645; type_elements_parameter();
					}
					}
					State = 1650;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1651; Match(RIGHT_PAREN);
				}
			}

			State = 1655; Match(RETURN);
			State = 1656; type_spec();
			State = 1657; is_or_as();
			State = 1668;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,125,_ctx) ) {
			case 1:
				{
				State = 1658; call_spec();
				}
				break;

			case 2:
				{
				State = 1662;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,124,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 1659; declare_spec();
						}
						} 
					}
					State = 1664;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,124,_ctx);
				}
				State = 1665; body();
				State = 1666; Match(SEMICOLON);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Constructor_declarationContext : ParserRuleContext {
		public ITerminalNode CONSTRUCTOR() { return GetToken(PlSqlParser.CONSTRUCTOR, 0); }
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Type_specContext[] type_spec() {
			return GetRuleContexts<Type_specContext>();
		}
		public Type_specContext type_spec(int i) {
			return GetRuleContext<Type_specContext>(i);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public ITerminalNode[] SELF() { return GetTokens(PlSqlParser.SELF); }
		public ITerminalNode SELF(int i) {
			return GetToken(PlSqlParser.SELF, i);
		}
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode RESULT() { return GetToken(PlSqlParser.RESULT, 0); }
		public Is_or_asContext is_or_as() {
			return GetRuleContext<Is_or_asContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public ITerminalNode FINAL() { return GetToken(PlSqlParser.FINAL, 0); }
		public ITerminalNode INSTANTIABLE() { return GetToken(PlSqlParser.INSTANTIABLE, 0); }
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode OUT() { return GetToken(PlSqlParser.OUT, 0); }
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Constructor_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constructor_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterConstructor_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitConstructor_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstructor_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Constructor_declarationContext constructor_declaration() {
		Constructor_declarationContext _localctx = new Constructor_declarationContext(_ctx, State);
		EnterRule(_localctx, 138, RULE_constructor_declaration);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1671;
			_la = _input.La(1);
			if (_la==FINAL) {
				{
				State = 1670; Match(FINAL);
				}
			}

			State = 1674;
			_la = _input.La(1);
			if (_la==INSTANTIABLE) {
				{
				State = 1673; Match(INSTANTIABLE);
				}
			}

			State = 1676; Match(CONSTRUCTOR);
			State = 1677; Match(FUNCTION);
			State = 1678; type_spec();
			State = 1696;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1679; Match(LEFT_PAREN);
				{
				State = 1680; Match(SELF);
				State = 1681; Match(IN);
				State = 1682; Match(OUT);
				State = 1683; type_spec();
				State = 1684; Match(COMMA);
				}
				State = 1686; type_elements_parameter();
				State = 1691;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1687; Match(COMMA);
					State = 1688; type_elements_parameter();
					}
					}
					State = 1693;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1694; Match(RIGHT_PAREN);
				}
			}

			State = 1698; Match(RETURN);
			State = 1699; Match(SELF);
			State = 1700; Match(AS);
			State = 1701; Match(RESULT);
			State = 1702; is_or_as();
			State = 1713;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,131,_ctx) ) {
			case 1:
				{
				State = 1703; call_spec();
				}
				break;

			case 2:
				{
				State = 1707;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,130,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 1704; declare_spec();
						}
						} 
					}
					State = 1709;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,130,_ctx);
				}
				State = 1710; body();
				State = 1711; Match(SEMICOLON);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Modifier_clauseContext : ParserRuleContext {
		public ITerminalNode INSTANTIABLE() { return GetToken(PlSqlParser.INSTANTIABLE, 0); }
		public ITerminalNode FINAL() { return GetToken(PlSqlParser.FINAL, 0); }
		public ITerminalNode OVERRIDING() { return GetToken(PlSqlParser.OVERRIDING, 0); }
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public Modifier_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_modifier_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterModifier_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitModifier_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModifier_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Modifier_clauseContext modifier_clause() {
		Modifier_clauseContext _localctx = new Modifier_clauseContext(_ctx, State);
		EnterRule(_localctx, 140, RULE_modifier_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1716;
			_la = _input.La(1);
			if (_la==NOT) {
				{
				State = 1715; Match(NOT);
				}
			}

			State = 1718;
			_la = _input.La(1);
			if ( !(_la==FINAL || _la==INSTANTIABLE || _la==OVERRIDING) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Object_member_specContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Sqlj_object_type_attrContext sqlj_object_type_attr() {
			return GetRuleContext<Sqlj_object_type_attrContext>(0);
		}
		public Element_specContext element_spec() {
			return GetRuleContext<Element_specContext>(0);
		}
		public Object_member_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_object_member_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterObject_member_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitObject_member_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObject_member_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Object_member_specContext object_member_spec() {
		Object_member_specContext _localctx = new Object_member_specContext(_ctx, State);
		EnterRule(_localctx, 142, RULE_object_member_spec);
		int _la;
		try {
			State = 1726;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,134,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1720; id();
				State = 1721; type_spec();
				State = 1723;
				_la = _input.La(1);
				if (_la==EXTERNAL) {
					{
					State = 1722; sqlj_object_type_attr();
					}
				}

				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1725; element_spec();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sqlj_object_type_attrContext : ParserRuleContext {
		public ITerminalNode EXTERNAL() { return GetToken(PlSqlParser.EXTERNAL, 0); }
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Sqlj_object_type_attrContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sqlj_object_type_attr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSqlj_object_type_attr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSqlj_object_type_attr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSqlj_object_type_attr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sqlj_object_type_attrContext sqlj_object_type_attr() {
		Sqlj_object_type_attrContext _localctx = new Sqlj_object_type_attrContext(_ctx, State);
		EnterRule(_localctx, 144, RULE_sqlj_object_type_attr);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1728; Match(EXTERNAL);
			State = 1729; Match(NAME);
			State = 1730; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Element_specContext : ParserRuleContext {
		public Modifier_clauseContext modifier_clause() {
			return GetRuleContext<Modifier_clauseContext>(0);
		}
		public Element_spec_optionsContext[] element_spec_options() {
			return GetRuleContexts<Element_spec_optionsContext>();
		}
		public Element_spec_optionsContext element_spec_options(int i) {
			return GetRuleContext<Element_spec_optionsContext>(i);
		}
		public Pragma_clauseContext pragma_clause() {
			return GetRuleContext<Pragma_clauseContext>(0);
		}
		public Element_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterElement_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitElement_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElement_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Element_specContext element_spec() {
		Element_specContext _localctx = new Element_specContext(_ctx, State);
		EnterRule(_localctx, 146, RULE_element_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1733;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,135,_ctx) ) {
			case 1:
				{
				State = 1732; modifier_clause();
				}
				break;
			}
			State = 1736;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 1735; element_spec_options();
				}
				}
				State = 1738;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==CONSTRUCTOR || _la==FINAL || _la==INSTANTIABLE || ((((_la - 221)) & ~0x3f) == 0 && ((1L << (_la - 221)) & ((1L << (MAP - 221)) | (1L << (MEMBER - 221)) | (1L << (ORDER - 221)))) != 0) || _la==STATIC );
			State = 1742;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,137,_ctx) ) {
			case 1:
				{
				State = 1740; Match(COMMA);
				State = 1741; pragma_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Element_spec_optionsContext : ParserRuleContext {
		public Subprogram_specContext subprogram_spec() {
			return GetRuleContext<Subprogram_specContext>(0);
		}
		public Constructor_specContext constructor_spec() {
			return GetRuleContext<Constructor_specContext>(0);
		}
		public Map_order_function_specContext map_order_function_spec() {
			return GetRuleContext<Map_order_function_specContext>(0);
		}
		public Element_spec_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element_spec_options; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterElement_spec_options(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitElement_spec_options(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElement_spec_options(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Element_spec_optionsContext element_spec_options() {
		Element_spec_optionsContext _localctx = new Element_spec_optionsContext(_ctx, State);
		EnterRule(_localctx, 148, RULE_element_spec_options);
		try {
			State = 1747;
			switch (_input.La(1)) {
			case MEMBER:
			case STATIC:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1744; subprogram_spec();
				}
				break;
			case CONSTRUCTOR:
			case FINAL:
			case INSTANTIABLE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1745; constructor_spec();
				}
				break;
			case MAP:
			case ORDER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1746; map_order_function_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subprogram_specContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(PlSqlParser.MEMBER, 0); }
		public ITerminalNode STATIC() { return GetToken(PlSqlParser.STATIC, 0); }
		public Type_procedure_specContext type_procedure_spec() {
			return GetRuleContext<Type_procedure_specContext>(0);
		}
		public Type_function_specContext type_function_spec() {
			return GetRuleContext<Type_function_specContext>(0);
		}
		public Subprogram_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subprogram_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSubprogram_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSubprogram_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubprogram_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subprogram_specContext subprogram_spec() {
		Subprogram_specContext _localctx = new Subprogram_specContext(_ctx, State);
		EnterRule(_localctx, 150, RULE_subprogram_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1749;
			_la = _input.La(1);
			if ( !(_la==MEMBER || _la==STATIC) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 1752;
			switch (_input.La(1)) {
			case PROCEDURE:
				{
				State = 1750; type_procedure_spec();
				}
				break;
			case FUNCTION:
				{
				State = 1751; type_function_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_procedure_specContext : ParserRuleContext {
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public Procedure_nameContext procedure_name() {
			return GetRuleContext<Procedure_nameContext>(0);
		}
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public Is_or_asContext is_or_as() {
			return GetRuleContext<Is_or_asContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public Type_procedure_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_procedure_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterType_procedure_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitType_procedure_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_procedure_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_procedure_specContext type_procedure_spec() {
		Type_procedure_specContext _localctx = new Type_procedure_specContext(_ctx, State);
		EnterRule(_localctx, 152, RULE_type_procedure_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1754; Match(PROCEDURE);
			State = 1755; procedure_name();
			State = 1756; Match(LEFT_PAREN);
			State = 1757; type_elements_parameter();
			State = 1762;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1758; Match(COMMA);
				State = 1759; type_elements_parameter();
				}
				}
				State = 1764;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1765; Match(RIGHT_PAREN);
			State = 1769;
			_la = _input.La(1);
			if (_la==AS || _la==IS) {
				{
				State = 1766; is_or_as();
				State = 1767; call_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_function_specContext : ParserRuleContext {
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Function_nameContext function_name() {
			return GetRuleContext<Function_nameContext>(0);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode SELF() { return GetToken(PlSqlParser.SELF, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode RESULT() { return GetToken(PlSqlParser.RESULT, 0); }
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public Is_or_asContext is_or_as() {
			return GetRuleContext<Is_or_asContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode EXTERNAL() { return GetToken(PlSqlParser.EXTERNAL, 0); }
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode VARIABLE() { return GetToken(PlSqlParser.VARIABLE, 0); }
		public Type_function_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_function_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterType_function_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitType_function_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_function_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_function_specContext type_function_spec() {
		Type_function_specContext _localctx = new Type_function_specContext(_ctx, State);
		EnterRule(_localctx, 154, RULE_type_function_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1771; Match(FUNCTION);
			State = 1772; function_name();
			State = 1784;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1773; Match(LEFT_PAREN);
				State = 1774; type_elements_parameter();
				State = 1779;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1775; Match(COMMA);
					State = 1776; type_elements_parameter();
					}
					}
					State = 1781;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1782; Match(RIGHT_PAREN);
				}
			}

			State = 1786; Match(RETURN);
			State = 1791;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,144,_ctx) ) {
			case 1:
				{
				State = 1787; type_spec();
				}
				break;

			case 2:
				{
				State = 1788; Match(SELF);
				State = 1789; Match(AS);
				State = 1790; Match(RESULT);
				}
				break;
			}
			State = 1802;
			switch (_input.La(1)) {
			case AS:
			case IS:
				{
				State = 1793; is_or_as();
				State = 1794; call_spec();
				}
				break;
			case EXTERNAL:
				{
				State = 1796; Match(EXTERNAL);
				State = 1798;
				_la = _input.La(1);
				if (_la==VARIABLE) {
					{
					State = 1797; Match(VARIABLE);
					}
				}

				State = 1800; Match(NAME);
				State = 1801; expression();
				}
				break;
			case CASCADE:
			case CONSTRUCTOR:
			case FINAL:
			case INSTANTIABLE:
			case INVALIDATE:
			case MAP:
			case MEMBER:
			case ORDER:
			case STATIC:
			case RIGHT_PAREN:
			case COMMA:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Constructor_specContext : ParserRuleContext {
		public ITerminalNode CONSTRUCTOR() { return GetToken(PlSqlParser.CONSTRUCTOR, 0); }
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public Type_specContext[] type_spec() {
			return GetRuleContexts<Type_specContext>();
		}
		public Type_specContext type_spec(int i) {
			return GetRuleContext<Type_specContext>(i);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public ITerminalNode[] SELF() { return GetTokens(PlSqlParser.SELF); }
		public ITerminalNode SELF(int i) {
			return GetToken(PlSqlParser.SELF, i);
		}
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode RESULT() { return GetToken(PlSqlParser.RESULT, 0); }
		public ITerminalNode FINAL() { return GetToken(PlSqlParser.FINAL, 0); }
		public ITerminalNode INSTANTIABLE() { return GetToken(PlSqlParser.INSTANTIABLE, 0); }
		public Type_elements_parameterContext[] type_elements_parameter() {
			return GetRuleContexts<Type_elements_parameterContext>();
		}
		public Type_elements_parameterContext type_elements_parameter(int i) {
			return GetRuleContext<Type_elements_parameterContext>(i);
		}
		public Is_or_asContext is_or_as() {
			return GetRuleContext<Is_or_asContext>(0);
		}
		public Call_specContext call_spec() {
			return GetRuleContext<Call_specContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode OUT() { return GetToken(PlSqlParser.OUT, 0); }
		public Constructor_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constructor_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterConstructor_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitConstructor_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstructor_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Constructor_specContext constructor_spec() {
		Constructor_specContext _localctx = new Constructor_specContext(_ctx, State);
		EnterRule(_localctx, 156, RULE_constructor_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1805;
			_la = _input.La(1);
			if (_la==FINAL) {
				{
				State = 1804; Match(FINAL);
				}
			}

			State = 1808;
			_la = _input.La(1);
			if (_la==INSTANTIABLE) {
				{
				State = 1807; Match(INSTANTIABLE);
				}
			}

			State = 1810; Match(CONSTRUCTOR);
			State = 1811; Match(FUNCTION);
			State = 1812; type_spec();
			State = 1830;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 1813; Match(LEFT_PAREN);
				{
				State = 1814; Match(SELF);
				State = 1815; Match(IN);
				State = 1816; Match(OUT);
				State = 1817; type_spec();
				State = 1818; Match(COMMA);
				}
				State = 1820; type_elements_parameter();
				State = 1825;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1821; Match(COMMA);
					State = 1822; type_elements_parameter();
					}
					}
					State = 1827;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 1828; Match(RIGHT_PAREN);
				}
			}

			State = 1832; Match(RETURN);
			State = 1833; Match(SELF);
			State = 1834; Match(AS);
			State = 1835; Match(RESULT);
			State = 1839;
			_la = _input.La(1);
			if (_la==AS || _la==IS) {
				{
				State = 1836; is_or_as();
				State = 1837; call_spec();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Map_order_function_specContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(PlSqlParser.MEMBER, 0); }
		public Type_function_specContext type_function_spec() {
			return GetRuleContext<Type_function_specContext>(0);
		}
		public ITerminalNode MAP() { return GetToken(PlSqlParser.MAP, 0); }
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public Map_order_function_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_map_order_function_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMap_order_function_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMap_order_function_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMap_order_function_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Map_order_function_specContext map_order_function_spec() {
		Map_order_function_specContext _localctx = new Map_order_function_specContext(_ctx, State);
		EnterRule(_localctx, 158, RULE_map_order_function_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1841;
			_la = _input.La(1);
			if ( !(_la==MAP || _la==ORDER) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 1842; Match(MEMBER);
			State = 1843; type_function_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pragma_clauseContext : ParserRuleContext {
		public ITerminalNode PRAGMA() { return GetToken(PlSqlParser.PRAGMA, 0); }
		public ITerminalNode RESTRICT_REFERENCES() { return GetToken(PlSqlParser.RESTRICT_REFERENCES, 0); }
		public Pragma_elementsContext[] pragma_elements() {
			return GetRuleContexts<Pragma_elementsContext>();
		}
		public Pragma_elementsContext pragma_elements(int i) {
			return GetRuleContext<Pragma_elementsContext>(i);
		}
		public Pragma_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pragma_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPragma_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPragma_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPragma_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pragma_clauseContext pragma_clause() {
		Pragma_clauseContext _localctx = new Pragma_clauseContext(_ctx, State);
		EnterRule(_localctx, 160, RULE_pragma_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1845; Match(PRAGMA);
			State = 1846; Match(RESTRICT_REFERENCES);
			State = 1847; Match(LEFT_PAREN);
			State = 1848; pragma_elements();
			State = 1853;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1849; Match(COMMA);
				State = 1850; pragma_elements();
				}
				}
				State = 1855;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1856; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pragma_elementsContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public Pragma_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pragma_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPragma_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPragma_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPragma_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pragma_elementsContext pragma_elements() {
		Pragma_elementsContext _localctx = new Pragma_elementsContext(_ctx, State);
		EnterRule(_localctx, 162, RULE_pragma_elements);
		try {
			State = 1860;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,153,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1858; id();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1859; Match(DEFAULT);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_elements_parameterContext : ParserRuleContext {
		public Parameter_nameContext parameter_name() {
			return GetRuleContext<Parameter_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Type_elements_parameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_elements_parameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterType_elements_parameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitType_elements_parameter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_elements_parameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_elements_parameterContext type_elements_parameter() {
		Type_elements_parameterContext _localctx = new Type_elements_parameterContext(_ctx, State);
		EnterRule(_localctx, 164, RULE_type_elements_parameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1862; parameter_name();
			State = 1863; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Drop_sequenceContext : ParserRuleContext {
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(PlSqlParser.SEQUENCE, 0); }
		public Sequence_nameContext sequence_name() {
			return GetRuleContext<Sequence_nameContext>(0);
		}
		public Drop_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_drop_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDrop_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDrop_sequence(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop_sequence(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Drop_sequenceContext drop_sequence() {
		Drop_sequenceContext _localctx = new Drop_sequenceContext(_ctx, State);
		EnterRule(_localctx, 166, RULE_drop_sequence);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1865; Match(DROP);
			State = 1866; Match(SEQUENCE);
			State = 1867; sequence_name();
			State = 1868; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alter_sequenceContext : ParserRuleContext {
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(PlSqlParser.SEQUENCE, 0); }
		public Sequence_nameContext sequence_name() {
			return GetRuleContext<Sequence_nameContext>(0);
		}
		public Sequence_specContext[] sequence_spec() {
			return GetRuleContexts<Sequence_specContext>();
		}
		public Sequence_specContext sequence_spec(int i) {
			return GetRuleContext<Sequence_specContext>(i);
		}
		public Alter_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alter_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAlter_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAlter_sequence(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlter_sequence(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alter_sequenceContext alter_sequence() {
		Alter_sequenceContext _localctx = new Alter_sequenceContext(_ctx, State);
		EnterRule(_localctx, 168, RULE_alter_sequence);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1870; Match(ALTER);
			State = 1871; Match(SEQUENCE);
			State = 1872; sequence_name();
			State = 1874;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 1873; sequence_spec();
				}
				}
				State = 1876;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==CACHE || _la==CYCLE || ((((_la - 175)) & ~0x3f) == 0 && ((1L << (_la - 175)) & ((1L << (INCREMENT - 175)) | (1L << (MAXVALUE - 175)) | (1L << (MINVALUE - 175)))) != 0) || ((((_la - 250)) & ~0x3f) == 0 && ((1L << (_la - 250)) & ((1L << (NOCACHE - 250)) | (1L << (NOCYCLE - 250)) | (1L << (NOMAXVALUE - 250)) | (1L << (NOMINVALUE - 250)) | (1L << (NOORDER - 250)) | (1L << (ORDER - 250)))) != 0) );
			State = 1878; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Create_sequenceContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(PlSqlParser.SEQUENCE, 0); }
		public Sequence_nameContext sequence_name() {
			return GetRuleContext<Sequence_nameContext>(0);
		}
		public Sequence_start_clauseContext[] sequence_start_clause() {
			return GetRuleContexts<Sequence_start_clauseContext>();
		}
		public Sequence_start_clauseContext sequence_start_clause(int i) {
			return GetRuleContext<Sequence_start_clauseContext>(i);
		}
		public Sequence_specContext[] sequence_spec() {
			return GetRuleContexts<Sequence_specContext>();
		}
		public Sequence_specContext sequence_spec(int i) {
			return GetRuleContext<Sequence_specContext>(i);
		}
		public Create_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_create_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCreate_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCreate_sequence(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreate_sequence(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Create_sequenceContext create_sequence() {
		Create_sequenceContext _localctx = new Create_sequenceContext(_ctx, State);
		EnterRule(_localctx, 170, RULE_create_sequence);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1880; Match(CREATE);
			State = 1881; Match(SEQUENCE);
			State = 1882; sequence_name();
			State = 1887;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==CACHE || _la==CYCLE || ((((_la - 175)) & ~0x3f) == 0 && ((1L << (_la - 175)) & ((1L << (INCREMENT - 175)) | (1L << (MAXVALUE - 175)) | (1L << (MINVALUE - 175)))) != 0) || ((((_la - 250)) & ~0x3f) == 0 && ((1L << (_la - 250)) & ((1L << (NOCACHE - 250)) | (1L << (NOCYCLE - 250)) | (1L << (NOMAXVALUE - 250)) | (1L << (NOMINVALUE - 250)) | (1L << (NOORDER - 250)) | (1L << (ORDER - 250)))) != 0) || _la==START) {
				{
				State = 1885;
				switch (_input.La(1)) {
				case START:
					{
					State = 1883; sequence_start_clause();
					}
					break;
				case CACHE:
				case CYCLE:
				case INCREMENT:
				case MAXVALUE:
				case MINVALUE:
				case NOCACHE:
				case NOCYCLE:
				case NOMAXVALUE:
				case NOMINVALUE:
				case NOORDER:
				case ORDER:
					{
					State = 1884; sequence_spec();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 1889;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1890; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sequence_specContext : ParserRuleContext {
		public ITerminalNode INCREMENT() { return GetToken(PlSqlParser.INCREMENT, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(PlSqlParser.UNSIGNED_INTEGER, 0); }
		public ITerminalNode MAXVALUE() { return GetToken(PlSqlParser.MAXVALUE, 0); }
		public ITerminalNode NOMAXVALUE() { return GetToken(PlSqlParser.NOMAXVALUE, 0); }
		public ITerminalNode MINVALUE() { return GetToken(PlSqlParser.MINVALUE, 0); }
		public ITerminalNode NOMINVALUE() { return GetToken(PlSqlParser.NOMINVALUE, 0); }
		public ITerminalNode CYCLE() { return GetToken(PlSqlParser.CYCLE, 0); }
		public ITerminalNode NOCYCLE() { return GetToken(PlSqlParser.NOCYCLE, 0); }
		public ITerminalNode CACHE() { return GetToken(PlSqlParser.CACHE, 0); }
		public ITerminalNode NOCACHE() { return GetToken(PlSqlParser.NOCACHE, 0); }
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public ITerminalNode NOORDER() { return GetToken(PlSqlParser.NOORDER, 0); }
		public Sequence_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequence_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSequence_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSequence_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSequence_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sequence_specContext sequence_spec() {
		Sequence_specContext _localctx = new Sequence_specContext(_ctx, State);
		EnterRule(_localctx, 172, RULE_sequence_spec);
		try {
			State = 1908;
			switch (_input.La(1)) {
			case INCREMENT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1892; Match(INCREMENT);
				State = 1893; Match(BY);
				State = 1894; Match(UNSIGNED_INTEGER);
				}
				break;
			case MAXVALUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1895; Match(MAXVALUE);
				State = 1896; Match(UNSIGNED_INTEGER);
				}
				break;
			case NOMAXVALUE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1897; Match(NOMAXVALUE);
				}
				break;
			case MINVALUE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1898; Match(MINVALUE);
				State = 1899; Match(UNSIGNED_INTEGER);
				}
				break;
			case NOMINVALUE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1900; Match(NOMINVALUE);
				}
				break;
			case CYCLE:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1901; Match(CYCLE);
				}
				break;
			case NOCYCLE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1902; Match(NOCYCLE);
				}
				break;
			case CACHE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1903; Match(CACHE);
				State = 1904; Match(UNSIGNED_INTEGER);
				}
				break;
			case NOCACHE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1905; Match(NOCACHE);
				}
				break;
			case ORDER:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1906; Match(ORDER);
				}
				break;
			case NOORDER:
				EnterOuterAlt(_localctx, 11);
				{
				State = 1907; Match(NOORDER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sequence_start_clauseContext : ParserRuleContext {
		public ITerminalNode START() { return GetToken(PlSqlParser.START, 0); }
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(PlSqlParser.UNSIGNED_INTEGER, 0); }
		public Sequence_start_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequence_start_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSequence_start_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSequence_start_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSequence_start_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sequence_start_clauseContext sequence_start_clause() {
		Sequence_start_clauseContext _localctx = new Sequence_start_clauseContext(_ctx, State);
		EnterRule(_localctx, 174, RULE_sequence_start_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1910; Match(START);
			State = 1911; Match(WITH);
			State = 1912; Match(UNSIGNED_INTEGER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Invoker_rights_clauseContext : ParserRuleContext {
		public ITerminalNode AUTHID() { return GetToken(PlSqlParser.AUTHID, 0); }
		public ITerminalNode CURRENT_USER() { return GetToken(PlSqlParser.CURRENT_USER, 0); }
		public ITerminalNode DEFINER() { return GetToken(PlSqlParser.DEFINER, 0); }
		public Invoker_rights_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_invoker_rights_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterInvoker_rights_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitInvoker_rights_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInvoker_rights_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Invoker_rights_clauseContext invoker_rights_clause() {
		Invoker_rights_clauseContext _localctx = new Invoker_rights_clauseContext(_ctx, State);
		EnterRule(_localctx, 176, RULE_invoker_rights_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1914; Match(AUTHID);
			State = 1915;
			_la = _input.La(1);
			if ( !(_la==CURRENT_USER || _la==DEFINER) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compiler_parameters_clauseContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Compiler_parameters_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compiler_parameters_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCompiler_parameters_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCompiler_parameters_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompiler_parameters_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compiler_parameters_clauseContext compiler_parameters_clause() {
		Compiler_parameters_clauseContext _localctx = new Compiler_parameters_clauseContext(_ctx, State);
		EnterRule(_localctx, 178, RULE_compiler_parameters_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1917; id();
			State = 1918; Match(EQUALS_OP);
			State = 1919; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Call_specContext : ParserRuleContext {
		public ITerminalNode LANGUAGE() { return GetToken(PlSqlParser.LANGUAGE, 0); }
		public Java_specContext java_spec() {
			return GetRuleContext<Java_specContext>(0);
		}
		public C_specContext c_spec() {
			return GetRuleContext<C_specContext>(0);
		}
		public Call_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_call_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCall_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCall_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCall_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Call_specContext call_spec() {
		Call_specContext _localctx = new Call_specContext(_ctx, State);
		EnterRule(_localctx, 180, RULE_call_spec);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1921; Match(LANGUAGE);
			State = 1924;
			switch (_input.La(1)) {
			case JAVA:
				{
				State = 1922; java_spec();
				}
				break;
			case C_LETTER:
				{
				State = 1923; c_spec();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Java_specContext : ParserRuleContext {
		public ITerminalNode JAVA() { return GetToken(PlSqlParser.JAVA, 0); }
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public Java_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_java_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterJava_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitJava_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJava_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Java_specContext java_spec() {
		Java_specContext _localctx = new Java_specContext(_ctx, State);
		EnterRule(_localctx, 182, RULE_java_spec);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1926; Match(JAVA);
			State = 1927; Match(NAME);
			State = 1928; Match(CHAR_STRING);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class C_specContext : ParserRuleContext {
		public ITerminalNode C_LETTER() { return GetToken(PlSqlParser.C_LETTER, 0); }
		public ITerminalNode LIBRARY() { return GetToken(PlSqlParser.LIBRARY, 0); }
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public C_agent_in_clauseContext c_agent_in_clause() {
			return GetRuleContext<C_agent_in_clauseContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode CONTEXT() { return GetToken(PlSqlParser.CONTEXT, 0); }
		public C_parameters_clauseContext c_parameters_clause() {
			return GetRuleContext<C_parameters_clauseContext>(0);
		}
		public C_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_c_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterC_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitC_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitC_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public C_specContext c_spec() {
		C_specContext _localctx = new C_specContext(_ctx, State);
		EnterRule(_localctx, 184, RULE_c_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1930; Match(C_LETTER);
			State = 1933;
			_la = _input.La(1);
			if (_la==NAME) {
				{
				State = 1931; Match(NAME);
				State = 1932; Match(CHAR_STRING);
				}
			}

			State = 1935; Match(LIBRARY);
			State = 1936; id();
			State = 1938;
			_la = _input.La(1);
			if (_la==AGENT) {
				{
				State = 1937; c_agent_in_clause();
				}
			}

			State = 1942;
			_la = _input.La(1);
			if (_la==WITH) {
				{
				State = 1940; Match(WITH);
				State = 1941; Match(CONTEXT);
				}
			}

			State = 1945;
			_la = _input.La(1);
			if (_la==PARAMETERS) {
				{
				State = 1944; c_parameters_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class C_agent_in_clauseContext : ParserRuleContext {
		public ITerminalNode AGENT() { return GetToken(PlSqlParser.AGENT, 0); }
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public C_agent_in_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_c_agent_in_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterC_agent_in_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitC_agent_in_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitC_agent_in_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public C_agent_in_clauseContext c_agent_in_clause() {
		C_agent_in_clauseContext _localctx = new C_agent_in_clauseContext(_ctx, State);
		EnterRule(_localctx, 186, RULE_c_agent_in_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1947; Match(AGENT);
			State = 1948; Match(IN);
			State = 1949; Match(LEFT_PAREN);
			State = 1950; expression();
			State = 1955;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 1951; Match(COMMA);
				State = 1952; expression();
				}
				}
				State = 1957;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 1958; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class C_parameters_clauseContext : ParserRuleContext {
		public ITerminalNode PARAMETERS() { return GetToken(PlSqlParser.PARAMETERS, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public C_parameters_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_c_parameters_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterC_parameters_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitC_parameters_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitC_parameters_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public C_parameters_clauseContext c_parameters_clause() {
		C_parameters_clauseContext _localctx = new C_parameters_clauseContext(_ctx, State);
		EnterRule(_localctx, 188, RULE_c_parameters_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1960; Match(PARAMETERS);
			State = 1961; Match(LEFT_PAREN);
			State = 1973;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MOD:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TO_NUMBER:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 1962; expression();
				State = 1967;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 1963; Match(COMMA);
					State = 1964; expression();
					}
					}
					State = 1969;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			case PERIOD:
				{
				State = 1970; Match(PERIOD);
				State = 1971; Match(PERIOD);
				State = 1972; Match(PERIOD);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1975; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterContext : ParserRuleContext {
		public Parameter_nameContext parameter_name() {
			return GetRuleContext<Parameter_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public ITerminalNode[] IN() { return GetTokens(PlSqlParser.IN); }
		public ITerminalNode IN(int i) {
			return GetToken(PlSqlParser.IN, i);
		}
		public ITerminalNode[] OUT() { return GetTokens(PlSqlParser.OUT); }
		public ITerminalNode OUT(int i) {
			return GetToken(PlSqlParser.OUT, i);
		}
		public ITerminalNode[] INOUT() { return GetTokens(PlSqlParser.INOUT); }
		public ITerminalNode INOUT(int i) {
			return GetToken(PlSqlParser.INOUT, i);
		}
		public ITerminalNode[] NOCOPY() { return GetTokens(PlSqlParser.NOCOPY); }
		public ITerminalNode NOCOPY(int i) {
			return GetToken(PlSqlParser.NOCOPY, i);
		}
		public ParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitParameter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterContext parameter() {
		ParameterContext _localctx = new ParameterContext(_ctx, State);
		EnterRule(_localctx, 190, RULE_parameter);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1977; parameter_name();
			State = 1981;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,166,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 1978;
					_la = _input.La(1);
					if ( !(_la==IN || _la==INOUT || _la==NOCOPY || _la==OUT) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					}
					} 
				}
				State = 1983;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,166,_ctx);
			}
			State = 1985;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,167,_ctx) ) {
			case 1:
				{
				State = 1984; type_spec();
				}
				break;
			}
			State = 1988;
			_la = _input.La(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 1987; default_value_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Default_value_partContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode ASSIGN_OP() { return GetToken(PlSqlParser.ASSIGN_OP, 0); }
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public Default_value_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_default_value_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDefault_value_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDefault_value_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefault_value_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Default_value_partContext default_value_part() {
		Default_value_partContext _localctx = new Default_value_partContext(_ctx, State);
		EnterRule(_localctx, 192, RULE_default_value_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1990;
			_la = _input.La(1);
			if ( !(_la==DEFAULT || _la==ASSIGN_OP) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 1991; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Declare_specContext : ParserRuleContext {
		public Variable_declarationContext variable_declaration() {
			return GetRuleContext<Variable_declarationContext>(0);
		}
		public Subtype_declarationContext subtype_declaration() {
			return GetRuleContext<Subtype_declarationContext>(0);
		}
		public Cursor_declarationContext cursor_declaration() {
			return GetRuleContext<Cursor_declarationContext>(0);
		}
		public Exception_declarationContext exception_declaration() {
			return GetRuleContext<Exception_declarationContext>(0);
		}
		public Pragma_declarationContext pragma_declaration() {
			return GetRuleContext<Pragma_declarationContext>(0);
		}
		public Record_declarationContext record_declaration() {
			return GetRuleContext<Record_declarationContext>(0);
		}
		public Table_declarationContext table_declaration() {
			return GetRuleContext<Table_declarationContext>(0);
		}
		public Create_procedure_bodyContext create_procedure_body() {
			return GetRuleContext<Create_procedure_bodyContext>(0);
		}
		public Create_function_bodyContext create_function_body() {
			return GetRuleContext<Create_function_bodyContext>(0);
		}
		public Preprocessor_statementContext preprocessor_statement() {
			return GetRuleContext<Preprocessor_statementContext>(0);
		}
		public Declare_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declare_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDeclare_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDeclare_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclare_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Declare_specContext declare_spec() {
		Declare_specContext _localctx = new Declare_specContext(_ctx, State);
		EnterRule(_localctx, 194, RULE_declare_spec);
		try {
			State = 2003;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,169,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1993; variable_declaration();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1994; subtype_declaration();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1995; cursor_declaration();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1996; exception_declaration();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1997; pragma_declaration();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1998; record_declaration();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1999; table_declaration();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2000; create_procedure_body();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2001; create_function_body();
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2002; preprocessor_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Variable_declarationContext : ParserRuleContext {
		public Variable_nameContext variable_name() {
			return GetRuleContext<Variable_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode CONSTANT() { return GetToken(PlSqlParser.CONSTANT, 0); }
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public Variable_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variable_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterVariable_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitVariable_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Variable_declarationContext variable_declaration() {
		Variable_declarationContext _localctx = new Variable_declarationContext(_ctx, State);
		EnterRule(_localctx, 196, RULE_variable_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2005; variable_name();
			State = 2007;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,170,_ctx) ) {
			case 1:
				{
				State = 2006; Match(CONSTANT);
				}
				break;
			}
			State = 2009; type_spec();
			State = 2012;
			_la = _input.La(1);
			if (_la==NOT) {
				{
				State = 2010; Match(NOT);
				State = 2011; Match(NULL);
				}
			}

			State = 2015;
			_la = _input.La(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 2014; default_value_part();
				}
			}

			State = 2017; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subtype_declarationContext : ParserRuleContext {
		public ITerminalNode SUBTYPE() { return GetToken(PlSqlParser.SUBTYPE, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode RANGE() { return GetToken(PlSqlParser.RANGE, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Subtype_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subtype_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSubtype_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSubtype_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubtype_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subtype_declarationContext subtype_declaration() {
		Subtype_declarationContext _localctx = new Subtype_declarationContext(_ctx, State);
		EnterRule(_localctx, 198, RULE_subtype_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2019; Match(SUBTYPE);
			State = 2020; type_name();
			State = 2021; Match(IS);
			State = 2022; type_spec();
			State = 2028;
			_la = _input.La(1);
			if (_la==RANGE) {
				{
				State = 2023; Match(RANGE);
				State = 2024; expression();
				State = 2025; Match(T__0);
				State = 2026; expression();
				}
			}

			State = 2032;
			_la = _input.La(1);
			if (_la==NOT) {
				{
				State = 2030; Match(NOT);
				State = 2031; Match(NULL);
				}
			}

			State = 2034; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_declarationContext : ParserRuleContext {
		public ITerminalNode CURSOR() { return GetToken(PlSqlParser.CURSOR, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Parameter_specContext[] parameter_spec() {
			return GetRuleContexts<Parameter_specContext>();
		}
		public Parameter_specContext parameter_spec(int i) {
			return GetRuleContext<Parameter_specContext>(i);
		}
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Cursor_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCursor_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCursor_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_declarationContext cursor_declaration() {
		Cursor_declarationContext _localctx = new Cursor_declarationContext(_ctx, State);
		EnterRule(_localctx, 200, RULE_cursor_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2036; Match(CURSOR);
			State = 2037; cursor_name();
			State = 2049;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2038; Match(LEFT_PAREN);
				State = 2039; parameter_spec();
				State = 2044;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2040; Match(COMMA);
					State = 2041; parameter_spec();
					}
					}
					State = 2046;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 2047; Match(RIGHT_PAREN);
				}
			}

			State = 2053;
			_la = _input.La(1);
			if (_la==RETURN) {
				{
				State = 2051; Match(RETURN);
				State = 2052; type_spec();
				}
			}

			State = 2057;
			_la = _input.La(1);
			if (_la==IS) {
				{
				State = 2055; Match(IS);
				State = 2056; select_statement();
				}
			}

			State = 2059; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parameter_specContext : ParserRuleContext {
		public Parameter_nameContext parameter_name() {
			return GetRuleContext<Parameter_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public Parameter_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterParameter_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitParameter_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parameter_specContext parameter_spec() {
		Parameter_specContext _localctx = new Parameter_specContext(_ctx, State);
		EnterRule(_localctx, 202, RULE_parameter_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2061; parameter_name();
			State = 2066;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,180,_ctx) ) {
			case 1:
				{
				State = 2063;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,179,_ctx) ) {
				case 1:
					{
					State = 2062; Match(IN);
					}
					break;
				}
				State = 2065; type_spec();
				}
				break;
			}
			State = 2069;
			_la = _input.La(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 2068; default_value_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_declarationContext : ParserRuleContext {
		public Exception_nameContext exception_name() {
			return GetRuleContext<Exception_nameContext>(0);
		}
		public ITerminalNode EXCEPTION() { return GetToken(PlSqlParser.EXCEPTION, 0); }
		public Exception_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterException_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitException_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitException_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exception_declarationContext exception_declaration() {
		Exception_declarationContext _localctx = new Exception_declarationContext(_ctx, State);
		EnterRule(_localctx, 204, RULE_exception_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2071; exception_name();
			State = 2072; Match(EXCEPTION);
			State = 2073; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pragma_declarationContext : ParserRuleContext {
		public IdContext id1;
		public ITerminalNode PRAGMA() { return GetToken(PlSqlParser.PRAGMA, 0); }
		public ITerminalNode SERIALLY_REUSABLE() { return GetToken(PlSqlParser.SERIALLY_REUSABLE, 0); }
		public ITerminalNode AUTONOMOUS_TRANSACTION() { return GetToken(PlSqlParser.AUTONOMOUS_TRANSACTION, 0); }
		public ITerminalNode EXCEPTION_INIT() { return GetToken(PlSqlParser.EXCEPTION_INIT, 0); }
		public Exception_nameContext exception_name() {
			return GetRuleContext<Exception_nameContext>(0);
		}
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public ITerminalNode INLINE() { return GetToken(PlSqlParser.INLINE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode RESTRICT_REFERENCES() { return GetToken(PlSqlParser.RESTRICT_REFERENCES, 0); }
		public IdContext[] id() {
			return GetRuleContexts<IdContext>();
		}
		public IdContext id(int i) {
			return GetRuleContext<IdContext>(i);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ITerminalNode MINUS_SIGN() { return GetToken(PlSqlParser.MINUS_SIGN, 0); }
		public Pragma_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pragma_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPragma_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPragma_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPragma_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pragma_declarationContext pragma_declaration() {
		Pragma_declarationContext _localctx = new Pragma_declarationContext(_ctx, State);
		EnterRule(_localctx, 206, RULE_pragma_declaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2075; Match(PRAGMA);
			State = 2109;
			switch (_input.La(1)) {
			case SERIALLY_REUSABLE:
				{
				State = 2076; Match(SERIALLY_REUSABLE);
				}
				break;
			case AUTONOMOUS_TRANSACTION:
				{
				State = 2077; Match(AUTONOMOUS_TRANSACTION);
				}
				break;
			case EXCEPTION_INIT:
				{
				State = 2078; Match(EXCEPTION_INIT);
				State = 2079; Match(LEFT_PAREN);
				State = 2080; exception_name();
				State = 2081; Match(COMMA);
				State = 2083;
				_la = _input.La(1);
				if (_la==MINUS_SIGN) {
					{
					State = 2082; Match(MINUS_SIGN);
					}
				}

				State = 2085; numeric();
				State = 2086; Match(RIGHT_PAREN);
				}
				break;
			case INLINE:
				{
				State = 2088; Match(INLINE);
				State = 2089; Match(LEFT_PAREN);
				State = 2090; _localctx.id1 = id();
				State = 2091; Match(COMMA);
				State = 2092; expression();
				State = 2093; Match(RIGHT_PAREN);
				}
				break;
			case RESTRICT_REFERENCES:
				{
				State = 2095; Match(RESTRICT_REFERENCES);
				State = 2096; Match(LEFT_PAREN);
				State = 2099;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,183,_ctx) ) {
				case 1:
					{
					State = 2097; id();
					}
					break;

				case 2:
					{
					State = 2098; Match(DEFAULT);
					}
					break;
				}
				State = 2103;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 2101; Match(COMMA);
					State = 2102; id();
					}
					}
					State = 2105;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( _la==COMMA );
				State = 2107; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2111; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Record_declarationContext : ParserRuleContext {
		public Record_type_decContext record_type_dec() {
			return GetRuleContext<Record_type_decContext>(0);
		}
		public Record_var_decContext record_var_dec() {
			return GetRuleContext<Record_var_decContext>(0);
		}
		public Record_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_record_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRecord_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRecord_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRecord_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Record_declarationContext record_declaration() {
		Record_declarationContext _localctx = new Record_declarationContext(_ctx, State);
		EnterRule(_localctx, 208, RULE_record_declaration);
		try {
			State = 2115;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,186,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2113; record_type_dec();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2114; record_var_dec();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Record_type_decContext : ParserRuleContext {
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode RECORD() { return GetToken(PlSqlParser.RECORD, 0); }
		public Field_specContext[] field_spec() {
			return GetRuleContexts<Field_specContext>();
		}
		public Field_specContext field_spec(int i) {
			return GetRuleContext<Field_specContext>(i);
		}
		public ITerminalNode REF() { return GetToken(PlSqlParser.REF, 0); }
		public ITerminalNode CURSOR() { return GetToken(PlSqlParser.CURSOR, 0); }
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Record_type_decContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_record_type_dec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRecord_type_dec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRecord_type_dec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRecord_type_dec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Record_type_decContext record_type_dec() {
		Record_type_decContext _localctx = new Record_type_decContext(_ctx, State);
		EnterRule(_localctx, 210, RULE_record_type_dec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2117; Match(TYPE);
			State = 2118; type_name();
			State = 2119; Match(IS);
			State = 2138;
			switch (_input.La(1)) {
			case RECORD:
				{
				State = 2120; Match(RECORD);
				State = 2121; Match(LEFT_PAREN);
				State = 2122; field_spec();
				State = 2127;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2123; Match(COMMA);
					State = 2124; field_spec();
					}
					}
					State = 2129;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 2130; Match(RIGHT_PAREN);
				}
				break;
			case REF:
				{
				State = 2132; Match(REF);
				State = 2133; Match(CURSOR);
				State = 2136;
				_la = _input.La(1);
				if (_la==RETURN) {
					{
					State = 2134; Match(RETURN);
					State = 2135; type_spec();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2140; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Field_specContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public Field_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_field_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterField_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitField_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitField_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Field_specContext field_spec() {
		Field_specContext _localctx = new Field_specContext(_ctx, State);
		EnterRule(_localctx, 212, RULE_field_spec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2142; column_name();
			State = 2144;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,190,_ctx) ) {
			case 1:
				{
				State = 2143; type_spec();
				}
				break;
			}
			State = 2148;
			_la = _input.La(1);
			if (_la==NOT) {
				{
				State = 2146; Match(NOT);
				State = 2147; Match(NULL);
				}
			}

			State = 2151;
			_la = _input.La(1);
			if (_la==DEFAULT || _la==ASSIGN_OP) {
				{
				State = 2150; default_value_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Record_var_decContext : ParserRuleContext {
		public Record_nameContext record_name() {
			return GetRuleContext<Record_nameContext>(0);
		}
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode PERCENT_ROWTYPE() { return GetToken(PlSqlParser.PERCENT_ROWTYPE, 0); }
		public ITerminalNode PERCENT_TYPE() { return GetToken(PlSqlParser.PERCENT_TYPE, 0); }
		public ITerminalNode AT_SIGN() { return GetToken(PlSqlParser.AT_SIGN, 0); }
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public Default_value_partContext default_value_part() {
			return GetRuleContext<Default_value_partContext>(0);
		}
		public Record_var_decContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_record_var_dec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRecord_var_dec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRecord_var_dec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRecord_var_dec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Record_var_decContext record_var_dec() {
		Record_var_decContext _localctx = new Record_var_decContext(_ctx, State);
		EnterRule(_localctx, 214, RULE_record_var_dec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2153; record_name();
			State = 2154; type_name();
			State = 2157;
			_la = _input.La(1);
			if (_la==AT_SIGN) {
				{
				State = 2155; Match(AT_SIGN);
				State = 2156; link_name();
				}
			}

			State = 2164;
			switch (_input.La(1)) {
			case PERCENT_ROWTYPE:
				{
				State = 2159; Match(PERCENT_ROWTYPE);
				}
				break;
			case PERCENT_TYPE:
				{
				State = 2160; Match(PERCENT_TYPE);
				State = 2162;
				_la = _input.La(1);
				if (_la==DEFAULT || _la==ASSIGN_OP) {
					{
					State = 2161; default_value_part();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2166; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_declarationContext : ParserRuleContext {
		public Table_type_decContext table_type_dec() {
			return GetRuleContext<Table_type_decContext>(0);
		}
		public Table_var_decContext table_var_dec() {
			return GetRuleContext<Table_var_decContext>(0);
		}
		public Table_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTable_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTable_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_declarationContext table_declaration() {
		Table_declarationContext _localctx = new Table_declarationContext(_ctx, State);
		EnterRule(_localctx, 216, RULE_table_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2170;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,196,_ctx) ) {
			case 1:
				{
				State = 2168; table_type_dec();
				}
				break;

			case 2:
				{
				State = 2169; table_var_dec();
				}
				break;
			}
			State = 2172; Match(SEMICOLON);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_type_decContext : ParserRuleContext {
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Varray_type_defContext varray_type_def() {
			return GetRuleContext<Varray_type_defContext>(0);
		}
		public Table_indexed_by_partContext table_indexed_by_part() {
			return GetRuleContext<Table_indexed_by_partContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Table_type_decContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_type_dec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTable_type_dec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTable_type_dec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_type_dec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_type_decContext table_type_dec() {
		Table_type_decContext _localctx = new Table_type_decContext(_ctx, State);
		EnterRule(_localctx, 218, RULE_table_type_dec);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2174; Match(TYPE);
			State = 2175; type_name();
			State = 2176; Match(IS);
			State = 2188;
			switch (_input.La(1)) {
			case TABLE:
				{
				State = 2177; Match(TABLE);
				State = 2178; Match(OF);
				State = 2179; type_spec();
				State = 2181;
				_la = _input.La(1);
				if (_la==INDEX || _la==INDEXED) {
					{
					State = 2180; table_indexed_by_part();
					}
				}

				State = 2185;
				_la = _input.La(1);
				if (_la==NOT) {
					{
					State = 2183; Match(NOT);
					State = 2184; Match(NULL);
					}
				}

				}
				break;
			case VARRAY:
			case VARYING:
				{
				State = 2187; varray_type_def();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_indexed_by_partContext : ParserRuleContext {
		public IToken idx1;
		public IToken idx2;
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode INDEXED() { return GetToken(PlSqlParser.INDEXED, 0); }
		public ITerminalNode INDEX() { return GetToken(PlSqlParser.INDEX, 0); }
		public Table_indexed_by_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_indexed_by_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTable_indexed_by_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTable_indexed_by_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_indexed_by_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_indexed_by_partContext table_indexed_by_part() {
		Table_indexed_by_partContext _localctx = new Table_indexed_by_partContext(_ctx, State);
		EnterRule(_localctx, 220, RULE_table_indexed_by_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2192;
			switch (_input.La(1)) {
			case INDEXED:
				{
				State = 2190; _localctx.idx1 = Match(INDEXED);
				}
				break;
			case INDEX:
				{
				State = 2191; _localctx.idx2 = Match(INDEX);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2194; Match(BY);
			State = 2195; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Varray_type_defContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode VARRAY() { return GetToken(PlSqlParser.VARRAY, 0); }
		public ITerminalNode VARYING() { return GetToken(PlSqlParser.VARYING, 0); }
		public ITerminalNode ARRAY() { return GetToken(PlSqlParser.ARRAY, 0); }
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Varray_type_defContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varray_type_def; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterVarray_type_def(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitVarray_type_def(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarray_type_def(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Varray_type_defContext varray_type_def() {
		Varray_type_defContext _localctx = new Varray_type_defContext(_ctx, State);
		EnterRule(_localctx, 222, RULE_varray_type_def);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2200;
			switch (_input.La(1)) {
			case VARRAY:
				{
				State = 2197; Match(VARRAY);
				}
				break;
			case VARYING:
				{
				State = 2198; Match(VARYING);
				State = 2199; Match(ARRAY);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2202; Match(LEFT_PAREN);
			State = 2203; expression();
			State = 2204; Match(RIGHT_PAREN);
			State = 2205; Match(OF);
			State = 2206; type_spec();
			State = 2209;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,202,_ctx) ) {
			case 1:
				{
				State = 2207; Match(NOT);
				State = 2208; Match(NULL);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_var_decContext : ParserRuleContext {
		public Table_var_nameContext table_var_name() {
			return GetRuleContext<Table_var_nameContext>(0);
		}
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public Table_var_decContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_var_dec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTable_var_dec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTable_var_dec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_var_dec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_var_decContext table_var_dec() {
		Table_var_decContext _localctx = new Table_var_decContext(_ctx, State);
		EnterRule(_localctx, 224, RULE_table_var_dec);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2211; table_var_name();
			State = 2212; type_spec();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Seq_of_statementsContext : ParserRuleContext {
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public Label_declarationContext[] label_declaration() {
			return GetRuleContexts<Label_declarationContext>();
		}
		public Label_declarationContext label_declaration(int i) {
			return GetRuleContext<Label_declarationContext>(i);
		}
		public Preprocessor_statementContext[] preprocessor_statement() {
			return GetRuleContexts<Preprocessor_statementContext>();
		}
		public Preprocessor_statementContext preprocessor_statement(int i) {
			return GetRuleContext<Preprocessor_statementContext>(i);
		}
		public Seq_of_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_seq_of_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSeq_of_statements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSeq_of_statements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSeq_of_statements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Seq_of_statementsContext seq_of_statements() {
		Seq_of_statementsContext _localctx = new Seq_of_statementsContext(_ctx, State);
		EnterRule(_localctx, 226, RULE_seq_of_statements);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2219;
			_errHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					State = 2219;
					switch (_input.La(1)) {
					case A_LETTER:
					case ADD:
					case AFTER:
					case AGENT:
					case AGGREGATE:
					case ALL:
					case ALTER:
					case ANALYZE:
					case AND:
					case ANY:
					case ARRAY:
					case AS:
					case ASC:
					case ASSOCIATE:
					case AT:
					case ATTRIBUTE:
					case AUDIT:
					case AUTHID:
					case AUTO:
					case AUTOMATIC:
					case AUTONOMOUS_TRANSACTION:
					case BATCH:
					case BEFORE:
					case BEGIN:
					case BETWEEN:
					case BFILE:
					case BINARY_DOUBLE:
					case BINARY_FLOAT:
					case BINARY_INTEGER:
					case BLOB:
					case BLOCK:
					case BODY:
					case BOOLEAN:
					case BOTH:
					case BREADTH:
					case BULK:
					case BY:
					case BYTE:
					case C_LETTER:
					case CACHE:
					case CALL:
					case CANONICAL:
					case CASCADE:
					case CASE:
					case CAST:
					case CHAR:
					case CHAR_CS:
					case CHARACTER:
					case CHECK:
					case CHR:
					case CLOB:
					case CLOSE:
					case CLUSTER:
					case COLLECT:
					case COLUMNS:
					case COMMENT:
					case COMMIT:
					case COMMITTED:
					case COMPATIBILITY:
					case COMPILE:
					case COMPOUND:
					case CONNECT:
					case CONNECT_BY_ROOT:
					case CONSTANT:
					case CONSTRAINT:
					case CONSTRAINTS:
					case CONSTRUCTOR:
					case CONTENT:
					case CONTEXT:
					case CONTINUE:
					case CONVERT:
					case CORRUPT_XID:
					case CORRUPT_XID_ALL:
					case COST:
					case COUNT:
					case CREATE:
					case CROSS:
					case CUBE:
					case CURRENT:
					case CURRENT_USER:
					case CURSOR:
					case CUSTOMDATUM:
					case CYCLE:
					case DATA:
					case DATABASE:
					case DATE:
					case DAY:
					case DB_ROLE_CHANGE:
					case DBTIMEZONE:
					case DDL:
					case DEBUG:
					case DEC:
					case DECIMAL:
					case DECLARE:
					case DECOMPOSE:
					case DECREMENT:
					case DEFAULT:
					case DEFAULTS:
					case DEFERRED:
					case DEFINER:
					case DELETE:
					case DEPTH:
					case DESC:
					case DETERMINISTIC:
					case DIMENSION:
					case DISABLE:
					case DISASSOCIATE:
					case DISTINCT:
					case DOCUMENT:
					case DOUBLE:
					case DROP:
					case DSINTERVAL_UNCONSTRAINED:
					case EACH:
					case ELEMENT:
					case ELSE:
					case ELSIF:
					case EMPTY:
					case ENABLE:
					case ENCODING:
					case END:
					case ENTITYESCAPING:
					case ERRORS:
					case ESCAPE:
					case EXCEPT:
					case EVALNAME:
					case EXCEPTION:
					case EXCEPTION_INIT:
					case EXCEPTIONS:
					case EXCLUDE:
					case EXCLUSIVE:
					case EXECUTE:
					case EXISTS:
					case EXIT:
					case EXPLAIN:
					case EXTERNAL:
					case EXTRACT:
					case FAILURE:
					case FALSE:
					case FETCH:
					case FINAL:
					case FIRST:
					case FIRST_VALUE:
					case FLOAT:
					case FOLLOWING:
					case FOLLOWS:
					case FOR:
					case FORALL:
					case FORCE:
					case FROM:
					case FULL:
					case FUNCTION:
					case GOTO:
					case GRANT:
					case GROUP:
					case GROUPING:
					case HASH:
					case HAVING:
					case HIDE:
					case HOUR:
					case IF:
					case IGNORE:
					case IMMEDIATE:
					case IN:
					case INCLUDE:
					case INCLUDING:
					case INCREMENT:
					case INDENT:
					case INDEX:
					case INDEXED:
					case INDICATOR:
					case INDICES:
					case INFINITE:
					case INLINE:
					case INNER:
					case INOUT:
					case INSERT:
					case INSTANTIABLE:
					case INSTEAD:
					case INT:
					case INTEGER:
					case INTERSECT:
					case INTERVAL:
					case INTO:
					case INVALIDATE:
					case IS:
					case ISOLATION:
					case ITERATE:
					case JAVA:
					case JOIN:
					case KEEP:
					case LANGUAGE:
					case LAST:
					case LAST_VALUE:
					case LEADING:
					case LEFT:
					case LEVEL:
					case LIBRARY:
					case LIKE:
					case LIKE2:
					case LIKE4:
					case LIKEC:
					case LIMIT:
					case LOCAL:
					case LOCK:
					case LOCKED:
					case LOG:
					case LOGOFF:
					case LOGON:
					case LONG:
					case LOOP:
					case MAIN:
					case MAP:
					case MATCHED:
					case MAXVALUE:
					case MEASURES:
					case MEMBER:
					case MERGE:
					case MINUS:
					case MINUTE:
					case MINVALUE:
					case MLSLABEL:
					case MODE:
					case MODEL:
					case MODIFY:
					case MONTH:
					case MULTISET:
					case NAME:
					case NAN:
					case NATURAL:
					case NATURALN:
					case NAV:
					case NCHAR:
					case NCHAR_CS:
					case NCLOB:
					case NESTED:
					case NEW:
					case NO:
					case NOAUDIT:
					case NOCACHE:
					case NOCOPY:
					case NOCYCLE:
					case NOENTITYESCAPING:
					case NOMAXVALUE:
					case NOMINVALUE:
					case NONE:
					case NOORDER:
					case NOSCHEMACHECK:
					case NOT:
					case NOWAIT:
					case NULL:
					case NULLS:
					case NUMBER:
					case NUMERIC:
					case NVARCHAR2:
					case OBJECT:
					case OF:
					case OFF:
					case OID:
					case OLD:
					case ON:
					case ONLY:
					case OPEN:
					case OPTION:
					case OR:
					case ORADATA:
					case ORDER:
					case ORDINALITY:
					case OSERROR:
					case OUT:
					case OUTER:
					case OVER:
					case OVERRIDING:
					case PACKAGE:
					case PARALLEL_ENABLE:
					case PARAMETERS:
					case PARENT:
					case PARTITION:
					case PASSING:
					case PATH:
					case PIPELINED:
					case PIPE:
					case PIVOT:
					case PLAN:
					case PLS_INTEGER:
					case POSITIVE:
					case POSITIVEN:
					case PRAGMA:
					case PRECEDING:
					case PRECISION:
					case PRESENT:
					case PRIOR:
					case PROCEDURE:
					case RAISE:
					case RANGE:
					case RAW:
					case READ:
					case REAL:
					case RECORD:
					case REF:
					case REFERENCE:
					case REFERENCING:
					case REJECT:
					case RELIES_ON:
					case RENAME:
					case REPLACE:
					case RESPECT:
					case RESTRICT_REFERENCES:
					case RESULT:
					case RESULT_CACHE:
					case RETURN:
					case RETURNING:
					case REUSE:
					case REVERSE:
					case REVOKE:
					case RIGHT:
					case ROLLBACK:
					case ROLLUP:
					case ROW:
					case ROWID:
					case ROWS:
					case RULES:
					case SAMPLE:
					case SAVE:
					case SAVEPOINT:
					case SCHEMA:
					case SCHEMACHECK:
					case SCN:
					case SEARCH:
					case SECOND:
					case SEED:
					case SEGMENT:
					case SELECT:
					case SELF:
					case SEQUENCE:
					case SEQUENTIAL:
					case SERIALIZABLE:
					case SERIALLY_REUSABLE:
					case SERVERERROR:
					case SESSIONTIMEZONE:
					case SET:
					case SETS:
					case SETTINGS:
					case SHARE:
					case SHOW:
					case SHUTDOWN:
					case SIBLINGS:
					case SIGNTYPE:
					case SIMPLE_INTEGER:
					case SINGLE:
					case SIZE:
					case SKIP_:
					case SMALLINT:
					case SNAPSHOT:
					case SOME:
					case SPECIFICATION:
					case SQLDATA:
					case SQLERROR:
					case SQL_PERCENT_ROWCOUNT:
					case STANDALONE:
					case START:
					case STARTUP:
					case STATEMENT:
					case STATEMENT_ID:
					case STATIC:
					case STATISTICS:
					case STRING:
					case SUBMULTISET:
					case SUBPARTITION:
					case SUBSTITUTABLE:
					case SUBTYPE:
					case SUCCESS:
					case SUSPEND:
					case TABLE:
					case THE:
					case THEN:
					case TIME:
					case TIMESTAMP:
					case TIMESTAMP_LTZ_UNCONSTRAINED:
					case TIMESTAMP_TZ_UNCONSTRAINED:
					case TIMESTAMP_UNCONSTRAINED:
					case TIMEZONE_ABBR:
					case TIMEZONE_HOUR:
					case TIMEZONE_MINUTE:
					case TIMEZONE_REGION:
					case TO:
					case TO_CHAR:
					case TRAILING:
					case TRANSACTION:
					case TRANSLATE:
					case TREAT:
					case TRIGGER:
					case TRIM:
					case TRUE:
					case TRUNCATE:
					case TYPE:
					case UNBOUNDED:
					case UNDER:
					case UNION:
					case UNIQUE:
					case UNLIMITED:
					case UNPIVOT:
					case UNTIL:
					case UPDATE:
					case UPDATED:
					case UPSERT:
					case UROWID:
					case USE:
					case USING:
					case VALIDATE:
					case VALUE:
					case VALUES:
					case VARCHAR:
					case VARCHAR2:
					case VARIABLE:
					case VARRAY:
					case VARYING:
					case VERSION:
					case VERSIONS:
					case WAIT:
					case WARNING:
					case WELLFORMED:
					case WHEN:
					case WHENEVER:
					case WHERE:
					case WHILE:
					case WITH:
					case WITHIN:
					case WORK:
					case WRITE:
					case XML:
					case XMLAGG:
					case XMLATTRIBUTES:
					case XMLCAST:
					case XMLCOLATTVAL:
					case XMLELEMENT:
					case XMLEXISTS:
					case XMLFOREST:
					case XMLNAMESPACES:
					case XMLPARSE:
					case XMLPI:
					case XMLQUERY:
					case XMLROOT:
					case XMLSERIALIZE:
					case XMLTABLE:
					case YEAR:
					case YES:
					case YMINTERVAL_UNCONSTRAINED:
					case ZONE:
					case PREDICTION:
					case PREDICTION_BOUNDS:
					case PREDICTION_COST:
					case PREDICTION_DETAILS:
					case PREDICTION_PROBABILITY:
					case PREDICTION_SET:
					case CUME_DIST:
					case DENSE_RANK:
					case LISTAGG:
					case PERCENT_RANK:
					case PERCENTILE_CONT:
					case PERCENTILE_DISC:
					case RANK:
					case AVG:
					case CORR:
					case LAG:
					case LEAD:
					case MAX:
					case MEDIAN:
					case MIN:
					case NTILE:
					case RATIO_TO_REPORT:
					case ROW_NUMBER:
					case SUM:
					case VARIANCE:
					case REGR_:
					case STDDEV:
					case VAR_:
					case COVAR_:
					case DELIMITED_ID:
					case LEFT_PAREN:
					case BINDVAR:
					case COLON:
					case INTRODUCER:
					case REGULAR_ID:
						{
						State = 2214; statement();
						State = 2215; Match(SEMICOLON);
						}
						break;
					case LESS_THAN_OP:
						{
						State = 2217; label_declaration();
						}
						break;
					case PP_IF:
						{
						State = 2218; preprocessor_statement();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2221;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,204,_ctx);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Label_declarationContext : ParserRuleContext {
		public IToken ltp1;
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public Label_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterLabel_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitLabel_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabel_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Label_declarationContext label_declaration() {
		Label_declarationContext _localctx = new Label_declarationContext(_ctx, State);
		EnterRule(_localctx, 228, RULE_label_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2223; _localctx.ltp1 = Match(LESS_THAN_OP);
			State = 2224; Match(LESS_THAN_OP);
			State = 2225; label_name();
			State = 2226; Match(GREATER_THAN_OP);
			State = 2227; Match(GREATER_THAN_OP);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public Swallow_to_semiContext swallow_to_semi() {
			return GetRuleContext<Swallow_to_semiContext>(0);
		}
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode GRANT() { return GetToken(PlSqlParser.GRANT, 0); }
		public ITerminalNode TRUNCATE() { return GetToken(PlSqlParser.TRUNCATE, 0); }
		public ITerminalNode PRAGMA() { return GetToken(PlSqlParser.PRAGMA, 0); }
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public BlockContext block() {
			return GetRuleContext<BlockContext>(0);
		}
		public Assignment_statementContext assignment_statement() {
			return GetRuleContext<Assignment_statementContext>(0);
		}
		public Continue_statementContext continue_statement() {
			return GetRuleContext<Continue_statementContext>(0);
		}
		public Exit_statementContext exit_statement() {
			return GetRuleContext<Exit_statementContext>(0);
		}
		public Goto_statementContext goto_statement() {
			return GetRuleContext<Goto_statementContext>(0);
		}
		public If_statementContext if_statement() {
			return GetRuleContext<If_statementContext>(0);
		}
		public Loop_statementContext loop_statement() {
			return GetRuleContext<Loop_statementContext>(0);
		}
		public Forall_statementContext forall_statement() {
			return GetRuleContext<Forall_statementContext>(0);
		}
		public Null_statementContext null_statement() {
			return GetRuleContext<Null_statementContext>(0);
		}
		public Raise_statementContext raise_statement() {
			return GetRuleContext<Raise_statementContext>(0);
		}
		public Return_statementContext return_statement() {
			return GetRuleContext<Return_statementContext>(0);
		}
		public Case_statementContext case_statement() {
			return GetRuleContext<Case_statementContext>(0);
		}
		public Sql_statementContext sql_statement() {
			return GetRuleContext<Sql_statementContext>(0);
		}
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public Pipe_rowContext pipe_row() {
			return GetRuleContext<Pipe_rowContext>(0);
		}
		public Collection_statementContext collection_statement() {
			return GetRuleContext<Collection_statementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 230, RULE_statement);
		try {
			State = 2256;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,205,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2229; Match(CREATE);
				State = 2230; swallow_to_semi();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2231; Match(ALTER);
				State = 2232; swallow_to_semi();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2233; Match(GRANT);
				State = 2234; swallow_to_semi();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2235; Match(TRUNCATE);
				State = 2236; swallow_to_semi();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2237; Match(PRAGMA);
				State = 2238; swallow_to_semi();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2239; body();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2240; block();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2241; assignment_statement();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2242; continue_statement();
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2243; exit_statement();
				}
				break;

			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 2244; goto_statement();
				}
				break;

			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 2245; if_statement();
				}
				break;

			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 2246; loop_statement();
				}
				break;

			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 2247; forall_statement();
				}
				break;

			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 2248; null_statement();
				}
				break;

			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 2249; raise_statement();
				}
				break;

			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 2250; return_statement();
				}
				break;

			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 2251; case_statement();
				}
				break;

			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 2252; sql_statement();
				}
				break;

			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 2253; function_call();
				}
				break;

			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 2254; pipe_row();
				}
				break;

			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 2255; collection_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Assignment_statementContext : ParserRuleContext {
		public ITerminalNode ASSIGN_OP() { return GetToken(PlSqlParser.ASSIGN_OP, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Collection_assoc_expressionContext collection_assoc_expression() {
			return GetRuleContext<Collection_assoc_expressionContext>(0);
		}
		public General_elementContext general_element() {
			return GetRuleContext<General_elementContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public Assignment_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAssignment_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAssignment_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignment_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Assignment_statementContext assignment_statement() {
		Assignment_statementContext _localctx = new Assignment_statementContext(_ctx, State);
		EnterRule(_localctx, 232, RULE_assignment_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2261;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,206,_ctx) ) {
			case 1:
				{
				State = 2258; collection_assoc_expression();
				}
				break;

			case 2:
				{
				State = 2259; general_element();
				}
				break;

			case 3:
				{
				State = 2260; bind_variable();
				}
				break;
			}
			State = 2263; Match(ASSIGN_OP);
			State = 2264; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Continue_statementContext : ParserRuleContext {
		public ITerminalNode CONTINUE() { return GetToken(PlSqlParser.CONTINUE, 0); }
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Continue_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_continue_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterContinue_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitContinue_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitContinue_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Continue_statementContext continue_statement() {
		Continue_statementContext _localctx = new Continue_statementContext(_ctx, State);
		EnterRule(_localctx, 234, RULE_continue_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2266; Match(CONTINUE);
			State = 2268;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,207,_ctx) ) {
			case 1:
				{
				State = 2267; label_name();
				}
				break;
			}
			State = 2272;
			_la = _input.La(1);
			if (_la==WHEN) {
				{
				State = 2270; Match(WHEN);
				State = 2271; condition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exit_statementContext : ParserRuleContext {
		public ITerminalNode EXIT() { return GetToken(PlSqlParser.EXIT, 0); }
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Exit_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exit_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterExit_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitExit_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExit_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exit_statementContext exit_statement() {
		Exit_statementContext _localctx = new Exit_statementContext(_ctx, State);
		EnterRule(_localctx, 236, RULE_exit_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2274; Match(EXIT);
			State = 2276;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,209,_ctx) ) {
			case 1:
				{
				State = 2275; label_name();
				}
				break;
			}
			State = 2280;
			_la = _input.La(1);
			if (_la==WHEN) {
				{
				State = 2278; Match(WHEN);
				State = 2279; condition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Goto_statementContext : ParserRuleContext {
		public ITerminalNode GOTO() { return GetToken(PlSqlParser.GOTO, 0); }
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public Goto_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_goto_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterGoto_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitGoto_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGoto_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Goto_statementContext goto_statement() {
		Goto_statementContext _localctx = new Goto_statementContext(_ctx, State);
		EnterRule(_localctx, 238, RULE_goto_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2282; Match(GOTO);
			State = 2283; label_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class If_statementContext : ParserRuleContext {
		public ITerminalNode[] IF() { return GetTokens(PlSqlParser.IF); }
		public ITerminalNode IF(int i) {
			return GetToken(PlSqlParser.IF, i);
		}
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public Elsif_partContext[] elsif_part() {
			return GetRuleContexts<Elsif_partContext>();
		}
		public Elsif_partContext elsif_part(int i) {
			return GetRuleContext<Elsif_partContext>(i);
		}
		public Else_partContext else_part() {
			return GetRuleContext<Else_partContext>(0);
		}
		public If_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_if_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterIf_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitIf_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIf_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public If_statementContext if_statement() {
		If_statementContext _localctx = new If_statementContext(_ctx, State);
		EnterRule(_localctx, 240, RULE_if_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2285; Match(IF);
			State = 2286; condition();
			State = 2287; Match(THEN);
			State = 2288; seq_of_statements();
			State = 2292;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==ELSIF) {
				{
				{
				State = 2289; elsif_part();
				}
				}
				State = 2294;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2296;
			_la = _input.La(1);
			if (_la==ELSE) {
				{
				State = 2295; else_part();
				}
			}

			State = 2298; Match(END);
			State = 2299; Match(IF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Elsif_partContext : ParserRuleContext {
		public ITerminalNode ELSIF() { return GetToken(PlSqlParser.ELSIF, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Elsif_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elsif_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterElsif_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitElsif_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElsif_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Elsif_partContext elsif_part() {
		Elsif_partContext _localctx = new Elsif_partContext(_ctx, State);
		EnterRule(_localctx, 242, RULE_elsif_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2301; Match(ELSIF);
			State = 2302; condition();
			State = 2303; Match(THEN);
			State = 2304; seq_of_statements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Else_partContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(PlSqlParser.ELSE, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Else_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_else_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterElse_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitElse_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElse_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Else_partContext else_part() {
		Else_partContext _localctx = new Else_partContext(_ctx, State);
		EnterRule(_localctx, 244, RULE_else_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2306; Match(ELSE);
			State = 2307; seq_of_statements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Loop_statementContext : ParserRuleContext {
		public ITerminalNode[] LOOP() { return GetTokens(PlSqlParser.LOOP); }
		public ITerminalNode LOOP(int i) {
			return GetToken(PlSqlParser.LOOP, i);
		}
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public Label_nameContext[] label_name() {
			return GetRuleContexts<Label_nameContext>();
		}
		public Label_nameContext label_name(int i) {
			return GetRuleContext<Label_nameContext>(i);
		}
		public ITerminalNode WHILE() { return GetToken(PlSqlParser.WHILE, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Cursor_loop_paramContext cursor_loop_param() {
			return GetRuleContext<Cursor_loop_paramContext>(0);
		}
		public Loop_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterLoop_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitLoop_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoop_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Loop_statementContext loop_statement() {
		Loop_statementContext _localctx = new Loop_statementContext(_ctx, State);
		EnterRule(_localctx, 246, RULE_loop_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2310;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,213,_ctx) ) {
			case 1:
				{
				State = 2309; label_name();
				}
				break;
			}
			State = 2316;
			switch (_input.La(1)) {
			case WHILE:
				{
				State = 2312; Match(WHILE);
				State = 2313; condition();
				}
				break;
			case FOR:
				{
				State = 2314; Match(FOR);
				State = 2315; cursor_loop_param();
				}
				break;
			case LOOP:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2318; Match(LOOP);
			State = 2319; seq_of_statements();
			State = 2320; Match(END);
			State = 2321; Match(LOOP);
			State = 2323;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (DELIMITED_ID - 448)))) != 0) || _la==REGULAR_ID) {
				{
				State = 2322; label_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_loop_paramContext : ParserRuleContext {
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public Lower_boundContext lower_bound() {
			return GetRuleContext<Lower_boundContext>(0);
		}
		public Upper_boundContext upper_bound() {
			return GetRuleContext<Upper_boundContext>(0);
		}
		public ITerminalNode REVERSE() { return GetToken(PlSqlParser.REVERSE, 0); }
		public Record_nameContext record_name() {
			return GetRuleContext<Record_nameContext>(0);
		}
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public Cursor_loop_paramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_loop_param; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCursor_loop_param(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCursor_loop_param(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_loop_param(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_loop_paramContext cursor_loop_param() {
		Cursor_loop_paramContext _localctx = new Cursor_loop_paramContext(_ctx, State);
		EnterRule(_localctx, 248, RULE_cursor_loop_param);
		int _la;
		try {
			State = 2346;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,219,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2325; index_name();
				State = 2326; Match(IN);
				State = 2328;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,216,_ctx) ) {
				case 1:
					{
					State = 2327; Match(REVERSE);
					}
					break;
				}
				State = 2330; lower_bound();
				State = 2331; Match(T__0);
				State = 2332; upper_bound();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2334; record_name();
				State = 2335; Match(IN);
				State = 2344;
				switch (_input.La(1)) {
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ALL:
				case ALTER:
				case ANALYZE:
				case AND:
				case ANY:
				case ARRAY:
				case AS:
				case ASC:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BEGIN:
				case BETWEEN:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BREADTH:
				case BULK:
				case BY:
				case BYTE:
				case C_LETTER:
				case CACHE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CASE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHECK:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONNECT:
				case CONNECT_BY_ROOT:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CREATE:
				case CROSS:
				case CUBE:
				case CURRENT:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DATE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECLARE:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DEPTH:
				case DESC:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DISTINCT:
				case DOCUMENT:
				case DOUBLE:
				case DROP:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case ELSE:
				case ELSIF:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case END:
				case ENTITYESCAPING:
				case ERRORS:
				case ESCAPE:
				case EXCEPT:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXCLUSIVE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FALSE:
				case FETCH:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FOR:
				case FORALL:
				case FORCE:
				case FROM:
				case FULL:
				case FUNCTION:
				case GOTO:
				case GRANT:
				case GROUP:
				case GROUPING:
				case HASH:
				case HAVING:
				case HIDE:
				case HOUR:
				case IF:
				case IGNORE:
				case IMMEDIATE:
				case IN:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEX:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSERT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERSECT:
				case INTERVAL:
				case INTO:
				case INVALIDATE:
				case IS:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCK:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUS:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODE:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCACHE:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NOMAXVALUE:
				case NOMINVALUE:
				case NONE:
				case NOORDER:
				case NOSCHEMACHECK:
				case NOT:
				case NOWAIT:
				case NULL:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OF:
				case OFF:
				case OID:
				case OLD:
				case ON:
				case ONLY:
				case OPEN:
				case OPTION:
				case OR:
				case ORADATA:
				case ORDER:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PIVOT:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIOR:
				case PROCEDURE:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SEARCH:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELECT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHARE:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case SQL_PERCENT_ROWCOUNT:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TABLE:
				case THE:
				case THEN:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TO:
				case TO_CHAR:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRIM:
				case TRUE:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNION:
				case UNIQUE:
				case UNLIMITED:
				case UNPIVOT:
				case UNTIL:
				case UPDATE:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case USING:
				case VALIDATE:
				case VALUE:
				case VALUES:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHEN:
				case WHENEVER:
				case WHERE:
				case WHILE:
				case WITH:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case ROW_NUMBER:
				case SUM:
				case VARIANCE:
				case REGR_:
				case STDDEV:
				case VAR_:
				case COVAR_:
				case DELIMITED_ID:
				case BINDVAR:
				case COLON:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 2336; cursor_name();
					State = 2338;
					_la = _input.La(1);
					if (_la==LEFT_PAREN) {
						{
						State = 2337; expression_list();
						}
					}

					}
					break;
				case LEFT_PAREN:
					{
					State = 2340; Match(LEFT_PAREN);
					State = 2341; select_statement();
					State = 2342; Match(RIGHT_PAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Forall_statementContext : ParserRuleContext {
		public ITerminalNode FORALL() { return GetToken(PlSqlParser.FORALL, 0); }
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public Bounds_clauseContext bounds_clause() {
			return GetRuleContext<Bounds_clauseContext>(0);
		}
		public Sql_statementContext sql_statement() {
			return GetRuleContext<Sql_statementContext>(0);
		}
		public ITerminalNode SAVE() { return GetToken(PlSqlParser.SAVE, 0); }
		public ITerminalNode EXCEPTIONS() { return GetToken(PlSqlParser.EXCEPTIONS, 0); }
		public Forall_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forall_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterForall_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitForall_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForall_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Forall_statementContext forall_statement() {
		Forall_statementContext _localctx = new Forall_statementContext(_ctx, State);
		EnterRule(_localctx, 250, RULE_forall_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2348; Match(FORALL);
			State = 2349; index_name();
			State = 2350; Match(IN);
			State = 2351; bounds_clause();
			State = 2352; sql_statement();
			State = 2355;
			_la = _input.La(1);
			if (_la==SAVE) {
				{
				State = 2353; Match(SAVE);
				State = 2354; Match(EXCEPTIONS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Bounds_clauseContext : ParserRuleContext {
		public Lower_boundContext lower_bound() {
			return GetRuleContext<Lower_boundContext>(0);
		}
		public Upper_boundContext upper_bound() {
			return GetRuleContext<Upper_boundContext>(0);
		}
		public ITerminalNode INDICES() { return GetToken(PlSqlParser.INDICES, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Collection_nameContext collection_name() {
			return GetRuleContext<Collection_nameContext>(0);
		}
		public Between_boundContext between_bound() {
			return GetRuleContext<Between_boundContext>(0);
		}
		public ITerminalNode VALUES() { return GetToken(PlSqlParser.VALUES, 0); }
		public Index_nameContext index_name() {
			return GetRuleContext<Index_nameContext>(0);
		}
		public Bounds_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bounds_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterBounds_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitBounds_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBounds_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Bounds_clauseContext bounds_clause() {
		Bounds_clauseContext _localctx = new Bounds_clauseContext(_ctx, State);
		EnterRule(_localctx, 252, RULE_bounds_clause);
		int _la;
		try {
			State = 2370;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,222,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2357; lower_bound();
				State = 2358; Match(T__0);
				State = 2359; upper_bound();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2361; Match(INDICES);
				State = 2362; Match(OF);
				State = 2363; collection_name();
				State = 2365;
				_la = _input.La(1);
				if (_la==BETWEEN) {
					{
					State = 2364; between_bound();
					}
				}

				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2367; Match(VALUES);
				State = 2368; Match(OF);
				State = 2369; index_name();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Between_boundContext : ParserRuleContext {
		public ITerminalNode BETWEEN() { return GetToken(PlSqlParser.BETWEEN, 0); }
		public Lower_boundContext lower_bound() {
			return GetRuleContext<Lower_boundContext>(0);
		}
		public ITerminalNode AND() { return GetToken(PlSqlParser.AND, 0); }
		public Upper_boundContext upper_bound() {
			return GetRuleContext<Upper_boundContext>(0);
		}
		public Between_boundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_between_bound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterBetween_bound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitBetween_bound(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBetween_bound(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Between_boundContext between_bound() {
		Between_boundContext _localctx = new Between_boundContext(_ctx, State);
		EnterRule(_localctx, 254, RULE_between_bound);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2372; Match(BETWEEN);
			State = 2373; lower_bound();
			State = 2374; Match(AND);
			State = 2375; upper_bound();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lower_boundContext : ParserRuleContext {
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Lower_boundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lower_bound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterLower_bound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitLower_bound(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLower_bound(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lower_boundContext lower_bound() {
		Lower_boundContext _localctx = new Lower_boundContext(_ctx, State);
		EnterRule(_localctx, 256, RULE_lower_bound);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2377; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Upper_boundContext : ParserRuleContext {
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Upper_boundContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_upper_bound; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterUpper_bound(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitUpper_bound(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpper_bound(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Upper_boundContext upper_bound() {
		Upper_boundContext _localctx = new Upper_boundContext(_ctx, State);
		EnterRule(_localctx, 258, RULE_upper_bound);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2379; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Null_statementContext : ParserRuleContext {
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public Null_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_null_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterNull_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitNull_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNull_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Null_statementContext null_statement() {
		Null_statementContext _localctx = new Null_statementContext(_ctx, State);
		EnterRule(_localctx, 260, RULE_null_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2381; Match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Raise_statementContext : ParserRuleContext {
		public ITerminalNode RAISE() { return GetToken(PlSqlParser.RAISE, 0); }
		public Exception_nameContext exception_name() {
			return GetRuleContext<Exception_nameContext>(0);
		}
		public Raise_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_raise_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRaise_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRaise_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRaise_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Raise_statementContext raise_statement() {
		Raise_statementContext _localctx = new Raise_statementContext(_ctx, State);
		EnterRule(_localctx, 262, RULE_raise_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2383; Match(RAISE);
			State = 2385;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (DELIMITED_ID - 448)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 2384; exception_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Return_statementContext : ParserRuleContext {
		public ConditionContext cn1;
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Return_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_return_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterReturn_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitReturn_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturn_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Return_statementContext return_statement() {
		Return_statementContext _localctx = new Return_statementContext(_ctx, State);
		EnterRule(_localctx, 264, RULE_return_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2387; Match(RETURN);
			State = 2389;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MOD - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TO_NUMBER - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (LEFT_PAREN - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (PLUS_SIGN - 512)) | (1L << (MINUS_SIGN - 512)) | (1L << (BINDVAR - 512)) | (1L << (COLON - 512)) | (1L << (INTRODUCER - 512)))) != 0) || _la==REGULAR_ID) {
				{
				State = 2388; _localctx.cn1 = condition();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_callContext : ParserRuleContext {
		public Routine_nameContext routine_name() {
			return GetRuleContext<Routine_nameContext>(0);
		}
		public ITerminalNode CALL() { return GetToken(PlSqlParser.CALL, 0); }
		public Function_argumentContext function_argument() {
			return GetRuleContext<Function_argumentContext>(0);
		}
		public Function_callContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_call; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFunction_call(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFunction_call(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_call(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_callContext function_call() {
		Function_callContext _localctx = new Function_callContext(_ctx, State);
		EnterRule(_localctx, 266, RULE_function_call);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2392;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,225,_ctx) ) {
			case 1:
				{
				State = 2391; Match(CALL);
				}
				break;
			}
			State = 2394; routine_name();
			State = 2396;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,226,_ctx) ) {
			case 1:
				{
				State = 2395; function_argument();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BodyContext : ParserRuleContext {
		public ITerminalNode BEGIN() { return GetToken(PlSqlParser.BEGIN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public Exception_clauseContext exception_clause() {
			return GetRuleContext<Exception_clauseContext>(0);
		}
		public Label_nameContext label_name() {
			return GetRuleContext<Label_nameContext>(0);
		}
		public BodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterBody(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitBody(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BodyContext body() {
		BodyContext _localctx = new BodyContext(_ctx, State);
		EnterRule(_localctx, 268, RULE_body);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2398; Match(BEGIN);
			State = 2399; seq_of_statements();
			State = 2401;
			_la = _input.La(1);
			if (_la==EXCEPTION) {
				{
				State = 2400; exception_clause();
				}
			}

			State = 2403; Match(END);
			State = 2405;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,228,_ctx) ) {
			case 1:
				{
				State = 2404; label_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Collection_statementContext : ParserRuleContext {
		public Collection_assoc_expressionContext collection_assoc_expression() {
			return GetRuleContext<Collection_assoc_expressionContext>(0);
		}
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode EXTEND() { return GetToken(PlSqlParser.EXTEND, 0); }
		public ITerminalNode TRIM() { return GetToken(PlSqlParser.TRIM, 0); }
		public Collection_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collection_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCollection_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCollection_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollection_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Collection_statementContext collection_statement() {
		Collection_statementContext _localctx = new Collection_statementContext(_ctx, State);
		EnterRule(_localctx, 270, RULE_collection_statement);
		int _la;
		try {
			State = 2445;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,237,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2407; collection_assoc_expression();
				State = 2408; Match(PERIOD);
				State = 2409; Match(DELETE);
				State = 2419;
				_la = _input.La(1);
				if (_la==LEFT_PAREN) {
					{
					State = 2410; Match(LEFT_PAREN);
					State = 2416;
					_la = _input.La(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MOD - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TO_NUMBER - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (LEFT_PAREN - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (PLUS_SIGN - 512)) | (1L << (MINUS_SIGN - 512)) | (1L << (BINDVAR - 512)) | (1L << (COLON - 512)) | (1L << (INTRODUCER - 512)))) != 0) || _la==REGULAR_ID) {
						{
						State = 2411; expression();
						State = 2414;
						_la = _input.La(1);
						if (_la==COMMA) {
							{
							State = 2412; Match(COMMA);
							State = 2413; expression();
							}
						}

						}
					}

					State = 2418; Match(RIGHT_PAREN);
					}
				}

				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2421; collection_assoc_expression();
				State = 2422; Match(PERIOD);
				State = 2423; Match(EXTEND);
				State = 2433;
				_la = _input.La(1);
				if (_la==LEFT_PAREN) {
					{
					State = 2424; Match(LEFT_PAREN);
					State = 2430;
					_la = _input.La(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MOD - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TO_NUMBER - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (LEFT_PAREN - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (PLUS_SIGN - 512)) | (1L << (MINUS_SIGN - 512)) | (1L << (BINDVAR - 512)) | (1L << (COLON - 512)) | (1L << (INTRODUCER - 512)))) != 0) || _la==REGULAR_ID) {
						{
						State = 2425; expression();
						State = 2428;
						_la = _input.La(1);
						if (_la==COMMA) {
							{
							State = 2426; Match(COMMA);
							State = 2427; expression();
							}
						}

						}
					}

					State = 2432; Match(RIGHT_PAREN);
					}
				}

				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2435; collection_assoc_expression();
				State = 2436; Match(PERIOD);
				State = 2437; Match(TRIM);
				State = 2443;
				_la = _input.La(1);
				if (_la==LEFT_PAREN) {
					{
					State = 2438; Match(LEFT_PAREN);
					State = 2440;
					_la = _input.La(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MOD - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TO_NUMBER - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (LEFT_PAREN - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (PLUS_SIGN - 512)) | (1L << (MINUS_SIGN - 512)) | (1L << (BINDVAR - 512)) | (1L << (COLON - 512)) | (1L << (INTRODUCER - 512)))) != 0) || _la==REGULAR_ID) {
						{
						State = 2439; expression();
						}
					}

					State = 2442; Match(RIGHT_PAREN);
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pipe_rowContext : ParserRuleContext {
		public ITerminalNode PIPE() { return GetToken(PlSqlParser.PIPE, 0); }
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Pipe_rowContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pipe_row; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPipe_row(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPipe_row(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPipe_row(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pipe_rowContext pipe_row() {
		Pipe_rowContext _localctx = new Pipe_rowContext(_ctx, State);
		EnterRule(_localctx, 272, RULE_pipe_row);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2447; Match(PIPE);
			State = 2448; Match(ROW);
			State = 2449; Match(LEFT_PAREN);
			State = 2450; expression();
			State = 2451; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_clauseContext : ParserRuleContext {
		public ITerminalNode EXCEPTION() { return GetToken(PlSqlParser.EXCEPTION, 0); }
		public Exception_handlerContext[] exception_handler() {
			return GetRuleContexts<Exception_handlerContext>();
		}
		public Exception_handlerContext exception_handler(int i) {
			return GetRuleContext<Exception_handlerContext>(i);
		}
		public Exception_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterException_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitException_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitException_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exception_clauseContext exception_clause() {
		Exception_clauseContext _localctx = new Exception_clauseContext(_ctx, State);
		EnterRule(_localctx, 274, RULE_exception_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2453; Match(EXCEPTION);
			State = 2455;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 2454; exception_handler();
				}
				}
				State = 2457;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WHEN );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_handlerContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public Exception_nameContext[] exception_name() {
			return GetRuleContexts<Exception_nameContext>();
		}
		public Exception_nameContext exception_name(int i) {
			return GetRuleContext<Exception_nameContext>(i);
		}
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public ITerminalNode[] OR() { return GetTokens(PlSqlParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(PlSqlParser.OR, i);
		}
		public Exception_handlerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_handler; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterException_handler(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitException_handler(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitException_handler(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exception_handlerContext exception_handler() {
		Exception_handlerContext _localctx = new Exception_handlerContext(_ctx, State);
		EnterRule(_localctx, 276, RULE_exception_handler);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2459; Match(WHEN);
			State = 2460; exception_name();
			State = 2465;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==OR) {
				{
				{
				State = 2461; Match(OR);
				State = 2462; exception_name();
				}
				}
				State = 2467;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2468; Match(THEN);
			State = 2469; seq_of_statements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_blockContext : ParserRuleContext {
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Declare_wrapperContext declare_wrapper() {
			return GetRuleContext<Declare_wrapperContext>(0);
		}
		public Trigger_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTrigger_block(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTrigger_block(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_block(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_blockContext trigger_block() {
		Trigger_blockContext _localctx = new Trigger_blockContext(_ctx, State);
		EnterRule(_localctx, 278, RULE_trigger_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2472;
			_la = _input.La(1);
			if (_la==DECLARE) {
				{
				State = 2471; declare_wrapper();
				}
			}

			State = 2474; body();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BlockContext : ParserRuleContext {
		public BodyContext body() {
			return GetRuleContext<BodyContext>(0);
		}
		public Declare_wrapperContext declare_wrapper() {
			return GetRuleContext<Declare_wrapperContext>(0);
		}
		public BlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitBlock(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBlock(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BlockContext block() {
		BlockContext _localctx = new BlockContext(_ctx, State);
		EnterRule(_localctx, 280, RULE_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2477;
			_la = _input.La(1);
			if (_la==DECLARE) {
				{
				State = 2476; declare_wrapper();
				}
			}

			State = 2479; body();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sql_statementContext : ParserRuleContext {
		public Execute_immediateContext execute_immediate() {
			return GetRuleContext<Execute_immediateContext>(0);
		}
		public Data_manipulation_language_statementsContext data_manipulation_language_statements() {
			return GetRuleContext<Data_manipulation_language_statementsContext>(0);
		}
		public Cursor_manipulation_statementsContext cursor_manipulation_statements() {
			return GetRuleContext<Cursor_manipulation_statementsContext>(0);
		}
		public Transaction_control_statementsContext transaction_control_statements() {
			return GetRuleContext<Transaction_control_statementsContext>(0);
		}
		public Sql_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sql_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSql_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSql_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSql_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sql_statementContext sql_statement() {
		Sql_statementContext _localctx = new Sql_statementContext(_ctx, State);
		EnterRule(_localctx, 282, RULE_sql_statement);
		try {
			State = 2485;
			switch (_input.La(1)) {
			case EXECUTE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2481; execute_immediate();
				}
				break;
			case DELETE:
			case EXPLAIN:
			case INSERT:
			case LOCK:
			case MERGE:
			case SELECT:
			case UPDATE:
			case WITH:
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2482; data_manipulation_language_statements();
				}
				break;
			case CLOSE:
			case FETCH:
			case OPEN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2483; cursor_manipulation_statements();
				}
				break;
			case COMMIT:
			case ROLLBACK:
			case SAVEPOINT:
			case SET:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2484; transaction_control_statements();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Execute_immediateContext : ParserRuleContext {
		public ITerminalNode EXECUTE() { return GetToken(PlSqlParser.EXECUTE, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(PlSqlParser.IMMEDIATE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public Using_clauseContext using_clause() {
			return GetRuleContext<Using_clauseContext>(0);
		}
		public Dynamic_returning_clauseContext dynamic_returning_clause() {
			return GetRuleContext<Dynamic_returning_clauseContext>(0);
		}
		public Execute_immediateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_execute_immediate; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterExecute_immediate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitExecute_immediate(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExecute_immediate(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Execute_immediateContext execute_immediate() {
		Execute_immediateContext _localctx = new Execute_immediateContext(_ctx, State);
		EnterRule(_localctx, 284, RULE_execute_immediate);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2487; Match(EXECUTE);
			State = 2488; Match(IMMEDIATE);
			State = 2489; expression();
			State = 2499;
			switch (_input.La(1)) {
			case BULK:
			case INTO:
				{
				State = 2490; into_clause();
				State = 2492;
				_la = _input.La(1);
				if (_la==USING) {
					{
					State = 2491; using_clause();
					}
				}

				}
				break;
			case USING:
				{
				State = 2494; using_clause();
				State = 2496;
				_la = _input.La(1);
				if (_la==RETURN || _la==RETURNING) {
					{
					State = 2495; dynamic_returning_clause();
					}
				}

				}
				break;
			case RETURN:
			case RETURNING:
				{
				State = 2498; dynamic_returning_clause();
				}
				break;
			case SAVE:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dynamic_returning_clauseContext : ParserRuleContext {
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public ITerminalNode RETURNING() { return GetToken(PlSqlParser.RETURNING, 0); }
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Dynamic_returning_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dynamic_returning_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDynamic_returning_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDynamic_returning_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDynamic_returning_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dynamic_returning_clauseContext dynamic_returning_clause() {
		Dynamic_returning_clauseContext _localctx = new Dynamic_returning_clauseContext(_ctx, State);
		EnterRule(_localctx, 286, RULE_dynamic_returning_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2501;
			_la = _input.La(1);
			if ( !(_la==RETURN || _la==RETURNING) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 2502; into_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Data_manipulation_language_statementsContext : ParserRuleContext {
		public Merge_statementContext merge_statement() {
			return GetRuleContext<Merge_statementContext>(0);
		}
		public Lock_table_statementContext lock_table_statement() {
			return GetRuleContext<Lock_table_statementContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Update_statementContext update_statement() {
			return GetRuleContext<Update_statementContext>(0);
		}
		public Delete_statementContext delete_statement() {
			return GetRuleContext<Delete_statementContext>(0);
		}
		public Insert_statementContext insert_statement() {
			return GetRuleContext<Insert_statementContext>(0);
		}
		public Explain_statementContext explain_statement() {
			return GetRuleContext<Explain_statementContext>(0);
		}
		public Data_manipulation_language_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_data_manipulation_language_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterData_manipulation_language_statements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitData_manipulation_language_statements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitData_manipulation_language_statements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Data_manipulation_language_statementsContext data_manipulation_language_statements() {
		Data_manipulation_language_statementsContext _localctx = new Data_manipulation_language_statementsContext(_ctx, State);
		EnterRule(_localctx, 288, RULE_data_manipulation_language_statements);
		try {
			State = 2511;
			switch (_input.La(1)) {
			case MERGE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2504; merge_statement();
				}
				break;
			case LOCK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2505; lock_table_statement();
				}
				break;
			case SELECT:
			case WITH:
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2506; select_statement();
				}
				break;
			case UPDATE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2507; update_statement();
				}
				break;
			case DELETE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2508; delete_statement();
				}
				break;
			case INSERT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2509; insert_statement();
				}
				break;
			case EXPLAIN:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2510; explain_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_manipulation_statementsContext : ParserRuleContext {
		public Close_statementContext close_statement() {
			return GetRuleContext<Close_statementContext>(0);
		}
		public Open_statementContext open_statement() {
			return GetRuleContext<Open_statementContext>(0);
		}
		public Fetch_statementContext fetch_statement() {
			return GetRuleContext<Fetch_statementContext>(0);
		}
		public Open_for_statementContext open_for_statement() {
			return GetRuleContext<Open_for_statementContext>(0);
		}
		public Cursor_manipulation_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_manipulation_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCursor_manipulation_statements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCursor_manipulation_statements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_manipulation_statements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_manipulation_statementsContext cursor_manipulation_statements() {
		Cursor_manipulation_statementsContext _localctx = new Cursor_manipulation_statementsContext(_ctx, State);
		EnterRule(_localctx, 290, RULE_cursor_manipulation_statements);
		try {
			State = 2517;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,247,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2513; close_statement();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2514; open_statement();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2515; fetch_statement();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2516; open_for_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Close_statementContext : ParserRuleContext {
		public ITerminalNode CLOSE() { return GetToken(PlSqlParser.CLOSE, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Close_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_close_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterClose_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitClose_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClose_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Close_statementContext close_statement() {
		Close_statementContext _localctx = new Close_statementContext(_ctx, State);
		EnterRule(_localctx, 292, RULE_close_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2519; Match(CLOSE);
			State = 2520; cursor_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Open_statementContext : ParserRuleContext {
		public ITerminalNode OPEN() { return GetToken(PlSqlParser.OPEN, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public Open_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_open_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterOpen_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitOpen_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpen_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Open_statementContext open_statement() {
		Open_statementContext _localctx = new Open_statementContext(_ctx, State);
		EnterRule(_localctx, 294, RULE_open_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2522; Match(OPEN);
			State = 2523; cursor_name();
			State = 2525;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2524; expression_list();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Fetch_statementContext : ParserRuleContext {
		public IToken it1;
		public ITerminalNode FETCH() { return GetToken(PlSqlParser.FETCH, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Variable_nameContext[] variable_name() {
			return GetRuleContexts<Variable_nameContext>();
		}
		public Variable_nameContext variable_name(int i) {
			return GetRuleContext<Variable_nameContext>(i);
		}
		public ITerminalNode BULK() { return GetToken(PlSqlParser.BULK, 0); }
		public ITerminalNode COLLECT() { return GetToken(PlSqlParser.COLLECT, 0); }
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public ITerminalNode LIMIT() { return GetToken(PlSqlParser.LIMIT, 0); }
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public Fetch_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fetch_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFetch_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFetch_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFetch_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Fetch_statementContext fetch_statement() {
		Fetch_statementContext _localctx = new Fetch_statementContext(_ctx, State);
		EnterRule(_localctx, 296, RULE_fetch_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2527; Match(FETCH);
			State = 2528; cursor_name();
			State = 2556;
			switch (_input.La(1)) {
			case INTO:
				{
				State = 2529; _localctx.it1 = Match(INTO);
				State = 2530; variable_name();
				State = 2535;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2531; Match(COMMA);
					State = 2532; variable_name();
					}
					}
					State = 2537;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			case BULK:
				{
				State = 2538; Match(BULK);
				State = 2539; Match(COLLECT);
				State = 2540; Match(INTO);
				State = 2541; variable_name();
				State = 2546;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2542; Match(COMMA);
					State = 2543; variable_name();
					}
					}
					State = 2548;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 2554;
				_la = _input.La(1);
				if (_la==LIMIT) {
					{
					State = 2549; Match(LIMIT);
					State = 2552;
					switch (_input.La(1)) {
					case A_LETTER:
					case ADD:
					case AFTER:
					case AGENT:
					case AGGREGATE:
					case ALL:
					case ALTER:
					case ANALYZE:
					case AND:
					case ANY:
					case ARRAY:
					case AS:
					case ASC:
					case ASSOCIATE:
					case AT:
					case ATTRIBUTE:
					case AUDIT:
					case AUTHID:
					case AUTO:
					case AUTOMATIC:
					case AUTONOMOUS_TRANSACTION:
					case BATCH:
					case BEFORE:
					case BEGIN:
					case BETWEEN:
					case BFILE:
					case BINARY_DOUBLE:
					case BINARY_FLOAT:
					case BINARY_INTEGER:
					case BLOB:
					case BLOCK:
					case BODY:
					case BOOLEAN:
					case BOTH:
					case BREADTH:
					case BULK:
					case BY:
					case BYTE:
					case C_LETTER:
					case CACHE:
					case CALL:
					case CANONICAL:
					case CASCADE:
					case CASE:
					case CAST:
					case CHAR:
					case CHAR_CS:
					case CHARACTER:
					case CHECK:
					case CHR:
					case CLOB:
					case CLOSE:
					case CLUSTER:
					case COLLECT:
					case COLUMNS:
					case COMMENT:
					case COMMIT:
					case COMMITTED:
					case COMPATIBILITY:
					case COMPILE:
					case COMPOUND:
					case CONNECT:
					case CONNECT_BY_ROOT:
					case CONSTANT:
					case CONSTRAINT:
					case CONSTRAINTS:
					case CONSTRUCTOR:
					case CONTENT:
					case CONTEXT:
					case CONTINUE:
					case CONVERT:
					case CORRUPT_XID:
					case CORRUPT_XID_ALL:
					case COST:
					case COUNT:
					case CREATE:
					case CROSS:
					case CUBE:
					case CURRENT:
					case CURRENT_USER:
					case CURSOR:
					case CUSTOMDATUM:
					case CYCLE:
					case DATA:
					case DATABASE:
					case DATE:
					case DAY:
					case DB_ROLE_CHANGE:
					case DBTIMEZONE:
					case DDL:
					case DEBUG:
					case DEC:
					case DECIMAL:
					case DECLARE:
					case DECOMPOSE:
					case DECREMENT:
					case DEFAULT:
					case DEFAULTS:
					case DEFERRED:
					case DEFINER:
					case DELETE:
					case DEPTH:
					case DESC:
					case DETERMINISTIC:
					case DIMENSION:
					case DISABLE:
					case DISASSOCIATE:
					case DISTINCT:
					case DOCUMENT:
					case DOUBLE:
					case DROP:
					case DSINTERVAL_UNCONSTRAINED:
					case EACH:
					case ELEMENT:
					case ELSE:
					case ELSIF:
					case EMPTY:
					case ENABLE:
					case ENCODING:
					case END:
					case ENTITYESCAPING:
					case ERRORS:
					case ESCAPE:
					case EXCEPT:
					case EVALNAME:
					case EXCEPTION:
					case EXCEPTION_INIT:
					case EXCEPTIONS:
					case EXCLUDE:
					case EXCLUSIVE:
					case EXECUTE:
					case EXISTS:
					case EXIT:
					case EXPLAIN:
					case EXTERNAL:
					case EXTRACT:
					case FAILURE:
					case FALSE:
					case FETCH:
					case FINAL:
					case FIRST:
					case FIRST_VALUE:
					case FLOAT:
					case FOLLOWING:
					case FOLLOWS:
					case FOR:
					case FORALL:
					case FORCE:
					case FROM:
					case FULL:
					case FUNCTION:
					case GOTO:
					case GRANT:
					case GROUP:
					case GROUPING:
					case HASH:
					case HAVING:
					case HIDE:
					case HOUR:
					case IF:
					case IGNORE:
					case IMMEDIATE:
					case IN:
					case INCLUDE:
					case INCLUDING:
					case INCREMENT:
					case INDENT:
					case INDEX:
					case INDEXED:
					case INDICATOR:
					case INDICES:
					case INFINITE:
					case INLINE:
					case INNER:
					case INOUT:
					case INSERT:
					case INSTANTIABLE:
					case INSTEAD:
					case INT:
					case INTEGER:
					case INTERSECT:
					case INTERVAL:
					case INTO:
					case INVALIDATE:
					case IS:
					case ISOLATION:
					case ITERATE:
					case JAVA:
					case JOIN:
					case KEEP:
					case LANGUAGE:
					case LAST:
					case LAST_VALUE:
					case LEADING:
					case LEFT:
					case LEVEL:
					case LIBRARY:
					case LIKE:
					case LIKE2:
					case LIKE4:
					case LIKEC:
					case LIMIT:
					case LOCAL:
					case LOCK:
					case LOCKED:
					case LOG:
					case LOGOFF:
					case LOGON:
					case LONG:
					case LOOP:
					case MAIN:
					case MAP:
					case MATCHED:
					case MAXVALUE:
					case MEASURES:
					case MEMBER:
					case MERGE:
					case MINUS:
					case MINUTE:
					case MINVALUE:
					case MLSLABEL:
					case MODE:
					case MODEL:
					case MODIFY:
					case MONTH:
					case MULTISET:
					case NAME:
					case NAN:
					case NATURAL:
					case NATURALN:
					case NAV:
					case NCHAR:
					case NCHAR_CS:
					case NCLOB:
					case NESTED:
					case NEW:
					case NO:
					case NOAUDIT:
					case NOCACHE:
					case NOCOPY:
					case NOCYCLE:
					case NOENTITYESCAPING:
					case NOMAXVALUE:
					case NOMINVALUE:
					case NONE:
					case NOORDER:
					case NOSCHEMACHECK:
					case NOT:
					case NOWAIT:
					case NULL:
					case NULLS:
					case NUMBER:
					case NUMERIC:
					case NVARCHAR2:
					case OBJECT:
					case OF:
					case OFF:
					case OID:
					case OLD:
					case ON:
					case ONLY:
					case OPEN:
					case OPTION:
					case OR:
					case ORADATA:
					case ORDER:
					case ORDINALITY:
					case OSERROR:
					case OUT:
					case OUTER:
					case OVER:
					case OVERRIDING:
					case PACKAGE:
					case PARALLEL_ENABLE:
					case PARAMETERS:
					case PARENT:
					case PARTITION:
					case PASSING:
					case PATH:
					case PIPELINED:
					case PIVOT:
					case PLAN:
					case PLS_INTEGER:
					case POSITIVE:
					case POSITIVEN:
					case PRAGMA:
					case PRECEDING:
					case PRECISION:
					case PRESENT:
					case PRIOR:
					case PROCEDURE:
					case RAISE:
					case RANGE:
					case RAW:
					case READ:
					case REAL:
					case RECORD:
					case REF:
					case REFERENCE:
					case REFERENCING:
					case REJECT:
					case RELIES_ON:
					case RENAME:
					case REPLACE:
					case RESPECT:
					case RESTRICT_REFERENCES:
					case RESULT:
					case RESULT_CACHE:
					case RETURN:
					case RETURNING:
					case REUSE:
					case REVERSE:
					case REVOKE:
					case RIGHT:
					case ROLLBACK:
					case ROLLUP:
					case ROW:
					case ROWID:
					case ROWS:
					case RULES:
					case SAMPLE:
					case SAVE:
					case SAVEPOINT:
					case SCHEMA:
					case SCHEMACHECK:
					case SCN:
					case SEARCH:
					case SECOND:
					case SEED:
					case SEGMENT:
					case SELECT:
					case SELF:
					case SEQUENCE:
					case SEQUENTIAL:
					case SERIALIZABLE:
					case SERIALLY_REUSABLE:
					case SERVERERROR:
					case SESSIONTIMEZONE:
					case SET:
					case SETS:
					case SETTINGS:
					case SHARE:
					case SHOW:
					case SHUTDOWN:
					case SIBLINGS:
					case SIGNTYPE:
					case SIMPLE_INTEGER:
					case SINGLE:
					case SIZE:
					case SKIP_:
					case SMALLINT:
					case SNAPSHOT:
					case SOME:
					case SPECIFICATION:
					case SQLDATA:
					case SQLERROR:
					case SQL_PERCENT_ROWCOUNT:
					case STANDALONE:
					case START:
					case STARTUP:
					case STATEMENT:
					case STATEMENT_ID:
					case STATIC:
					case STATISTICS:
					case STRING:
					case SUBMULTISET:
					case SUBPARTITION:
					case SUBSTITUTABLE:
					case SUBTYPE:
					case SUCCESS:
					case SUSPEND:
					case TABLE:
					case THE:
					case THEN:
					case TIME:
					case TIMESTAMP:
					case TIMESTAMP_LTZ_UNCONSTRAINED:
					case TIMESTAMP_TZ_UNCONSTRAINED:
					case TIMESTAMP_UNCONSTRAINED:
					case TIMEZONE_ABBR:
					case TIMEZONE_HOUR:
					case TIMEZONE_MINUTE:
					case TIMEZONE_REGION:
					case TO:
					case TO_CHAR:
					case TRAILING:
					case TRANSACTION:
					case TRANSLATE:
					case TREAT:
					case TRIGGER:
					case TRIM:
					case TRUE:
					case TRUNCATE:
					case TYPE:
					case UNBOUNDED:
					case UNDER:
					case UNION:
					case UNIQUE:
					case UNLIMITED:
					case UNPIVOT:
					case UNTIL:
					case UPDATE:
					case UPDATED:
					case UPSERT:
					case UROWID:
					case USE:
					case USING:
					case VALIDATE:
					case VALUE:
					case VALUES:
					case VARCHAR:
					case VARCHAR2:
					case VARIABLE:
					case VARRAY:
					case VARYING:
					case VERSION:
					case VERSIONS:
					case WAIT:
					case WARNING:
					case WELLFORMED:
					case WHEN:
					case WHENEVER:
					case WHERE:
					case WHILE:
					case WITH:
					case WITHIN:
					case WORK:
					case WRITE:
					case XML:
					case XMLAGG:
					case XMLATTRIBUTES:
					case XMLCAST:
					case XMLCOLATTVAL:
					case XMLELEMENT:
					case XMLEXISTS:
					case XMLFOREST:
					case XMLNAMESPACES:
					case XMLPARSE:
					case XMLPI:
					case XMLQUERY:
					case XMLROOT:
					case XMLSERIALIZE:
					case XMLTABLE:
					case YEAR:
					case YES:
					case YMINTERVAL_UNCONSTRAINED:
					case ZONE:
					case PREDICTION:
					case PREDICTION_BOUNDS:
					case PREDICTION_COST:
					case PREDICTION_DETAILS:
					case PREDICTION_PROBABILITY:
					case PREDICTION_SET:
					case CUME_DIST:
					case DENSE_RANK:
					case LISTAGG:
					case PERCENT_RANK:
					case PERCENTILE_CONT:
					case PERCENTILE_DISC:
					case RANK:
					case AVG:
					case CORR:
					case LAG:
					case LEAD:
					case MAX:
					case MEDIAN:
					case MIN:
					case NTILE:
					case RATIO_TO_REPORT:
					case ROW_NUMBER:
					case SUM:
					case VARIANCE:
					case REGR_:
					case STDDEV:
					case VAR_:
					case COVAR_:
					case DELIMITED_ID:
					case BINDVAR:
					case COLON:
					case INTRODUCER:
					case REGULAR_ID:
						{
						State = 2550; variable_name();
						}
						break;
					case UNSIGNED_INTEGER:
					case APPROXIMATE_NUM_LIT:
						{
						State = 2551; numeric();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Open_for_statementContext : ParserRuleContext {
		public ITerminalNode OPEN() { return GetToken(PlSqlParser.OPEN, 0); }
		public Variable_nameContext variable_name() {
			return GetRuleContext<Variable_nameContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Using_clauseContext using_clause() {
			return GetRuleContext<Using_clauseContext>(0);
		}
		public Open_for_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_open_for_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterOpen_for_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitOpen_for_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpen_for_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Open_for_statementContext open_for_statement() {
		Open_for_statementContext _localctx = new Open_for_statementContext(_ctx, State);
		EnterRule(_localctx, 298, RULE_open_for_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2558; Match(OPEN);
			State = 2559; variable_name();
			State = 2560; Match(FOR);
			State = 2563;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,254,_ctx) ) {
			case 1:
				{
				State = 2561; select_statement();
				}
				break;

			case 2:
				{
				State = 2562; expression();
				}
				break;
			}
			State = 2566;
			_la = _input.La(1);
			if (_la==USING) {
				{
				State = 2565; using_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Transaction_control_statementsContext : ParserRuleContext {
		public Set_transaction_commandContext set_transaction_command() {
			return GetRuleContext<Set_transaction_commandContext>(0);
		}
		public Set_constraint_commandContext set_constraint_command() {
			return GetRuleContext<Set_constraint_commandContext>(0);
		}
		public Commit_statementContext commit_statement() {
			return GetRuleContext<Commit_statementContext>(0);
		}
		public Rollback_statementContext rollback_statement() {
			return GetRuleContext<Rollback_statementContext>(0);
		}
		public Savepoint_statementContext savepoint_statement() {
			return GetRuleContext<Savepoint_statementContext>(0);
		}
		public Transaction_control_statementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transaction_control_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTransaction_control_statements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTransaction_control_statements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTransaction_control_statements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Transaction_control_statementsContext transaction_control_statements() {
		Transaction_control_statementsContext _localctx = new Transaction_control_statementsContext(_ctx, State);
		EnterRule(_localctx, 300, RULE_transaction_control_statements);
		try {
			State = 2573;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,256,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2568; set_transaction_command();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2569; set_constraint_command();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2570; commit_statement();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2571; rollback_statement();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2572; savepoint_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_transaction_commandContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(PlSqlParser.TRANSACTION, 0); }
		public ITerminalNode READ() { return GetToken(PlSqlParser.READ, 0); }
		public ITerminalNode ISOLATION() { return GetToken(PlSqlParser.ISOLATION, 0); }
		public ITerminalNode LEVEL() { return GetToken(PlSqlParser.LEVEL, 0); }
		public ITerminalNode USE() { return GetToken(PlSqlParser.USE, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(PlSqlParser.ROLLBACK, 0); }
		public ITerminalNode SEGMENT() { return GetToken(PlSqlParser.SEGMENT, 0); }
		public Rollback_segment_nameContext rollback_segment_name() {
			return GetRuleContext<Rollback_segment_nameContext>(0);
		}
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(PlSqlParser.ONLY, 0); }
		public ITerminalNode WRITE() { return GetToken(PlSqlParser.WRITE, 0); }
		public ITerminalNode SERIALIZABLE() { return GetToken(PlSqlParser.SERIALIZABLE, 0); }
		public ITerminalNode COMMITTED() { return GetToken(PlSqlParser.COMMITTED, 0); }
		public Set_transaction_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_transaction_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSet_transaction_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSet_transaction_command(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSet_transaction_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Set_transaction_commandContext set_transaction_command() {
		Set_transaction_commandContext _localctx = new Set_transaction_commandContext(_ctx, State);
		EnterRule(_localctx, 302, RULE_set_transaction_command);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2575; Match(SET);
			State = 2576; Match(TRANSACTION);
			State = 2590;
			switch (_input.La(1)) {
			case READ:
				{
				State = 2577; Match(READ);
				State = 2578;
				_la = _input.La(1);
				if ( !(_la==ONLY || _la==WRITE) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
				break;
			case ISOLATION:
				{
				State = 2579; Match(ISOLATION);
				State = 2580; Match(LEVEL);
				State = 2584;
				switch (_input.La(1)) {
				case SERIALIZABLE:
					{
					State = 2581; Match(SERIALIZABLE);
					}
					break;
				case READ:
					{
					State = 2582; Match(READ);
					State = 2583; Match(COMMITTED);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case USE:
				{
				State = 2586; Match(USE);
				State = 2587; Match(ROLLBACK);
				State = 2588; Match(SEGMENT);
				State = 2589; rollback_segment_name();
				}
				break;
			case NAME:
			case SAVE:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2594;
			_la = _input.La(1);
			if (_la==NAME) {
				{
				State = 2592; Match(NAME);
				State = 2593; quoted_string();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Set_constraint_commandContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public ITerminalNode CONSTRAINTS() { return GetToken(PlSqlParser.CONSTRAINTS, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(PlSqlParser.IMMEDIATE, 0); }
		public ITerminalNode DEFERRED() { return GetToken(PlSqlParser.DEFERRED, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Constraint_nameContext[] constraint_name() {
			return GetRuleContexts<Constraint_nameContext>();
		}
		public Constraint_nameContext constraint_name(int i) {
			return GetRuleContext<Constraint_nameContext>(i);
		}
		public Set_constraint_commandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_set_constraint_command; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSet_constraint_command(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSet_constraint_command(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSet_constraint_command(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Set_constraint_commandContext set_constraint_command() {
		Set_constraint_commandContext _localctx = new Set_constraint_commandContext(_ctx, State);
		EnterRule(_localctx, 304, RULE_set_constraint_command);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2596; Match(SET);
			State = 2597;
			_la = _input.La(1);
			if ( !(_la==CONSTRAINT || _la==CONSTRAINTS) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 2607;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,261,_ctx) ) {
			case 1:
				{
				State = 2598; Match(ALL);
				}
				break;

			case 2:
				{
				State = 2599; constraint_name();
				State = 2604;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2600; Match(COMMA);
					State = 2601; constraint_name();
					}
					}
					State = 2606;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			}
			State = 2609;
			_la = _input.La(1);
			if ( !(_la==DEFERRED || _la==IMMEDIATE) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Commit_statementContext : ParserRuleContext {
		public ITerminalNode COMMIT() { return GetToken(PlSqlParser.COMMIT, 0); }
		public ITerminalNode WORK() { return GetToken(PlSqlParser.WORK, 0); }
		public ITerminalNode COMMENT() { return GetToken(PlSqlParser.COMMENT, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public Write_clauseContext write_clause() {
			return GetRuleContext<Write_clauseContext>(0);
		}
		public ITerminalNode CORRUPT_XID() { return GetToken(PlSqlParser.CORRUPT_XID, 0); }
		public ITerminalNode CORRUPT_XID_ALL() { return GetToken(PlSqlParser.CORRUPT_XID_ALL, 0); }
		public Commit_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commit_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCommit_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCommit_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommit_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Commit_statementContext commit_statement() {
		Commit_statementContext _localctx = new Commit_statementContext(_ctx, State);
		EnterRule(_localctx, 306, RULE_commit_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2611; Match(COMMIT);
			State = 2613;
			_la = _input.La(1);
			if (_la==WORK) {
				{
				State = 2612; Match(WORK);
				}
			}

			State = 2628;
			switch (_input.La(1)) {
			case COMMENT:
				{
				State = 2615; Match(COMMENT);
				State = 2616; expression();
				}
				break;
			case FORCE:
				{
				State = 2617; Match(FORCE);
				State = 2626;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,264,_ctx) ) {
				case 1:
					{
					State = 2618; Match(CORRUPT_XID);
					State = 2619; expression();
					}
					break;

				case 2:
					{
					State = 2620; Match(CORRUPT_XID_ALL);
					}
					break;

				case 3:
					{
					State = 2621; expression();
					State = 2624;
					_la = _input.La(1);
					if (_la==COMMA) {
						{
						State = 2622; Match(COMMA);
						State = 2623; expression();
						}
					}

					}
					break;
				}
				}
				break;
			case SAVE:
			case WRITE:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2631;
			_la = _input.La(1);
			if (_la==WRITE) {
				{
				State = 2630; write_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Write_clauseContext : ParserRuleContext {
		public ITerminalNode WRITE() { return GetToken(PlSqlParser.WRITE, 0); }
		public ITerminalNode WAIT() { return GetToken(PlSqlParser.WAIT, 0); }
		public ITerminalNode NOWAIT() { return GetToken(PlSqlParser.NOWAIT, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(PlSqlParser.IMMEDIATE, 0); }
		public ITerminalNode BATCH() { return GetToken(PlSqlParser.BATCH, 0); }
		public Write_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_write_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterWrite_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitWrite_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWrite_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Write_clauseContext write_clause() {
		Write_clauseContext _localctx = new Write_clauseContext(_ctx, State);
		EnterRule(_localctx, 308, RULE_write_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2633; Match(WRITE);
			State = 2635;
			_la = _input.La(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 2634;
				_la = _input.La(1);
				if ( !(_la==NOWAIT || _la==WAIT) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
			}

			State = 2638;
			_la = _input.La(1);
			if (_la==BATCH || _la==IMMEDIATE) {
				{
				State = 2637;
				_la = _input.La(1);
				if ( !(_la==BATCH || _la==IMMEDIATE) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rollback_statementContext : ParserRuleContext {
		public ITerminalNode ROLLBACK() { return GetToken(PlSqlParser.ROLLBACK, 0); }
		public ITerminalNode WORK() { return GetToken(PlSqlParser.WORK, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public Savepoint_nameContext savepoint_name() {
			return GetRuleContext<Savepoint_nameContext>(0);
		}
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public ITerminalNode SAVEPOINT() { return GetToken(PlSqlParser.SAVEPOINT, 0); }
		public Rollback_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollback_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRollback_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRollback_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRollback_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Rollback_statementContext rollback_statement() {
		Rollback_statementContext _localctx = new Rollback_statementContext(_ctx, State);
		EnterRule(_localctx, 310, RULE_rollback_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2640; Match(ROLLBACK);
			State = 2642;
			_la = _input.La(1);
			if (_la==WORK) {
				{
				State = 2641; Match(WORK);
				}
			}

			State = 2651;
			switch (_input.La(1)) {
			case TO:
				{
				State = 2644; Match(TO);
				State = 2646;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,270,_ctx) ) {
				case 1:
					{
					State = 2645; Match(SAVEPOINT);
					}
					break;
				}
				State = 2648; savepoint_name();
				}
				break;
			case FORCE:
				{
				State = 2649; Match(FORCE);
				State = 2650; quoted_string();
				}
				break;
			case SAVE:
			case SEMICOLON:
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Savepoint_statementContext : ParserRuleContext {
		public ITerminalNode SAVEPOINT() { return GetToken(PlSqlParser.SAVEPOINT, 0); }
		public Savepoint_nameContext savepoint_name() {
			return GetRuleContext<Savepoint_nameContext>(0);
		}
		public Savepoint_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_savepoint_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSavepoint_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSavepoint_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSavepoint_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Savepoint_statementContext savepoint_statement() {
		Savepoint_statementContext _localctx = new Savepoint_statementContext(_ctx, State);
		EnterRule(_localctx, 312, RULE_savepoint_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2653; Match(SAVEPOINT);
			State = 2654; savepoint_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Explain_statementContext : ParserRuleContext {
		public ITerminalNode EXPLAIN() { return GetToken(PlSqlParser.EXPLAIN, 0); }
		public ITerminalNode PLAN() { return GetToken(PlSqlParser.PLAN, 0); }
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Update_statementContext update_statement() {
			return GetRuleContext<Update_statementContext>(0);
		}
		public Delete_statementContext delete_statement() {
			return GetRuleContext<Delete_statementContext>(0);
		}
		public Insert_statementContext insert_statement() {
			return GetRuleContext<Insert_statementContext>(0);
		}
		public Merge_statementContext merge_statement() {
			return GetRuleContext<Merge_statementContext>(0);
		}
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode STATEMENT_ID() { return GetToken(PlSqlParser.STATEMENT_ID, 0); }
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Explain_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_explain_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterExplain_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitExplain_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExplain_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Explain_statementContext explain_statement() {
		Explain_statementContext _localctx = new Explain_statementContext(_ctx, State);
		EnterRule(_localctx, 314, RULE_explain_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2656; Match(EXPLAIN);
			State = 2657; Match(PLAN);
			State = 2662;
			_la = _input.La(1);
			if (_la==SET) {
				{
				State = 2658; Match(SET);
				State = 2659; Match(STATEMENT_ID);
				State = 2660; Match(EQUALS_OP);
				State = 2661; quoted_string();
				}
			}

			State = 2666;
			_la = _input.La(1);
			if (_la==INTO) {
				{
				State = 2664; Match(INTO);
				State = 2665; tableview_name();
				}
			}

			State = 2668; Match(FOR);
			State = 2674;
			switch (_input.La(1)) {
			case SELECT:
			case WITH:
			case LEFT_PAREN:
				{
				State = 2669; select_statement();
				}
				break;
			case UPDATE:
				{
				State = 2670; update_statement();
				}
				break;
			case DELETE:
				{
				State = 2671; delete_statement();
				}
				break;
			case INSERT:
				{
				State = 2672; insert_statement();
				}
				break;
			case MERGE:
				{
				State = 2673; merge_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_statementContext : ParserRuleContext {
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public For_update_clauseContext[] for_update_clause() {
			return GetRuleContexts<For_update_clauseContext>();
		}
		public For_update_clauseContext for_update_clause(int i) {
			return GetRuleContext<For_update_clauseContext>(i);
		}
		public Order_by_clauseContext[] order_by_clause() {
			return GetRuleContexts<Order_by_clauseContext>();
		}
		public Order_by_clauseContext order_by_clause(int i) {
			return GetRuleContext<Order_by_clauseContext>(i);
		}
		public Select_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSelect_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSelect_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelect_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Select_statementContext select_statement() {
		Select_statementContext _localctx = new Select_statementContext(_ctx, State);
		EnterRule(_localctx, 316, RULE_select_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2676; subquery();
			State = 2681;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==FOR || _la==ORDER) {
				{
				State = 2679;
				switch (_input.La(1)) {
				case FOR:
					{
					State = 2677; for_update_clause();
					}
					break;
				case ORDER:
					{
					State = 2678; order_by_clause();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 2683;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_factoring_clauseContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public Factoring_elementContext[] factoring_element() {
			return GetRuleContexts<Factoring_elementContext>();
		}
		public Factoring_elementContext factoring_element(int i) {
			return GetRuleContext<Factoring_elementContext>(i);
		}
		public Subquery_factoring_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_factoring_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSubquery_factoring_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSubquery_factoring_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery_factoring_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_factoring_clauseContext subquery_factoring_clause() {
		Subquery_factoring_clauseContext _localctx = new Subquery_factoring_clauseContext(_ctx, State);
		EnterRule(_localctx, 318, RULE_subquery_factoring_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2684; Match(WITH);
			State = 2685; factoring_element();
			State = 2690;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2686; Match(COMMA);
				State = 2687; factoring_element();
				}
				}
				State = 2692;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Factoring_elementContext : ParserRuleContext {
		public Query_nameContext query_name() {
			return GetRuleContext<Query_nameContext>(0);
		}
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public Search_clauseContext search_clause() {
			return GetRuleContext<Search_clauseContext>(0);
		}
		public Cycle_clauseContext cycle_clause() {
			return GetRuleContext<Cycle_clauseContext>(0);
		}
		public Factoring_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_factoring_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFactoring_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFactoring_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFactoring_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Factoring_elementContext factoring_element() {
		Factoring_elementContext _localctx = new Factoring_elementContext(_ctx, State);
		EnterRule(_localctx, 320, RULE_factoring_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2693; query_name();
			State = 2705;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 2694; Match(LEFT_PAREN);
				State = 2695; column_name();
				State = 2700;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2696; Match(COMMA);
					State = 2697; column_name();
					}
					}
					State = 2702;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 2703; Match(RIGHT_PAREN);
				}
			}

			State = 2707; Match(AS);
			State = 2708; Match(LEFT_PAREN);
			State = 2709; subquery();
			State = 2711;
			_la = _input.La(1);
			if (_la==ORDER) {
				{
				State = 2710; order_by_clause();
				}
			}

			State = 2713; Match(RIGHT_PAREN);
			State = 2715;
			_la = _input.La(1);
			if (_la==SEARCH) {
				{
				State = 2714; search_clause();
				}
			}

			State = 2718;
			_la = _input.La(1);
			if (_la==CYCLE) {
				{
				State = 2717; cycle_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Search_clauseContext : ParserRuleContext {
		public ITerminalNode SEARCH() { return GetToken(PlSqlParser.SEARCH, 0); }
		public ITerminalNode[] FIRST() { return GetTokens(PlSqlParser.FIRST); }
		public ITerminalNode FIRST(int i) {
			return GetToken(PlSqlParser.FIRST, i);
		}
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode DEPTH() { return GetToken(PlSqlParser.DEPTH, 0); }
		public ITerminalNode BREADTH() { return GetToken(PlSqlParser.BREADTH, 0); }
		public ITerminalNode[] ASC() { return GetTokens(PlSqlParser.ASC); }
		public ITerminalNode ASC(int i) {
			return GetToken(PlSqlParser.ASC, i);
		}
		public ITerminalNode[] DESC() { return GetTokens(PlSqlParser.DESC); }
		public ITerminalNode DESC(int i) {
			return GetToken(PlSqlParser.DESC, i);
		}
		public ITerminalNode[] NULLS() { return GetTokens(PlSqlParser.NULLS); }
		public ITerminalNode NULLS(int i) {
			return GetToken(PlSqlParser.NULLS, i);
		}
		public ITerminalNode[] LAST() { return GetTokens(PlSqlParser.LAST); }
		public ITerminalNode LAST(int i) {
			return GetToken(PlSqlParser.LAST, i);
		}
		public Search_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_search_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSearch_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSearch_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSearch_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Search_clauseContext search_clause() {
		Search_clauseContext _localctx = new Search_clauseContext(_ctx, State);
		EnterRule(_localctx, 322, RULE_search_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2720; Match(SEARCH);
			State = 2721;
			_la = _input.La(1);
			if ( !(_la==BREADTH || _la==DEPTH) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 2722; Match(FIRST);
			State = 2723; Match(BY);
			State = 2724; column_name();
			State = 2726;
			_la = _input.La(1);
			if (_la==ASC) {
				{
				State = 2725; Match(ASC);
				}
			}

			State = 2729;
			_la = _input.La(1);
			if (_la==DESC) {
				{
				State = 2728; Match(DESC);
				}
			}

			State = 2733;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,285,_ctx) ) {
			case 1:
				{
				State = 2731; Match(NULLS);
				State = 2732; Match(FIRST);
				}
				break;
			}
			State = 2737;
			_la = _input.La(1);
			if (_la==NULLS) {
				{
				State = 2735; Match(NULLS);
				State = 2736; Match(LAST);
				}
			}

			State = 2757;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2739; Match(COMMA);
				State = 2740; column_name();
				State = 2742;
				_la = _input.La(1);
				if (_la==ASC) {
					{
					State = 2741; Match(ASC);
					}
				}

				State = 2745;
				_la = _input.La(1);
				if (_la==DESC) {
					{
					State = 2744; Match(DESC);
					}
				}

				State = 2749;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,289,_ctx) ) {
				case 1:
					{
					State = 2747; Match(NULLS);
					State = 2748; Match(FIRST);
					}
					break;
				}
				State = 2753;
				_la = _input.La(1);
				if (_la==NULLS) {
					{
					State = 2751; Match(NULLS);
					State = 2752; Match(LAST);
					}
				}

				}
				}
				State = 2759;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2760; Match(SET);
			State = 2761; column_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cycle_clauseContext : ParserRuleContext {
		public ITerminalNode CYCLE() { return GetToken(PlSqlParser.CYCLE, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public Cycle_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cycle_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCycle_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCycle_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCycle_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cycle_clauseContext cycle_clause() {
		Cycle_clauseContext _localctx = new Cycle_clauseContext(_ctx, State);
		EnterRule(_localctx, 324, RULE_cycle_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2763; Match(CYCLE);
			State = 2764; column_name();
			State = 2769;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2765; Match(COMMA);
				State = 2766; column_name();
				}
				}
				State = 2771;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2772; Match(SET);
			State = 2773; column_name();
			State = 2774; Match(TO);
			State = 2775; expression();
			State = 2776; Match(DEFAULT);
			State = 2777; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryContext : ParserRuleContext {
		public Subquery_basic_elementsContext subquery_basic_elements() {
			return GetRuleContext<Subquery_basic_elementsContext>(0);
		}
		public Subquery_operation_partContext[] subquery_operation_part() {
			return GetRuleContexts<Subquery_operation_partContext>();
		}
		public Subquery_operation_partContext subquery_operation_part(int i) {
			return GetRuleContext<Subquery_operation_partContext>(i);
		}
		public SubqueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSubquery(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSubquery(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryContext subquery() {
		SubqueryContext _localctx = new SubqueryContext(_ctx, State);
		EnterRule(_localctx, 326, RULE_subquery);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2779; subquery_basic_elements();
			State = 2783;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==INTERSECT || _la==MINUS || _la==UNION) {
				{
				{
				State = 2780; subquery_operation_part();
				}
				}
				State = 2785;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_operation_partContext : ParserRuleContext {
		public Subquery_basic_elementsContext subquery_basic_elements() {
			return GetRuleContext<Subquery_basic_elementsContext>(0);
		}
		public ITerminalNode UNION() { return GetToken(PlSqlParser.UNION, 0); }
		public ITerminalNode INTERSECT() { return GetToken(PlSqlParser.INTERSECT, 0); }
		public ITerminalNode MINUS() { return GetToken(PlSqlParser.MINUS, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Subquery_operation_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_operation_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSubquery_operation_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSubquery_operation_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery_operation_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_operation_partContext subquery_operation_part() {
		Subquery_operation_partContext _localctx = new Subquery_operation_partContext(_ctx, State);
		EnterRule(_localctx, 328, RULE_subquery_operation_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2792;
			switch (_input.La(1)) {
			case UNION:
				{
				State = 2786; Match(UNION);
				State = 2788;
				_la = _input.La(1);
				if (_la==ALL) {
					{
					State = 2787; Match(ALL);
					}
				}

				}
				break;
			case INTERSECT:
				{
				State = 2790; Match(INTERSECT);
				}
				break;
			case MINUS:
				{
				State = 2791; Match(MINUS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2794; subquery_basic_elements();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_basic_elementsContext : ParserRuleContext {
		public Query_blockContext query_block() {
			return GetRuleContext<Query_blockContext>(0);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Subquery_basic_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_basic_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSubquery_basic_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSubquery_basic_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery_basic_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_basic_elementsContext subquery_basic_elements() {
		Subquery_basic_elementsContext _localctx = new Subquery_basic_elementsContext(_ctx, State);
		EnterRule(_localctx, 330, RULE_subquery_basic_elements);
		try {
			State = 2801;
			switch (_input.La(1)) {
			case SELECT:
			case WITH:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2796; query_block();
				}
				break;
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2797; Match(LEFT_PAREN);
				State = 2798; subquery();
				State = 2799; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Query_blockContext : ParserRuleContext {
		public ITerminalNode SELECT() { return GetToken(PlSqlParser.SELECT, 0); }
		public From_clauseContext from_clause() {
			return GetRuleContext<From_clauseContext>(0);
		}
		public Selected_elementContext[] selected_element() {
			return GetRuleContexts<Selected_elementContext>();
		}
		public Selected_elementContext selected_element(int i) {
			return GetRuleContext<Selected_elementContext>(i);
		}
		public Subquery_factoring_clauseContext subquery_factoring_clause() {
			return GetRuleContext<Subquery_factoring_clauseContext>(0);
		}
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Hierarchical_query_clauseContext hierarchical_query_clause() {
			return GetRuleContext<Hierarchical_query_clauseContext>(0);
		}
		public Group_by_clauseContext group_by_clause() {
			return GetRuleContext<Group_by_clauseContext>(0);
		}
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public Model_clauseContext model_clause() {
			return GetRuleContext<Model_clauseContext>(0);
		}
		public ITerminalNode DISTINCT() { return GetToken(PlSqlParser.DISTINCT, 0); }
		public ITerminalNode UNIQUE() { return GetToken(PlSqlParser.UNIQUE, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Query_blockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_query_block; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterQuery_block(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitQuery_block(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuery_block(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Query_blockContext query_block() {
		Query_blockContext _localctx = new Query_blockContext(_ctx, State);
		EnterRule(_localctx, 332, RULE_query_block);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2804;
			_la = _input.La(1);
			if (_la==WITH) {
				{
				State = 2803; subquery_factoring_clause();
				}
			}

			State = 2806; Match(SELECT);
			State = 2808;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,298,_ctx) ) {
			case 1:
				{
				State = 2807;
				_la = _input.La(1);
				if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
				break;
			}
			State = 2819;
			switch (_input.La(1)) {
			case ASTERISK:
				{
				State = 2810; Match(ASTERISK);
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MOD:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TO_NUMBER:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 2811; selected_element();
				State = 2816;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 2812; Match(COMMA);
					State = 2813; selected_element();
					}
					}
					State = 2818;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2822;
			_la = _input.La(1);
			if (_la==BULK || _la==INTO) {
				{
				State = 2821; into_clause();
				}
			}

			State = 2824; from_clause();
			State = 2826;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,302,_ctx) ) {
			case 1:
				{
				State = 2825; where_clause();
				}
				break;
			}
			State = 2829;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,303,_ctx) ) {
			case 1:
				{
				State = 2828; hierarchical_query_clause();
				}
				break;
			}
			State = 2832;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,304,_ctx) ) {
			case 1:
				{
				State = 2831; group_by_clause();
				}
				break;
			}
			State = 2835;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,305,_ctx) ) {
			case 1:
				{
				State = 2834; order_by_clause();
				}
				break;
			}
			State = 2838;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,306,_ctx) ) {
			case 1:
				{
				State = 2837; model_clause();
				}
				break;
			}
			State = 2841;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,307,_ctx) ) {
			case 1:
				{
				State = 2840; Match(SEMICOLON);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Selected_elementContext : ParserRuleContext {
		public Select_list_elementsContext select_list_elements() {
			return GetRuleContext<Select_list_elementsContext>(0);
		}
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Selected_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selected_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSelected_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSelected_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelected_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Selected_elementContext selected_element() {
		Selected_elementContext _localctx = new Selected_elementContext(_ctx, State);
		EnterRule(_localctx, 334, RULE_selected_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2843; select_list_elements();
			State = 2845;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,308,_ctx) ) {
			case 1:
				{
				State = 2844; column_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class From_clauseContext : ParserRuleContext {
		public ITerminalNode FROM() { return GetToken(PlSqlParser.FROM, 0); }
		public Table_ref_listContext table_ref_list() {
			return GetRuleContext<Table_ref_listContext>(0);
		}
		public From_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_from_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFrom_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFrom_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFrom_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public From_clauseContext from_clause() {
		From_clauseContext _localctx = new From_clauseContext(_ctx, State);
		EnterRule(_localctx, 336, RULE_from_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2847; Match(FROM);
			State = 2848; table_ref_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Select_list_elementsContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Select_list_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_select_list_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSelect_list_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSelect_list_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelect_list_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Select_list_elementsContext select_list_elements() {
		Select_list_elementsContext _localctx = new Select_list_elementsContext(_ctx, State);
		EnterRule(_localctx, 338, RULE_select_list_elements);
		try {
			State = 2855;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,309,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2850; tableview_name();
				State = 2851; Match(PERIOD);
				State = 2852; Match(ASTERISK);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2854; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_ref_listContext : ParserRuleContext {
		public Table_refContext[] table_ref() {
			return GetRuleContexts<Table_refContext>();
		}
		public Table_refContext table_ref(int i) {
			return GetRuleContext<Table_refContext>(i);
		}
		public Table_ref_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTable_ref_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTable_ref_list(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_ref_listContext table_ref_list() {
		Table_ref_listContext _localctx = new Table_ref_listContext(_ctx, State);
		EnterRule(_localctx, 340, RULE_table_ref_list);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2857; table_ref();
			State = 2862;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,310,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 2858; Match(COMMA);
					State = 2859; table_ref();
					}
					} 
				}
				State = 2864;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,310,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_refContext : ParserRuleContext {
		public Table_ref_auxContext table_ref_aux() {
			return GetRuleContext<Table_ref_auxContext>(0);
		}
		public Join_clauseContext[] join_clause() {
			return GetRuleContexts<Join_clauseContext>();
		}
		public Join_clauseContext join_clause(int i) {
			return GetRuleContext<Join_clauseContext>(i);
		}
		public Pivot_clauseContext pivot_clause() {
			return GetRuleContext<Pivot_clauseContext>(0);
		}
		public Unpivot_clauseContext unpivot_clause() {
			return GetRuleContext<Unpivot_clauseContext>(0);
		}
		public Table_refContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTable_ref(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTable_ref(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_refContext table_ref() {
		Table_refContext _localctx = new Table_refContext(_ctx, State);
		EnterRule(_localctx, 342, RULE_table_ref);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2865; table_ref_aux();
			State = 2869;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,311,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 2866; join_clause();
					}
					} 
				}
				State = 2871;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,311,_ctx);
			}
			State = 2874;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,312,_ctx) ) {
			case 1:
				{
				State = 2872; pivot_clause();
				}
				break;

			case 2:
				{
				State = 2873; unpivot_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_ref_auxContext : ParserRuleContext {
		public Dml_table_expression_clauseContext dml_table_expression_clause() {
			return GetRuleContext<Dml_table_expression_clauseContext>(0);
		}
		public Table_refContext table_ref() {
			return GetRuleContext<Table_refContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(PlSqlParser.ONLY, 0); }
		public Xml_tableContext xml_table() {
			return GetRuleContext<Xml_tableContext>(0);
		}
		public Flashback_query_clauseContext[] flashback_query_clause() {
			return GetRuleContexts<Flashback_query_clauseContext>();
		}
		public Flashback_query_clauseContext flashback_query_clause(int i) {
			return GetRuleContext<Flashback_query_clauseContext>(i);
		}
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Pivot_clauseContext pivot_clause() {
			return GetRuleContext<Pivot_clauseContext>(0);
		}
		public Unpivot_clauseContext unpivot_clause() {
			return GetRuleContext<Unpivot_clauseContext>(0);
		}
		public Subquery_operation_partContext[] subquery_operation_part() {
			return GetRuleContexts<Subquery_operation_partContext>();
		}
		public Subquery_operation_partContext subquery_operation_part(int i) {
			return GetRuleContext<Subquery_operation_partContext>(i);
		}
		public Table_ref_auxContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_ref_aux; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTable_ref_aux(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTable_ref_aux(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_ref_aux(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_ref_auxContext table_ref_aux() {
		Table_ref_auxContext _localctx = new Table_ref_auxContext(_ctx, State);
		EnterRule(_localctx, 344, RULE_table_ref_aux);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2905;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,317,_ctx) ) {
			case 1:
				{
				State = 2876; dml_table_expression_clause();
				State = 2879;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,313,_ctx) ) {
				case 1:
					{
					State = 2877; pivot_clause();
					}
					break;

				case 2:
					{
					State = 2878; unpivot_clause();
					}
					break;
				}
				}
				break;

			case 2:
				{
				State = 2881; Match(LEFT_PAREN);
				State = 2882; table_ref();
				State = 2886;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==INTERSECT || _la==MINUS || _la==UNION) {
					{
					{
					State = 2883; subquery_operation_part();
					}
					}
					State = 2888;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 2889; Match(RIGHT_PAREN);
				State = 2892;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,315,_ctx) ) {
				case 1:
					{
					State = 2890; pivot_clause();
					}
					break;

				case 2:
					{
					State = 2891; unpivot_clause();
					}
					break;
				}
				}
				break;

			case 3:
				{
				State = 2894; Match(ONLY);
				State = 2895; Match(LEFT_PAREN);
				State = 2896; dml_table_expression_clause();
				State = 2897; Match(RIGHT_PAREN);
				}
				break;

			case 4:
				{
				State = 2899; dml_table_expression_clause();
				State = 2902;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,316,_ctx) ) {
				case 1:
					{
					State = 2900; pivot_clause();
					}
					break;

				case 2:
					{
					State = 2901; unpivot_clause();
					}
					break;
				}
				}
				break;

			case 5:
				{
				State = 2904; xml_table();
				}
				break;
			}
			State = 2910;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,318,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 2907; flashback_query_clause();
					}
					} 
				}
				State = 2912;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,318,_ctx);
			}
			State = 2914;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,319,_ctx) ) {
			case 1:
				{
				State = 2913; table_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Join_clauseContext : ParserRuleContext {
		public ITerminalNode JOIN() { return GetToken(PlSqlParser.JOIN, 0); }
		public Table_ref_auxContext table_ref_aux() {
			return GetRuleContext<Table_ref_auxContext>(0);
		}
		public Query_partition_clauseContext[] query_partition_clause() {
			return GetRuleContexts<Query_partition_clauseContext>();
		}
		public Query_partition_clauseContext query_partition_clause(int i) {
			return GetRuleContext<Query_partition_clauseContext>(i);
		}
		public ITerminalNode INNER() { return GetToken(PlSqlParser.INNER, 0); }
		public Outer_join_typeContext outer_join_type() {
			return GetRuleContext<Outer_join_typeContext>(0);
		}
		public Join_on_partContext[] join_on_part() {
			return GetRuleContexts<Join_on_partContext>();
		}
		public Join_on_partContext join_on_part(int i) {
			return GetRuleContext<Join_on_partContext>(i);
		}
		public Join_using_partContext[] join_using_part() {
			return GetRuleContexts<Join_using_partContext>();
		}
		public Join_using_partContext join_using_part(int i) {
			return GetRuleContext<Join_using_partContext>(i);
		}
		public ITerminalNode CROSS() { return GetToken(PlSqlParser.CROSS, 0); }
		public ITerminalNode NATURAL() { return GetToken(PlSqlParser.NATURAL, 0); }
		public Join_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_join_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterJoin_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitJoin_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJoin_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Join_clauseContext join_clause() {
		Join_clauseContext _localctx = new Join_clauseContext(_ctx, State);
		EnterRule(_localctx, 346, RULE_join_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2917;
			_la = _input.La(1);
			if (_la==PARTITION) {
				{
				State = 2916; query_partition_clause();
				}
			}

			State = 2920;
			_la = _input.La(1);
			if (_la==CROSS || _la==NATURAL) {
				{
				State = 2919;
				_la = _input.La(1);
				if ( !(_la==CROSS || _la==NATURAL) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
			}

			State = 2924;
			switch (_input.La(1)) {
			case INNER:
				{
				State = 2922; Match(INNER);
				}
				break;
			case FULL:
			case LEFT:
			case RIGHT:
				{
				State = 2923; outer_join_type();
				}
				break;
			case JOIN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2926; Match(JOIN);
			State = 2927; table_ref_aux();
			State = 2929;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,323,_ctx) ) {
			case 1:
				{
				State = 2928; query_partition_clause();
				}
				break;
			}
			State = 2935;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,325,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					State = 2933;
					switch (_input.La(1)) {
					case ON:
						{
						State = 2931; join_on_part();
						}
						break;
					case USING:
						{
						State = 2932; join_using_part();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 2937;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,325,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Join_on_partContext : ParserRuleContext {
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Join_on_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_join_on_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterJoin_on_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitJoin_on_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJoin_on_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Join_on_partContext join_on_part() {
		Join_on_partContext _localctx = new Join_on_partContext(_ctx, State);
		EnterRule(_localctx, 348, RULE_join_on_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2938; Match(ON);
			State = 2939; condition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Join_using_partContext : ParserRuleContext {
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Join_using_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_join_using_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterJoin_using_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitJoin_using_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJoin_using_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Join_using_partContext join_using_part() {
		Join_using_partContext _localctx = new Join_using_partContext(_ctx, State);
		EnterRule(_localctx, 350, RULE_join_using_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2941; Match(USING);
			State = 2942; Match(LEFT_PAREN);
			State = 2943; column_name();
			State = 2948;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2944; Match(COMMA);
				State = 2945; column_name();
				}
				}
				State = 2950;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2951; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Outer_join_typeContext : ParserRuleContext {
		public ITerminalNode FULL() { return GetToken(PlSqlParser.FULL, 0); }
		public ITerminalNode LEFT() { return GetToken(PlSqlParser.LEFT, 0); }
		public ITerminalNode RIGHT() { return GetToken(PlSqlParser.RIGHT, 0); }
		public ITerminalNode OUTER() { return GetToken(PlSqlParser.OUTER, 0); }
		public Outer_join_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outer_join_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterOuter_join_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitOuter_join_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuter_join_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Outer_join_typeContext outer_join_type() {
		Outer_join_typeContext _localctx = new Outer_join_typeContext(_ctx, State);
		EnterRule(_localctx, 352, RULE_outer_join_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2953;
			_la = _input.La(1);
			if ( !(_la==FULL || _la==LEFT || _la==RIGHT) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 2955;
			_la = _input.La(1);
			if (_la==OUTER) {
				{
				State = 2954; Match(OUTER);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Query_partition_clauseContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Query_partition_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_query_partition_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterQuery_partition_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitQuery_partition_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuery_partition_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Query_partition_clauseContext query_partition_clause() {
		Query_partition_clauseContext _localctx = new Query_partition_clauseContext(_ctx, State);
		EnterRule(_localctx, 354, RULE_query_partition_clause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2957; Match(PARTITION);
			State = 2958; Match(BY);
			State = 2972;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,329,_ctx) ) {
			case 1:
				{
				State = 2959; Match(LEFT_PAREN);
				State = 2960; subquery();
				State = 2961; Match(RIGHT_PAREN);
				}
				break;

			case 2:
				{
				State = 2963; expression_list();
				}
				break;

			case 3:
				{
				State = 2964; expression();
				State = 2969;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,328,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 2965; Match(COMMA);
						State = 2966; expression();
						}
						} 
					}
					State = 2971;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,328,_ctx);
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Flashback_query_clauseContext : ParserRuleContext {
		public ITerminalNode VERSIONS() { return GetToken(PlSqlParser.VERSIONS, 0); }
		public ITerminalNode BETWEEN() { return GetToken(PlSqlParser.BETWEEN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode SCN() { return GetToken(PlSqlParser.SCN, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(PlSqlParser.TIMESTAMP, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(PlSqlParser.SNAPSHOT, 0); }
		public Flashback_query_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_flashback_query_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFlashback_query_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFlashback_query_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFlashback_query_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Flashback_query_clauseContext flashback_query_clause() {
		Flashback_query_clauseContext _localctx = new Flashback_query_clauseContext(_ctx, State);
		EnterRule(_localctx, 356, RULE_flashback_query_clause);
		int _la;
		try {
			State = 2982;
			switch (_input.La(1)) {
			case VERSIONS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2974; Match(VERSIONS);
				State = 2975; Match(BETWEEN);
				State = 2976;
				_la = _input.La(1);
				if ( !(_la==SCN || _la==TIMESTAMP) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 2977; expression();
				}
				break;
			case AS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2978; Match(AS);
				State = 2979; Match(OF);
				State = 2980;
				_la = _input.La(1);
				if ( !(((((_la - 344)) & ~0x3f) == 0 && ((1L << (_la - 344)) & ((1L << (SCN - 344)) | (1L << (SNAPSHOT - 344)) | (1L << (TIMESTAMP - 344)))) != 0)) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 2981; expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_clauseContext : ParserRuleContext {
		public ITerminalNode PIVOT() { return GetToken(PlSqlParser.PIVOT, 0); }
		public Pivot_elementContext[] pivot_element() {
			return GetRuleContexts<Pivot_elementContext>();
		}
		public Pivot_elementContext pivot_element(int i) {
			return GetRuleContext<Pivot_elementContext>(i);
		}
		public Pivot_for_clauseContext pivot_for_clause() {
			return GetRuleContext<Pivot_for_clauseContext>(0);
		}
		public Pivot_in_clauseContext pivot_in_clause() {
			return GetRuleContext<Pivot_in_clauseContext>(0);
		}
		public ITerminalNode XML() { return GetToken(PlSqlParser.XML, 0); }
		public Pivot_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPivot_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPivot_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_clauseContext pivot_clause() {
		Pivot_clauseContext _localctx = new Pivot_clauseContext(_ctx, State);
		EnterRule(_localctx, 358, RULE_pivot_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2984; Match(PIVOT);
			State = 2986;
			_la = _input.La(1);
			if (_la==XML) {
				{
				State = 2985; Match(XML);
				}
			}

			State = 2988; Match(LEFT_PAREN);
			State = 2989; pivot_element();
			State = 2994;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 2990; Match(COMMA);
				State = 2991; pivot_element();
				}
				}
				State = 2996;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 2997; pivot_for_clause();
			State = 2998; pivot_in_clause();
			State = 2999; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_elementContext : ParserRuleContext {
		public Aggregate_function_nameContext aggregate_function_name() {
			return GetRuleContext<Aggregate_function_nameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Pivot_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPivot_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPivot_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_elementContext pivot_element() {
		Pivot_elementContext _localctx = new Pivot_elementContext(_ctx, State);
		EnterRule(_localctx, 360, RULE_pivot_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3001; aggregate_function_name();
			State = 3002; Match(LEFT_PAREN);
			State = 3003; expression();
			State = 3004; Match(RIGHT_PAREN);
			State = 3006;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,333,_ctx) ) {
			case 1:
				{
				State = 3005; column_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_for_clauseContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Pivot_for_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_for_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPivot_for_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPivot_for_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_for_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_for_clauseContext pivot_for_clause() {
		Pivot_for_clauseContext _localctx = new Pivot_for_clauseContext(_ctx, State);
		EnterRule(_localctx, 362, RULE_pivot_for_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3008; Match(FOR);
			State = 3021;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 3009; column_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 3010; Match(LEFT_PAREN);
				State = 3011; column_name();
				State = 3016;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3012; Match(COMMA);
					State = 3013; column_name();
					}
					}
					State = 3018;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 3019; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_in_clauseContext : ParserRuleContext {
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ITerminalNode[] ANY() { return GetTokens(PlSqlParser.ANY); }
		public ITerminalNode ANY(int i) {
			return GetToken(PlSqlParser.ANY, i);
		}
		public Pivot_in_clause_elementContext[] pivot_in_clause_element() {
			return GetRuleContexts<Pivot_in_clause_elementContext>();
		}
		public Pivot_in_clause_elementContext pivot_in_clause_element(int i) {
			return GetRuleContext<Pivot_in_clause_elementContext>(i);
		}
		public Pivot_in_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_in_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPivot_in_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPivot_in_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_in_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_in_clauseContext pivot_in_clause() {
		Pivot_in_clauseContext _localctx = new Pivot_in_clauseContext(_ctx, State);
		EnterRule(_localctx, 364, RULE_pivot_in_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3023; Match(IN);
			State = 3024; Match(LEFT_PAREN);
			State = 3042;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,338,_ctx) ) {
			case 1:
				{
				State = 3025; subquery();
				}
				break;

			case 2:
				{
				State = 3026; Match(ANY);
				State = 3031;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3027; Match(COMMA);
					State = 3028; Match(ANY);
					}
					}
					State = 3033;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 3:
				{
				State = 3034; pivot_in_clause_element();
				State = 3039;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3035; Match(COMMA);
					State = 3036; pivot_in_clause_element();
					}
					}
					State = 3041;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			}
			State = 3044; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_in_clause_elementContext : ParserRuleContext {
		public Pivot_in_clause_elementsContext pivot_in_clause_elements() {
			return GetRuleContext<Pivot_in_clause_elementsContext>(0);
		}
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Pivot_in_clause_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_in_clause_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPivot_in_clause_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPivot_in_clause_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_in_clause_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_in_clause_elementContext pivot_in_clause_element() {
		Pivot_in_clause_elementContext _localctx = new Pivot_in_clause_elementContext(_ctx, State);
		EnterRule(_localctx, 366, RULE_pivot_in_clause_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3046; pivot_in_clause_elements();
			State = 3048;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3047; column_alias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Pivot_in_clause_elementsContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public Pivot_in_clause_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pivot_in_clause_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPivot_in_clause_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPivot_in_clause_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPivot_in_clause_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Pivot_in_clause_elementsContext pivot_in_clause_elements() {
		Pivot_in_clause_elementsContext _localctx = new Pivot_in_clause_elementsContext(_ctx, State);
		EnterRule(_localctx, 368, RULE_pivot_in_clause_elements);
		try {
			State = 3052;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,340,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3050; expression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3051; expression_list();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unpivot_clauseContext : ParserRuleContext {
		public ITerminalNode UNPIVOT() { return GetToken(PlSqlParser.UNPIVOT, 0); }
		public Pivot_for_clauseContext pivot_for_clause() {
			return GetRuleContext<Pivot_for_clauseContext>(0);
		}
		public Unpivot_in_clauseContext unpivot_in_clause() {
			return GetRuleContext<Unpivot_in_clauseContext>(0);
		}
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode NULLS() { return GetToken(PlSqlParser.NULLS, 0); }
		public ITerminalNode INCLUDE() { return GetToken(PlSqlParser.INCLUDE, 0); }
		public ITerminalNode EXCLUDE() { return GetToken(PlSqlParser.EXCLUDE, 0); }
		public Unpivot_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivot_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterUnpivot_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitUnpivot_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnpivot_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unpivot_clauseContext unpivot_clause() {
		Unpivot_clauseContext _localctx = new Unpivot_clauseContext(_ctx, State);
		EnterRule(_localctx, 370, RULE_unpivot_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3054; Match(UNPIVOT);
			State = 3057;
			_la = _input.La(1);
			if (_la==EXCLUDE || _la==INCLUDE) {
				{
				State = 3055;
				_la = _input.La(1);
				if ( !(_la==EXCLUDE || _la==INCLUDE) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 3056; Match(NULLS);
				}
			}

			State = 3059; Match(LEFT_PAREN);
			State = 3072;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 3060; column_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 3061; Match(LEFT_PAREN);
				State = 3062; column_name();
				State = 3067;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3063; Match(COMMA);
					State = 3064; column_name();
					}
					}
					State = 3069;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 3070; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3074; pivot_for_clause();
			State = 3075; unpivot_in_clause();
			State = 3076; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unpivot_in_clauseContext : ParserRuleContext {
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public Unpivot_in_elementsContext[] unpivot_in_elements() {
			return GetRuleContexts<Unpivot_in_elementsContext>();
		}
		public Unpivot_in_elementsContext unpivot_in_elements(int i) {
			return GetRuleContext<Unpivot_in_elementsContext>(i);
		}
		public Unpivot_in_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivot_in_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterUnpivot_in_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitUnpivot_in_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnpivot_in_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unpivot_in_clauseContext unpivot_in_clause() {
		Unpivot_in_clauseContext _localctx = new Unpivot_in_clauseContext(_ctx, State);
		EnterRule(_localctx, 372, RULE_unpivot_in_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3078; Match(IN);
			State = 3079; Match(LEFT_PAREN);
			State = 3080; unpivot_in_elements();
			State = 3085;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3081; Match(COMMA);
				State = 3082; unpivot_in_elements();
				}
				}
				State = 3087;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3088; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unpivot_in_elementsContext : ParserRuleContext {
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ConstantContext[] constant() {
			return GetRuleContexts<ConstantContext>();
		}
		public ConstantContext constant(int i) {
			return GetRuleContext<ConstantContext>(i);
		}
		public Unpivot_in_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unpivot_in_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterUnpivot_in_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitUnpivot_in_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnpivot_in_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unpivot_in_elementsContext unpivot_in_elements() {
		Unpivot_in_elementsContext _localctx = new Unpivot_in_elementsContext(_ctx, State);
		EnterRule(_localctx, 374, RULE_unpivot_in_elements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3102;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 3090; column_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 3091; Match(LEFT_PAREN);
				State = 3092; column_name();
				State = 3097;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3093; Match(COMMA);
					State = 3094; column_name();
					}
					}
					State = 3099;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 3100; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3119;
			_la = _input.La(1);
			if (_la==AS) {
				{
				State = 3104; Match(AS);
				State = 3117;
				switch (_input.La(1)) {
				case DATE:
				case DBTIMEZONE:
				case DEFAULT:
				case FALSE:
				case INTERVAL:
				case MAXVALUE:
				case MINVALUE:
				case NULL:
				case SESSIONTIMEZONE:
				case TIMESTAMP:
				case TRUE:
				case NATIONAL_CHAR_STRING_LIT:
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
				case CHAR_STRING:
					{
					State = 3105; constant();
					}
					break;
				case LEFT_PAREN:
					{
					State = 3106; Match(LEFT_PAREN);
					State = 3107; constant();
					State = 3112;
					_errHandler.Sync(this);
					_la = _input.La(1);
					while (_la==COMMA) {
						{
						{
						State = 3108; Match(COMMA);
						State = 3109; constant();
						}
						}
						State = 3114;
						_errHandler.Sync(this);
						_la = _input.La(1);
					}
					State = 3115; Match(RIGHT_PAREN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Hierarchical_query_clauseContext : ParserRuleContext {
		public ITerminalNode CONNECT() { return GetToken(PlSqlParser.CONNECT, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode NOCYCLE() { return GetToken(PlSqlParser.NOCYCLE, 0); }
		public Start_partContext start_part() {
			return GetRuleContext<Start_partContext>(0);
		}
		public Hierarchical_query_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hierarchical_query_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterHierarchical_query_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitHierarchical_query_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHierarchical_query_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Hierarchical_query_clauseContext hierarchical_query_clause() {
		Hierarchical_query_clauseContext _localctx = new Hierarchical_query_clauseContext(_ctx, State);
		EnterRule(_localctx, 376, RULE_hierarchical_query_clause);
		try {
			State = 3138;
			switch (_input.La(1)) {
			case CONNECT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3121; Match(CONNECT);
				State = 3122; Match(BY);
				State = 3124;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,350,_ctx) ) {
				case 1:
					{
					State = 3123; Match(NOCYCLE);
					}
					break;
				}
				State = 3126; condition();
				State = 3128;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,351,_ctx) ) {
				case 1:
					{
					State = 3127; start_part();
					}
					break;
				}
				}
				break;
			case START:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3130; start_part();
				State = 3131; Match(CONNECT);
				State = 3132; Match(BY);
				State = 3134;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,352,_ctx) ) {
				case 1:
					{
					State = 3133; Match(NOCYCLE);
					}
					break;
				}
				State = 3136; condition();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Start_partContext : ParserRuleContext {
		public ITerminalNode START() { return GetToken(PlSqlParser.START, 0); }
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Start_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_start_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterStart_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitStart_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStart_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Start_partContext start_part() {
		Start_partContext _localctx = new Start_partContext(_ctx, State);
		EnterRule(_localctx, 378, RULE_start_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3140; Match(START);
			State = 3141; Match(WITH);
			State = 3142; condition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Group_by_clauseContext : ParserRuleContext {
		public ITerminalNode GROUP() { return GetToken(PlSqlParser.GROUP, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Group_by_elementsContext[] group_by_elements() {
			return GetRuleContexts<Group_by_elementsContext>();
		}
		public Group_by_elementsContext group_by_elements(int i) {
			return GetRuleContext<Group_by_elementsContext>(i);
		}
		public Having_clauseContext having_clause() {
			return GetRuleContext<Having_clauseContext>(0);
		}
		public Group_by_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_group_by_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterGroup_by_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitGroup_by_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroup_by_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Group_by_clauseContext group_by_clause() {
		Group_by_clauseContext _localctx = new Group_by_clauseContext(_ctx, State);
		EnterRule(_localctx, 380, RULE_group_by_clause);
		try {
			int _alt;
			State = 3170;
			switch (_input.La(1)) {
			case GROUP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3144; Match(GROUP);
				State = 3145; Match(BY);
				State = 3146; group_by_elements();
				State = 3151;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,354,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 3147; Match(COMMA);
						State = 3148; group_by_elements();
						}
						} 
					}
					State = 3153;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,354,_ctx);
				}
				State = 3155;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,355,_ctx) ) {
				case 1:
					{
					State = 3154; having_clause();
					}
					break;
				}
				}
				break;
			case HAVING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3157; having_clause();
				State = 3168;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,357,_ctx) ) {
				case 1:
					{
					State = 3158; Match(GROUP);
					State = 3159; Match(BY);
					State = 3160; group_by_elements();
					State = 3165;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,356,_ctx);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
						if ( _alt==1 ) {
							{
							{
							State = 3161; Match(COMMA);
							State = 3162; group_by_elements();
							}
							} 
						}
						State = 3167;
						_errHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(_input,356,_ctx);
					}
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Group_by_elementsContext : ParserRuleContext {
		public Grouping_sets_clauseContext grouping_sets_clause() {
			return GetRuleContext<Grouping_sets_clauseContext>(0);
		}
		public Rollup_cube_clauseContext rollup_cube_clause() {
			return GetRuleContext<Rollup_cube_clauseContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Group_by_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_group_by_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterGroup_by_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitGroup_by_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroup_by_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Group_by_elementsContext group_by_elements() {
		Group_by_elementsContext _localctx = new Group_by_elementsContext(_ctx, State);
		EnterRule(_localctx, 382, RULE_group_by_elements);
		try {
			State = 3175;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,359,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3172; grouping_sets_clause();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3173; rollup_cube_clause();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3174; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rollup_cube_clauseContext : ParserRuleContext {
		public Grouping_sets_elementsContext[] grouping_sets_elements() {
			return GetRuleContexts<Grouping_sets_elementsContext>();
		}
		public Grouping_sets_elementsContext grouping_sets_elements(int i) {
			return GetRuleContext<Grouping_sets_elementsContext>(i);
		}
		public ITerminalNode ROLLUP() { return GetToken(PlSqlParser.ROLLUP, 0); }
		public ITerminalNode CUBE() { return GetToken(PlSqlParser.CUBE, 0); }
		public Rollup_cube_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollup_cube_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRollup_cube_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRollup_cube_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRollup_cube_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Rollup_cube_clauseContext rollup_cube_clause() {
		Rollup_cube_clauseContext _localctx = new Rollup_cube_clauseContext(_ctx, State);
		EnterRule(_localctx, 384, RULE_rollup_cube_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3177;
			_la = _input.La(1);
			if ( !(_la==CUBE || _la==ROLLUP) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 3178; Match(LEFT_PAREN);
			State = 3179; grouping_sets_elements();
			State = 3184;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3180; Match(COMMA);
				State = 3181; grouping_sets_elements();
				}
				}
				State = 3186;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3187; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Grouping_sets_clauseContext : ParserRuleContext {
		public ITerminalNode GROUPING() { return GetToken(PlSqlParser.GROUPING, 0); }
		public ITerminalNode SETS() { return GetToken(PlSqlParser.SETS, 0); }
		public Grouping_sets_elementsContext[] grouping_sets_elements() {
			return GetRuleContexts<Grouping_sets_elementsContext>();
		}
		public Grouping_sets_elementsContext grouping_sets_elements(int i) {
			return GetRuleContext<Grouping_sets_elementsContext>(i);
		}
		public Grouping_sets_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grouping_sets_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterGrouping_sets_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitGrouping_sets_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrouping_sets_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Grouping_sets_clauseContext grouping_sets_clause() {
		Grouping_sets_clauseContext _localctx = new Grouping_sets_clauseContext(_ctx, State);
		EnterRule(_localctx, 386, RULE_grouping_sets_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3189; Match(GROUPING);
			State = 3190; Match(SETS);
			State = 3191; Match(LEFT_PAREN);
			State = 3192; grouping_sets_elements();
			State = 3197;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3193; Match(COMMA);
				State = 3194; grouping_sets_elements();
				}
				}
				State = 3199;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3200; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Grouping_sets_elementsContext : ParserRuleContext {
		public Rollup_cube_clauseContext rollup_cube_clause() {
			return GetRuleContext<Rollup_cube_clauseContext>(0);
		}
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Grouping_sets_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grouping_sets_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterGrouping_sets_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitGrouping_sets_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrouping_sets_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Grouping_sets_elementsContext grouping_sets_elements() {
		Grouping_sets_elementsContext _localctx = new Grouping_sets_elementsContext(_ctx, State);
		EnterRule(_localctx, 388, RULE_grouping_sets_elements);
		try {
			State = 3205;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,362,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3202; rollup_cube_clause();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3203; expression_list();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3204; expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Having_clauseContext : ParserRuleContext {
		public ITerminalNode HAVING() { return GetToken(PlSqlParser.HAVING, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Having_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_having_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterHaving_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitHaving_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHaving_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Having_clauseContext having_clause() {
		Having_clauseContext _localctx = new Having_clauseContext(_ctx, State);
		EnterRule(_localctx, 390, RULE_having_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3207; Match(HAVING);
			State = 3208; condition();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_clauseContext : ParserRuleContext {
		public ITerminalNode MODEL() { return GetToken(PlSqlParser.MODEL, 0); }
		public Main_modelContext main_model() {
			return GetRuleContext<Main_modelContext>(0);
		}
		public Cell_reference_optionsContext[] cell_reference_options() {
			return GetRuleContexts<Cell_reference_optionsContext>();
		}
		public Cell_reference_optionsContext cell_reference_options(int i) {
			return GetRuleContext<Cell_reference_optionsContext>(i);
		}
		public Return_rows_clauseContext return_rows_clause() {
			return GetRuleContext<Return_rows_clauseContext>(0);
		}
		public Reference_modelContext[] reference_model() {
			return GetRuleContexts<Reference_modelContext>();
		}
		public Reference_modelContext reference_model(int i) {
			return GetRuleContext<Reference_modelContext>(i);
		}
		public Model_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterModel_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitModel_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_clauseContext model_clause() {
		Model_clauseContext _localctx = new Model_clauseContext(_ctx, State);
		EnterRule(_localctx, 392, RULE_model_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3210; Match(MODEL);
			State = 3214;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==IGNORE || _la==KEEP || _la==UNIQUE) {
				{
				{
				State = 3211; cell_reference_options();
				}
				}
				State = 3216;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3218;
			_la = _input.La(1);
			if (_la==RETURN) {
				{
				State = 3217; return_rows_clause();
				}
			}

			State = 3223;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==REFERENCE) {
				{
				{
				State = 3220; reference_model();
				}
				}
				State = 3225;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3226; main_model();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cell_reference_optionsContext : ParserRuleContext {
		public ITerminalNode NAV() { return GetToken(PlSqlParser.NAV, 0); }
		public ITerminalNode IGNORE() { return GetToken(PlSqlParser.IGNORE, 0); }
		public ITerminalNode KEEP() { return GetToken(PlSqlParser.KEEP, 0); }
		public ITerminalNode UNIQUE() { return GetToken(PlSqlParser.UNIQUE, 0); }
		public ITerminalNode DIMENSION() { return GetToken(PlSqlParser.DIMENSION, 0); }
		public ITerminalNode SINGLE() { return GetToken(PlSqlParser.SINGLE, 0); }
		public ITerminalNode REFERENCE() { return GetToken(PlSqlParser.REFERENCE, 0); }
		public Cell_reference_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cell_reference_options; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCell_reference_options(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCell_reference_options(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCell_reference_options(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cell_reference_optionsContext cell_reference_options() {
		Cell_reference_optionsContext _localctx = new Cell_reference_optionsContext(_ctx, State);
		EnterRule(_localctx, 394, RULE_cell_reference_options);
		int _la;
		try {
			State = 3236;
			switch (_input.La(1)) {
			case IGNORE:
			case KEEP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3228;
				_la = _input.La(1);
				if ( !(_la==IGNORE || _la==KEEP) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 3229; Match(NAV);
				}
				break;
			case UNIQUE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3230; Match(UNIQUE);
				State = 3234;
				switch (_input.La(1)) {
				case DIMENSION:
					{
					State = 3231; Match(DIMENSION);
					}
					break;
				case SINGLE:
					{
					State = 3232; Match(SINGLE);
					State = 3233; Match(REFERENCE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Return_rows_clauseContext : ParserRuleContext {
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public ITerminalNode ROWS() { return GetToken(PlSqlParser.ROWS, 0); }
		public ITerminalNode UPDATED() { return GetToken(PlSqlParser.UPDATED, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Return_rows_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_return_rows_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterReturn_rows_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitReturn_rows_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturn_rows_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Return_rows_clauseContext return_rows_clause() {
		Return_rows_clauseContext _localctx = new Return_rows_clauseContext(_ctx, State);
		EnterRule(_localctx, 396, RULE_return_rows_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3238; Match(RETURN);
			State = 3239;
			_la = _input.La(1);
			if ( !(_la==ALL || _la==UPDATED) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 3240; Match(ROWS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Reference_modelContext : ParserRuleContext {
		public ITerminalNode REFERENCE() { return GetToken(PlSqlParser.REFERENCE, 0); }
		public Reference_model_nameContext reference_model_name() {
			return GetRuleContext<Reference_model_nameContext>(0);
		}
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Model_column_clausesContext model_column_clauses() {
			return GetRuleContext<Model_column_clausesContext>(0);
		}
		public Cell_reference_optionsContext[] cell_reference_options() {
			return GetRuleContexts<Cell_reference_optionsContext>();
		}
		public Cell_reference_optionsContext cell_reference_options(int i) {
			return GetRuleContext<Cell_reference_optionsContext>(i);
		}
		public Reference_modelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reference_model; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterReference_model(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitReference_model(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReference_model(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Reference_modelContext reference_model() {
		Reference_modelContext _localctx = new Reference_modelContext(_ctx, State);
		EnterRule(_localctx, 398, RULE_reference_model);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3242; Match(REFERENCE);
			State = 3243; reference_model_name();
			State = 3244; Match(ON);
			State = 3245; Match(LEFT_PAREN);
			State = 3246; subquery();
			State = 3247; Match(RIGHT_PAREN);
			State = 3248; model_column_clauses();
			State = 3252;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==IGNORE || _la==KEEP || _la==UNIQUE) {
				{
				{
				State = 3249; cell_reference_options();
				}
				}
				State = 3254;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Main_modelContext : ParserRuleContext {
		public Model_column_clausesContext model_column_clauses() {
			return GetRuleContext<Model_column_clausesContext>(0);
		}
		public Model_rules_clauseContext model_rules_clause() {
			return GetRuleContext<Model_rules_clauseContext>(0);
		}
		public ITerminalNode MAIN() { return GetToken(PlSqlParser.MAIN, 0); }
		public Main_model_nameContext main_model_name() {
			return GetRuleContext<Main_model_nameContext>(0);
		}
		public Cell_reference_optionsContext[] cell_reference_options() {
			return GetRuleContexts<Cell_reference_optionsContext>();
		}
		public Cell_reference_optionsContext cell_reference_options(int i) {
			return GetRuleContext<Cell_reference_optionsContext>(i);
		}
		public Main_modelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_main_model; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMain_model(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMain_model(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMain_model(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Main_modelContext main_model() {
		Main_modelContext _localctx = new Main_modelContext(_ctx, State);
		EnterRule(_localctx, 400, RULE_main_model);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3257;
			_la = _input.La(1);
			if (_la==MAIN) {
				{
				State = 3255; Match(MAIN);
				State = 3256; main_model_name();
				}
			}

			State = 3259; model_column_clauses();
			State = 3263;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==IGNORE || _la==KEEP || _la==UNIQUE) {
				{
				{
				State = 3260; cell_reference_options();
				}
				}
				State = 3265;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3266; model_rules_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_column_clausesContext : ParserRuleContext {
		public ITerminalNode DIMENSION() { return GetToken(PlSqlParser.DIMENSION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Model_column_listContext[] model_column_list() {
			return GetRuleContexts<Model_column_listContext>();
		}
		public Model_column_listContext model_column_list(int i) {
			return GetRuleContext<Model_column_listContext>(i);
		}
		public ITerminalNode MEASURES() { return GetToken(PlSqlParser.MEASURES, 0); }
		public Model_column_partition_partContext model_column_partition_part() {
			return GetRuleContext<Model_column_partition_partContext>(0);
		}
		public Model_column_clausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column_clauses; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterModel_column_clauses(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitModel_column_clauses(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_column_clauses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_column_clausesContext model_column_clauses() {
		Model_column_clausesContext _localctx = new Model_column_clausesContext(_ctx, State);
		EnterRule(_localctx, 402, RULE_model_column_clauses);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3269;
			_la = _input.La(1);
			if (_la==PARTITION) {
				{
				State = 3268; model_column_partition_part();
				}
			}

			State = 3271; Match(DIMENSION);
			State = 3272; Match(BY);
			State = 3273; model_column_list();
			State = 3274; Match(MEASURES);
			State = 3275; model_column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_column_partition_partContext : ParserRuleContext {
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Model_column_listContext model_column_list() {
			return GetRuleContext<Model_column_listContext>(0);
		}
		public Model_column_partition_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column_partition_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterModel_column_partition_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitModel_column_partition_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_column_partition_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_column_partition_partContext model_column_partition_part() {
		Model_column_partition_partContext _localctx = new Model_column_partition_partContext(_ctx, State);
		EnterRule(_localctx, 404, RULE_model_column_partition_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3277; Match(PARTITION);
			State = 3278; Match(BY);
			State = 3279; model_column_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_column_listContext : ParserRuleContext {
		public Model_columnContext[] model_column() {
			return GetRuleContexts<Model_columnContext>();
		}
		public Model_columnContext model_column(int i) {
			return GetRuleContext<Model_columnContext>(i);
		}
		public Model_column_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterModel_column_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitModel_column_list(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_column_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_column_listContext model_column_list() {
		Model_column_listContext _localctx = new Model_column_listContext(_ctx, State);
		EnterRule(_localctx, 406, RULE_model_column_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3281; Match(LEFT_PAREN);
			State = 3282; model_column();
			State = 3287;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3283; Match(COMMA);
				State = 3284; model_column();
				}
				}
				State = 3289;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3290; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_columnContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Model_columnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_column; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterModel_column(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitModel_column(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_column(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_columnContext model_column() {
		Model_columnContext _localctx = new Model_columnContext(_ctx, State);
		EnterRule(_localctx, 408, RULE_model_column);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3292; expression();
			State = 3294;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
				{
				State = 3293; table_alias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_rules_clauseContext : ParserRuleContext {
		public Model_rules_elementContext[] model_rules_element() {
			return GetRuleContexts<Model_rules_elementContext>();
		}
		public Model_rules_elementContext model_rules_element(int i) {
			return GetRuleContext<Model_rules_elementContext>(i);
		}
		public Model_rules_partContext model_rules_part() {
			return GetRuleContext<Model_rules_partContext>(0);
		}
		public Model_rules_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_rules_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterModel_rules_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitModel_rules_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_rules_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_rules_clauseContext model_rules_clause() {
		Model_rules_clauseContext _localctx = new Model_rules_clauseContext(_ctx, State);
		EnterRule(_localctx, 410, RULE_model_rules_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3297;
			_la = _input.La(1);
			if (_la==RULES) {
				{
				State = 3296; model_rules_part();
				}
			}

			State = 3299; Match(LEFT_PAREN);
			State = 3300; model_rules_element();
			State = 3305;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3301; Match(COMMA);
				State = 3302; model_rules_element();
				}
				}
				State = 3307;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3308; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_rules_partContext : ParserRuleContext {
		public ITerminalNode RULES() { return GetToken(PlSqlParser.RULES, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public ITerminalNode UPSERT() { return GetToken(PlSqlParser.UPSERT, 0); }
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public Model_iterate_clauseContext model_iterate_clause() {
			return GetRuleContext<Model_iterate_clauseContext>(0);
		}
		public ITerminalNode AUTOMATIC() { return GetToken(PlSqlParser.AUTOMATIC, 0); }
		public ITerminalNode SEQUENTIAL() { return GetToken(PlSqlParser.SEQUENTIAL, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Model_rules_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_rules_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterModel_rules_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitModel_rules_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_rules_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_rules_partContext model_rules_part() {
		Model_rules_partContext _localctx = new Model_rules_partContext(_ctx, State);
		EnterRule(_localctx, 412, RULE_model_rules_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3310; Match(RULES);
			State = 3316;
			switch (_input.La(1)) {
			case UPDATE:
				{
				State = 3311; Match(UPDATE);
				}
				break;
			case UPSERT:
				{
				State = 3312; Match(UPSERT);
				State = 3314;
				_la = _input.La(1);
				if (_la==ALL) {
					{
					State = 3313; Match(ALL);
					}
				}

				}
				break;
			case AUTOMATIC:
			case ITERATE:
			case SEQUENTIAL:
			case LEFT_PAREN:
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3320;
			_la = _input.La(1);
			if (_la==AUTOMATIC || _la==SEQUENTIAL) {
				{
				State = 3318;
				_la = _input.La(1);
				if ( !(_la==AUTOMATIC || _la==SEQUENTIAL) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 3319; Match(ORDER);
				}
			}

			State = 3323;
			_la = _input.La(1);
			if (_la==ITERATE) {
				{
				State = 3322; model_iterate_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_rules_elementContext : ParserRuleContext {
		public Cell_assignmentContext cell_assignment() {
			return GetRuleContext<Cell_assignmentContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public ITerminalNode UPSERT() { return GetToken(PlSqlParser.UPSERT, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Model_rules_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_rules_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterModel_rules_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitModel_rules_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_rules_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_rules_elementContext model_rules_element() {
		Model_rules_elementContext _localctx = new Model_rules_elementContext(_ctx, State);
		EnterRule(_localctx, 414, RULE_model_rules_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3330;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,381,_ctx) ) {
			case 1:
				{
				State = 3325; Match(UPDATE);
				}
				break;

			case 2:
				{
				State = 3326; Match(UPSERT);
				State = 3328;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,380,_ctx) ) {
				case 1:
					{
					State = 3327; Match(ALL);
					}
					break;
				}
				}
				break;
			}
			State = 3332; cell_assignment();
			State = 3334;
			_la = _input.La(1);
			if (_la==ORDER) {
				{
				State = 3333; order_by_clause();
				}
			}

			State = 3336; Match(EQUALS_OP);
			State = 3337; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cell_assignmentContext : ParserRuleContext {
		public Model_expressionContext model_expression() {
			return GetRuleContext<Model_expressionContext>(0);
		}
		public Cell_assignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cell_assignment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCell_assignment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCell_assignment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCell_assignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cell_assignmentContext cell_assignment() {
		Cell_assignmentContext _localctx = new Cell_assignmentContext(_ctx, State);
		EnterRule(_localctx, 416, RULE_cell_assignment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3339; model_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_iterate_clauseContext : ParserRuleContext {
		public ITerminalNode ITERATE() { return GetToken(PlSqlParser.ITERATE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Until_partContext until_part() {
			return GetRuleContext<Until_partContext>(0);
		}
		public Model_iterate_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_iterate_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterModel_iterate_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitModel_iterate_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_iterate_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_iterate_clauseContext model_iterate_clause() {
		Model_iterate_clauseContext _localctx = new Model_iterate_clauseContext(_ctx, State);
		EnterRule(_localctx, 418, RULE_model_iterate_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3341; Match(ITERATE);
			State = 3342; Match(LEFT_PAREN);
			State = 3343; expression();
			State = 3344; Match(RIGHT_PAREN);
			State = 3346;
			_la = _input.La(1);
			if (_la==UNTIL) {
				{
				State = 3345; until_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Until_partContext : ParserRuleContext {
		public ITerminalNode UNTIL() { return GetToken(PlSqlParser.UNTIL, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Until_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_until_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterUntil_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitUntil_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUntil_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Until_partContext until_part() {
		Until_partContext _localctx = new Until_partContext(_ctx, State);
		EnterRule(_localctx, 420, RULE_until_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3348; Match(UNTIL);
			State = 3349; Match(LEFT_PAREN);
			State = 3350; condition();
			State = 3351; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Order_by_clauseContext : ParserRuleContext {
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Order_by_elementsContext[] order_by_elements() {
			return GetRuleContexts<Order_by_elementsContext>();
		}
		public Order_by_elementsContext order_by_elements(int i) {
			return GetRuleContext<Order_by_elementsContext>(i);
		}
		public ITerminalNode SIBLINGS() { return GetToken(PlSqlParser.SIBLINGS, 0); }
		public Order_by_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_order_by_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterOrder_by_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitOrder_by_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrder_by_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Order_by_clauseContext order_by_clause() {
		Order_by_clauseContext _localctx = new Order_by_clauseContext(_ctx, State);
		EnterRule(_localctx, 422, RULE_order_by_clause);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3353; Match(ORDER);
			State = 3355;
			_la = _input.La(1);
			if (_la==SIBLINGS) {
				{
				State = 3354; Match(SIBLINGS);
				}
			}

			State = 3357; Match(BY);
			State = 3358; order_by_elements();
			State = 3363;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,385,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3359; Match(COMMA);
					State = 3360; order_by_elements();
					}
					} 
				}
				State = 3365;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,385,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Order_by_elementsContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode NULLS() { return GetToken(PlSqlParser.NULLS, 0); }
		public ITerminalNode ASC() { return GetToken(PlSqlParser.ASC, 0); }
		public ITerminalNode DESC() { return GetToken(PlSqlParser.DESC, 0); }
		public ITerminalNode FIRST() { return GetToken(PlSqlParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(PlSqlParser.LAST, 0); }
		public Order_by_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_order_by_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterOrder_by_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitOrder_by_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrder_by_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Order_by_elementsContext order_by_elements() {
		Order_by_elementsContext _localctx = new Order_by_elementsContext(_ctx, State);
		EnterRule(_localctx, 424, RULE_order_by_elements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3366; expression();
			State = 3368;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,386,_ctx) ) {
			case 1:
				{
				State = 3367;
				_la = _input.La(1);
				if ( !(_la==ASC || _la==DESC) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
				break;
			}
			State = 3372;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,387,_ctx) ) {
			case 1:
				{
				State = 3370; Match(NULLS);
				State = 3371;
				_la = _input.La(1);
				if ( !(_la==FIRST || _la==LAST) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_update_clauseContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public For_update_of_partContext for_update_of_part() {
			return GetRuleContext<For_update_of_partContext>(0);
		}
		public For_update_optionsContext for_update_options() {
			return GetRuleContext<For_update_optionsContext>(0);
		}
		public For_update_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_update_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFor_update_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFor_update_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_update_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_update_clauseContext for_update_clause() {
		For_update_clauseContext _localctx = new For_update_clauseContext(_ctx, State);
		EnterRule(_localctx, 426, RULE_for_update_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3374; Match(FOR);
			State = 3375; Match(UPDATE);
			State = 3377;
			_la = _input.La(1);
			if (_la==OF) {
				{
				State = 3376; for_update_of_part();
				}
			}

			State = 3380;
			_la = _input.La(1);
			if (_la==NOWAIT || _la==SKIP_ || _la==WAIT) {
				{
				State = 3379; for_update_options();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_update_of_partContext : ParserRuleContext {
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public For_update_of_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_update_of_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFor_update_of_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFor_update_of_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_update_of_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_update_of_partContext for_update_of_part() {
		For_update_of_partContext _localctx = new For_update_of_partContext(_ctx, State);
		EnterRule(_localctx, 428, RULE_for_update_of_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3382; Match(OF);
			State = 3383; column_name();
			State = 3388;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3384; Match(COMMA);
				State = 3385; column_name();
				}
				}
				State = 3390;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_update_optionsContext : ParserRuleContext {
		public ITerminalNode SKIP_() { return GetToken(PlSqlParser.SKIP_, 0); }
		public ITerminalNode LOCKED() { return GetToken(PlSqlParser.LOCKED, 0); }
		public ITerminalNode NOWAIT() { return GetToken(PlSqlParser.NOWAIT, 0); }
		public ITerminalNode WAIT() { return GetToken(PlSqlParser.WAIT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public For_update_optionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_update_options; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFor_update_options(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFor_update_options(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_update_options(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_update_optionsContext for_update_options() {
		For_update_optionsContext _localctx = new For_update_optionsContext(_ctx, State);
		EnterRule(_localctx, 430, RULE_for_update_options);
		try {
			State = 3396;
			switch (_input.La(1)) {
			case SKIP_:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3391; Match(SKIP_);
				State = 3392; Match(LOCKED);
				}
				break;
			case NOWAIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3393; Match(NOWAIT);
				}
				break;
			case WAIT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3394; Match(WAIT);
				State = 3395; expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Update_statementContext : ParserRuleContext {
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public General_table_refContext general_table_ref() {
			return GetRuleContext<General_table_refContext>(0);
		}
		public Update_set_clauseContext update_set_clause() {
			return GetRuleContext<Update_set_clauseContext>(0);
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Static_returning_clauseContext static_returning_clause() {
			return GetRuleContext<Static_returning_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Update_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_update_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterUpdate_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitUpdate_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdate_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Update_statementContext update_statement() {
		Update_statementContext _localctx = new Update_statementContext(_ctx, State);
		EnterRule(_localctx, 432, RULE_update_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3398; Match(UPDATE);
			State = 3399; general_table_ref();
			State = 3400; update_set_clause();
			State = 3402;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 3401; where_clause();
				}
			}

			State = 3405;
			_la = _input.La(1);
			if (_la==RETURN || _la==RETURNING) {
				{
				State = 3404; static_returning_clause();
				}
			}

			State = 3408;
			_la = _input.La(1);
			if (_la==LOG) {
				{
				State = 3407; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Update_set_clauseContext : ParserRuleContext {
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public Column_based_update_set_clauseContext[] column_based_update_set_clause() {
			return GetRuleContexts<Column_based_update_set_clauseContext>();
		}
		public Column_based_update_set_clauseContext column_based_update_set_clause(int i) {
			return GetRuleContext<Column_based_update_set_clauseContext>(i);
		}
		public ITerminalNode VALUE() { return GetToken(PlSqlParser.VALUE, 0); }
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Update_set_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_update_set_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterUpdate_set_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitUpdate_set_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUpdate_set_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Update_set_clauseContext update_set_clause() {
		Update_set_clauseContext _localctx = new Update_set_clauseContext(_ctx, State);
		EnterRule(_localctx, 434, RULE_update_set_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3410; Match(SET);
			State = 3426;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,396,_ctx) ) {
			case 1:
				{
				State = 3411; column_based_update_set_clause();
				State = 3416;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3412; Match(COMMA);
					State = 3413; column_based_update_set_clause();
					}
					}
					State = 3418;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 2:
				{
				State = 3419; Match(VALUE);
				State = 3420; Match(LEFT_PAREN);
				State = 3421; id();
				State = 3422; Match(RIGHT_PAREN);
				State = 3423; Match(EQUALS_OP);
				State = 3424; expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_based_update_set_clauseContext : ParserRuleContext {
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Column_based_update_set_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_based_update_set_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterColumn_based_update_set_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitColumn_based_update_set_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_based_update_set_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_based_update_set_clauseContext column_based_update_set_clause() {
		Column_based_update_set_clauseContext _localctx = new Column_based_update_set_clauseContext(_ctx, State);
		EnterRule(_localctx, 436, RULE_column_based_update_set_clause);
		int _la;
		try {
			State = 3445;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3428; column_name();
				State = 3429; Match(EQUALS_OP);
				State = 3430; expression();
				}
				break;
			case LEFT_PAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3432; Match(LEFT_PAREN);
				State = 3433; column_name();
				State = 3438;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3434; Match(COMMA);
					State = 3435; column_name();
					}
					}
					State = 3440;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 3441; Match(RIGHT_PAREN);
				State = 3442; Match(EQUALS_OP);
				State = 3443; subquery();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Delete_statementContext : ParserRuleContext {
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public General_table_refContext general_table_ref() {
			return GetRuleContext<General_table_refContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(PlSqlParser.FROM, 0); }
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Static_returning_clauseContext static_returning_clause() {
			return GetRuleContext<Static_returning_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Delete_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_delete_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDelete_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDelete_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDelete_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Delete_statementContext delete_statement() {
		Delete_statementContext _localctx = new Delete_statementContext(_ctx, State);
		EnterRule(_localctx, 438, RULE_delete_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3447; Match(DELETE);
			State = 3449;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,399,_ctx) ) {
			case 1:
				{
				State = 3448; Match(FROM);
				}
				break;
			}
			State = 3451; general_table_ref();
			State = 3453;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 3452; where_clause();
				}
			}

			State = 3456;
			_la = _input.La(1);
			if (_la==RETURN || _la==RETURNING) {
				{
				State = 3455; static_returning_clause();
				}
			}

			State = 3459;
			_la = _input.La(1);
			if (_la==LOG) {
				{
				State = 3458; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Insert_statementContext : ParserRuleContext {
		public ITerminalNode INSERT() { return GetToken(PlSqlParser.INSERT, 0); }
		public Single_table_insertContext single_table_insert() {
			return GetRuleContext<Single_table_insertContext>(0);
		}
		public Multi_table_insertContext multi_table_insert() {
			return GetRuleContext<Multi_table_insertContext>(0);
		}
		public Insert_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insert_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterInsert_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitInsert_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsert_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Insert_statementContext insert_statement() {
		Insert_statementContext _localctx = new Insert_statementContext(_ctx, State);
		EnterRule(_localctx, 440, RULE_insert_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3461; Match(INSERT);
			State = 3464;
			switch (_input.La(1)) {
			case INTO:
				{
				State = 3462; single_table_insert();
				}
				break;
			case ALL:
			case FIRST:
			case WHEN:
				{
				State = 3463; multi_table_insert();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Single_table_insertContext : ParserRuleContext {
		public Insert_into_clauseContext insert_into_clause() {
			return GetRuleContext<Insert_into_clauseContext>(0);
		}
		public Values_clauseContext values_clause() {
			return GetRuleContext<Values_clauseContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Static_returning_clauseContext static_returning_clause() {
			return GetRuleContext<Static_returning_clauseContext>(0);
		}
		public Single_table_insertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_single_table_insert; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSingle_table_insert(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSingle_table_insert(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingle_table_insert(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Single_table_insertContext single_table_insert() {
		Single_table_insertContext _localctx = new Single_table_insertContext(_ctx, State);
		EnterRule(_localctx, 442, RULE_single_table_insert);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3466; insert_into_clause();
			State = 3472;
			switch (_input.La(1)) {
			case VALUES:
				{
				State = 3467; values_clause();
				State = 3469;
				_la = _input.La(1);
				if (_la==RETURN || _la==RETURNING) {
					{
					State = 3468; static_returning_clause();
					}
				}

				}
				break;
			case SELECT:
			case WITH:
			case LEFT_PAREN:
				{
				State = 3471; select_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3475;
			_la = _input.La(1);
			if (_la==LOG) {
				{
				State = 3474; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multi_table_insertContext : ParserRuleContext {
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Conditional_insert_clauseContext conditional_insert_clause() {
			return GetRuleContext<Conditional_insert_clauseContext>(0);
		}
		public Multi_table_elementContext[] multi_table_element() {
			return GetRuleContexts<Multi_table_elementContext>();
		}
		public Multi_table_elementContext multi_table_element(int i) {
			return GetRuleContext<Multi_table_elementContext>(i);
		}
		public Multi_table_insertContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multi_table_insert; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMulti_table_insert(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMulti_table_insert(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulti_table_insert(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multi_table_insertContext multi_table_insert() {
		Multi_table_insertContext _localctx = new Multi_table_insertContext(_ctx, State);
		EnterRule(_localctx, 444, RULE_multi_table_insert);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3484;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,408,_ctx) ) {
			case 1:
				{
				State = 3477; Match(ALL);
				State = 3479;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 3478; multi_table_element();
					}
					}
					State = 3481;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( _la==INTO );
				}
				break;

			case 2:
				{
				State = 3483; conditional_insert_clause();
				}
				break;
			}
			State = 3486; select_statement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multi_table_elementContext : ParserRuleContext {
		public Insert_into_clauseContext insert_into_clause() {
			return GetRuleContext<Insert_into_clauseContext>(0);
		}
		public Values_clauseContext values_clause() {
			return GetRuleContext<Values_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Multi_table_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multi_table_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMulti_table_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMulti_table_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulti_table_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multi_table_elementContext multi_table_element() {
		Multi_table_elementContext _localctx = new Multi_table_elementContext(_ctx, State);
		EnterRule(_localctx, 446, RULE_multi_table_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3488; insert_into_clause();
			State = 3490;
			_la = _input.La(1);
			if (_la==VALUES) {
				{
				State = 3489; values_clause();
				}
			}

			State = 3493;
			_la = _input.La(1);
			if (_la==LOG) {
				{
				State = 3492; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_insert_clauseContext : ParserRuleContext {
		public Conditional_insert_when_partContext[] conditional_insert_when_part() {
			return GetRuleContexts<Conditional_insert_when_partContext>();
		}
		public Conditional_insert_when_partContext conditional_insert_when_part(int i) {
			return GetRuleContext<Conditional_insert_when_partContext>(i);
		}
		public Conditional_insert_else_partContext conditional_insert_else_part() {
			return GetRuleContext<Conditional_insert_else_partContext>(0);
		}
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode FIRST() { return GetToken(PlSqlParser.FIRST, 0); }
		public Conditional_insert_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_insert_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterConditional_insert_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitConditional_insert_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditional_insert_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_insert_clauseContext conditional_insert_clause() {
		Conditional_insert_clauseContext _localctx = new Conditional_insert_clauseContext(_ctx, State);
		EnterRule(_localctx, 448, RULE_conditional_insert_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3496;
			_la = _input.La(1);
			if (_la==ALL || _la==FIRST) {
				{
				State = 3495;
				_la = _input.La(1);
				if ( !(_la==ALL || _la==FIRST) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
			}

			State = 3499;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 3498; conditional_insert_when_part();
				}
				}
				State = 3501;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WHEN );
			State = 3504;
			_la = _input.La(1);
			if (_la==ELSE) {
				{
				State = 3503; conditional_insert_else_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_insert_when_partContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public Multi_table_elementContext[] multi_table_element() {
			return GetRuleContexts<Multi_table_elementContext>();
		}
		public Multi_table_elementContext multi_table_element(int i) {
			return GetRuleContext<Multi_table_elementContext>(i);
		}
		public Conditional_insert_when_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_insert_when_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterConditional_insert_when_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitConditional_insert_when_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditional_insert_when_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_insert_when_partContext conditional_insert_when_part() {
		Conditional_insert_when_partContext _localctx = new Conditional_insert_when_partContext(_ctx, State);
		EnterRule(_localctx, 450, RULE_conditional_insert_when_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3506; Match(WHEN);
			State = 3507; condition();
			State = 3508; Match(THEN);
			State = 3510;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 3509; multi_table_element();
				}
				}
				State = 3512;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==INTO );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_insert_else_partContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(PlSqlParser.ELSE, 0); }
		public Multi_table_elementContext[] multi_table_element() {
			return GetRuleContexts<Multi_table_elementContext>();
		}
		public Multi_table_elementContext multi_table_element(int i) {
			return GetRuleContext<Multi_table_elementContext>(i);
		}
		public Conditional_insert_else_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_insert_else_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterConditional_insert_else_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitConditional_insert_else_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConditional_insert_else_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_insert_else_partContext conditional_insert_else_part() {
		Conditional_insert_else_partContext _localctx = new Conditional_insert_else_partContext(_ctx, State);
		EnterRule(_localctx, 452, RULE_conditional_insert_else_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3514; Match(ELSE);
			State = 3516;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 3515; multi_table_element();
				}
				}
				State = 3518;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==INTO );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Insert_into_clauseContext : ParserRuleContext {
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public General_table_refContext general_table_ref() {
			return GetRuleContext<General_table_refContext>(0);
		}
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Insert_into_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insert_into_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterInsert_into_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitInsert_into_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsert_into_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Insert_into_clauseContext insert_into_clause() {
		Insert_into_clauseContext _localctx = new Insert_into_clauseContext(_ctx, State);
		EnterRule(_localctx, 454, RULE_insert_into_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3520; Match(INTO);
			State = 3521; general_table_ref();
			State = 3533;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,417,_ctx) ) {
			case 1:
				{
				State = 3522; Match(LEFT_PAREN);
				State = 3523; column_name();
				State = 3528;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3524; Match(COMMA);
					State = 3525; column_name();
					}
					}
					State = 3530;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 3531; Match(RIGHT_PAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Values_clauseContext : ParserRuleContext {
		public ITerminalNode VALUES() { return GetToken(PlSqlParser.VALUES, 0); }
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public Record_nameContext record_name() {
			return GetRuleContext<Record_nameContext>(0);
		}
		public Collection_assoc_expressionContext collection_assoc_expression() {
			return GetRuleContext<Collection_assoc_expressionContext>(0);
		}
		public Values_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_values_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterValues_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitValues_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitValues_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Values_clauseContext values_clause() {
		Values_clauseContext _localctx = new Values_clauseContext(_ctx, State);
		EnterRule(_localctx, 456, RULE_values_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3535; Match(VALUES);
			State = 3539;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,418,_ctx) ) {
			case 1:
				{
				State = 3536; expression_list();
				}
				break;

			case 2:
				{
				State = 3537; record_name();
				}
				break;

			case 3:
				{
				State = 3538; collection_assoc_expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_statementContext : ParserRuleContext {
		public ITerminalNode MERGE() { return GetToken(PlSqlParser.MERGE, 0); }
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public Selected_tableviewContext selected_tableview() {
			return GetRuleContext<Selected_tableviewContext>(0);
		}
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ConditionContext condition() {
			return GetRuleContext<ConditionContext>(0);
		}
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Merge_update_clauseContext merge_update_clause() {
			return GetRuleContext<Merge_update_clauseContext>(0);
		}
		public Merge_insert_clauseContext merge_insert_clause() {
			return GetRuleContext<Merge_insert_clauseContext>(0);
		}
		public Error_logging_clauseContext error_logging_clause() {
			return GetRuleContext<Error_logging_clauseContext>(0);
		}
		public Merge_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMerge_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMerge_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_statementContext merge_statement() {
		Merge_statementContext _localctx = new Merge_statementContext(_ctx, State);
		EnterRule(_localctx, 458, RULE_merge_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3541; Match(MERGE);
			State = 3542; Match(INTO);
			State = 3543; tableview_name();
			State = 3545;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,419,_ctx) ) {
			case 1:
				{
				State = 3544; table_alias();
				}
				break;
			}
			State = 3547; Match(USING);
			State = 3548; selected_tableview();
			State = 3549; Match(ON);
			State = 3550; Match(LEFT_PAREN);
			State = 3551; condition();
			State = 3552; Match(RIGHT_PAREN);
			State = 3561;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,422,_ctx) ) {
			case 1:
				{
				State = 3553; merge_update_clause();
				State = 3555;
				_la = _input.La(1);
				if (_la==WHEN) {
					{
					State = 3554; merge_insert_clause();
					}
				}

				}
				break;

			case 2:
				{
				State = 3557; merge_insert_clause();
				State = 3559;
				_la = _input.La(1);
				if (_la==WHEN) {
					{
					State = 3558; merge_update_clause();
					}
				}

				}
				break;
			}
			State = 3564;
			_la = _input.La(1);
			if (_la==LOG) {
				{
				State = 3563; error_logging_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_update_clauseContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ITerminalNode MATCHED() { return GetToken(PlSqlParser.MATCHED, 0); }
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public Merge_elementContext[] merge_element() {
			return GetRuleContexts<Merge_elementContext>();
		}
		public Merge_elementContext merge_element(int i) {
			return GetRuleContext<Merge_elementContext>(i);
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Merge_update_delete_partContext merge_update_delete_part() {
			return GetRuleContext<Merge_update_delete_partContext>(0);
		}
		public Merge_update_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_update_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMerge_update_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMerge_update_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_update_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_update_clauseContext merge_update_clause() {
		Merge_update_clauseContext _localctx = new Merge_update_clauseContext(_ctx, State);
		EnterRule(_localctx, 460, RULE_merge_update_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3566; Match(WHEN);
			State = 3567; Match(MATCHED);
			State = 3568; Match(THEN);
			State = 3569; Match(UPDATE);
			State = 3570; Match(SET);
			State = 3571; merge_element();
			State = 3576;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3572; Match(COMMA);
				State = 3573; merge_element();
				}
				}
				State = 3578;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3580;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 3579; where_clause();
				}
			}

			State = 3583;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,426,_ctx) ) {
			case 1:
				{
				State = 3582; merge_update_delete_part();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_elementContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Merge_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMerge_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMerge_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_elementContext merge_element() {
		Merge_elementContext _localctx = new Merge_elementContext(_ctx, State);
		EnterRule(_localctx, 462, RULE_merge_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3585; column_name();
			State = 3586; Match(EQUALS_OP);
			State = 3587; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_update_delete_partContext : ParserRuleContext {
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Merge_update_delete_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_update_delete_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMerge_update_delete_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMerge_update_delete_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_update_delete_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_update_delete_partContext merge_update_delete_part() {
		Merge_update_delete_partContext _localctx = new Merge_update_delete_partContext(_ctx, State);
		EnterRule(_localctx, 464, RULE_merge_update_delete_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3589; Match(DELETE);
			State = 3590; where_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Merge_insert_clauseContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode MATCHED() { return GetToken(PlSqlParser.MATCHED, 0); }
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public ITerminalNode INSERT() { return GetToken(PlSqlParser.INSERT, 0); }
		public ITerminalNode VALUES() { return GetToken(PlSqlParser.VALUES, 0); }
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public Where_clauseContext where_clause() {
			return GetRuleContext<Where_clauseContext>(0);
		}
		public Merge_insert_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_merge_insert_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMerge_insert_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMerge_insert_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMerge_insert_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Merge_insert_clauseContext merge_insert_clause() {
		Merge_insert_clauseContext _localctx = new Merge_insert_clauseContext(_ctx, State);
		EnterRule(_localctx, 466, RULE_merge_insert_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3592; Match(WHEN);
			State = 3593; Match(NOT);
			State = 3594; Match(MATCHED);
			State = 3595; Match(THEN);
			State = 3596; Match(INSERT);
			State = 3608;
			_la = _input.La(1);
			if (_la==LEFT_PAREN) {
				{
				State = 3597; Match(LEFT_PAREN);
				State = 3598; column_name();
				State = 3603;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 3599; Match(COMMA);
					State = 3600; column_name();
					}
					}
					State = 3605;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 3606; Match(RIGHT_PAREN);
				}
			}

			State = 3610; Match(VALUES);
			State = 3611; expression_list();
			State = 3613;
			_la = _input.La(1);
			if (_la==WHERE) {
				{
				State = 3612; where_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Selected_tableviewContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public Selected_tableviewContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selected_tableview; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSelected_tableview(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSelected_tableview(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSelected_tableview(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Selected_tableviewContext selected_tableview() {
		Selected_tableviewContext _localctx = new Selected_tableviewContext(_ctx, State);
		EnterRule(_localctx, 468, RULE_selected_tableview);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3620;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 3615; tableview_name();
				}
				break;
			case LEFT_PAREN:
				{
				State = 3616; Match(LEFT_PAREN);
				State = 3617; select_statement();
				State = 3618; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3623;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,431,_ctx) ) {
			case 1:
				{
				State = 3622; table_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_table_statementContext : ParserRuleContext {
		public ITerminalNode LOCK() { return GetToken(PlSqlParser.LOCK, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public Lock_table_elementContext[] lock_table_element() {
			return GetRuleContexts<Lock_table_elementContext>();
		}
		public Lock_table_elementContext lock_table_element(int i) {
			return GetRuleContext<Lock_table_elementContext>(i);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public Lock_modeContext lock_mode() {
			return GetRuleContext<Lock_modeContext>(0);
		}
		public ITerminalNode MODE() { return GetToken(PlSqlParser.MODE, 0); }
		public Wait_nowait_partContext wait_nowait_part() {
			return GetRuleContext<Wait_nowait_partContext>(0);
		}
		public Lock_table_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_table_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterLock_table_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitLock_table_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLock_table_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lock_table_statementContext lock_table_statement() {
		Lock_table_statementContext _localctx = new Lock_table_statementContext(_ctx, State);
		EnterRule(_localctx, 470, RULE_lock_table_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3625; Match(LOCK);
			State = 3626; Match(TABLE);
			State = 3627; lock_table_element();
			State = 3632;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3628; Match(COMMA);
				State = 3629; lock_table_element();
				}
				}
				State = 3634;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3635; Match(IN);
			State = 3636; lock_mode();
			State = 3637; Match(MODE);
			State = 3639;
			_la = _input.La(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 3638; wait_nowait_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Wait_nowait_partContext : ParserRuleContext {
		public ITerminalNode WAIT() { return GetToken(PlSqlParser.WAIT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode NOWAIT() { return GetToken(PlSqlParser.NOWAIT, 0); }
		public Wait_nowait_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_wait_nowait_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterWait_nowait_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitWait_nowait_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWait_nowait_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Wait_nowait_partContext wait_nowait_part() {
		Wait_nowait_partContext _localctx = new Wait_nowait_partContext(_ctx, State);
		EnterRule(_localctx, 472, RULE_wait_nowait_part);
		try {
			State = 3644;
			switch (_input.La(1)) {
			case WAIT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3641; Match(WAIT);
				State = 3642; expression();
				}
				break;
			case NOWAIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3643; Match(NOWAIT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_table_elementContext : ParserRuleContext {
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Partition_extension_clauseContext partition_extension_clause() {
			return GetRuleContext<Partition_extension_clauseContext>(0);
		}
		public Lock_table_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_table_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterLock_table_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitLock_table_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLock_table_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lock_table_elementContext lock_table_element() {
		Lock_table_elementContext _localctx = new Lock_table_elementContext(_ctx, State);
		EnterRule(_localctx, 474, RULE_lock_table_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3646; tableview_name();
			State = 3648;
			_la = _input.La(1);
			if (_la==PARTITION || _la==SUBPARTITION) {
				{
				State = 3647; partition_extension_clause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Lock_modeContext : ParserRuleContext {
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public ITerminalNode SHARE() { return GetToken(PlSqlParser.SHARE, 0); }
		public ITerminalNode EXCLUSIVE() { return GetToken(PlSqlParser.EXCLUSIVE, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public Lock_modeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lock_mode; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterLock_mode(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitLock_mode(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLock_mode(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Lock_modeContext lock_mode() {
		Lock_modeContext _localctx = new Lock_modeContext(_ctx, State);
		EnterRule(_localctx, 476, RULE_lock_mode);
		int _la;
		try {
			State = 3662;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,437,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3650; Match(ROW);
				State = 3651; Match(SHARE);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3652; Match(ROW);
				State = 3653; Match(EXCLUSIVE);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3654; Match(SHARE);
				State = 3656;
				_la = _input.La(1);
				if (_la==UPDATE) {
					{
					State = 3655; Match(UPDATE);
					}
				}

				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3658; Match(SHARE);
				State = 3659; Match(ROW);
				State = 3660; Match(EXCLUSIVE);
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3661; Match(EXCLUSIVE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class General_table_refContext : ParserRuleContext {
		public Dml_table_expression_clauseContext dml_table_expression_clause() {
			return GetRuleContext<Dml_table_expression_clauseContext>(0);
		}
		public ITerminalNode ONLY() { return GetToken(PlSqlParser.ONLY, 0); }
		public Table_aliasContext table_alias() {
			return GetRuleContext<Table_aliasContext>(0);
		}
		public General_table_refContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_general_table_ref; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterGeneral_table_ref(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitGeneral_table_ref(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGeneral_table_ref(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public General_table_refContext general_table_ref() {
		General_table_refContext _localctx = new General_table_refContext(_ctx, State);
		EnterRule(_localctx, 478, RULE_general_table_ref);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3670;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,438,_ctx) ) {
			case 1:
				{
				State = 3664; dml_table_expression_clause();
				}
				break;

			case 2:
				{
				State = 3665; Match(ONLY);
				State = 3666; Match(LEFT_PAREN);
				State = 3667; dml_table_expression_clause();
				State = 3668; Match(RIGHT_PAREN);
				}
				break;
			}
			State = 3673;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,439,_ctx) ) {
			case 1:
				{
				State = 3672; table_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Static_returning_clauseContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Into_clauseContext into_clause() {
			return GetRuleContext<Into_clauseContext>(0);
		}
		public ITerminalNode RETURNING() { return GetToken(PlSqlParser.RETURNING, 0); }
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public Static_returning_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_static_returning_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterStatic_returning_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitStatic_returning_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatic_returning_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Static_returning_clauseContext static_returning_clause() {
		Static_returning_clauseContext _localctx = new Static_returning_clauseContext(_ctx, State);
		EnterRule(_localctx, 480, RULE_static_returning_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3675;
			_la = _input.La(1);
			if ( !(_la==RETURN || _la==RETURNING) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 3676; expression();
			State = 3681;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3677; Match(COMMA);
				State = 3678; expression();
				}
				}
				State = 3683;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3684; into_clause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Error_logging_clauseContext : ParserRuleContext {
		public ITerminalNode LOG() { return GetToken(PlSqlParser.LOG, 0); }
		public ITerminalNode ERRORS() { return GetToken(PlSqlParser.ERRORS, 0); }
		public Error_logging_into_partContext error_logging_into_part() {
			return GetRuleContext<Error_logging_into_partContext>(0);
		}
		public Expression_wrapperContext expression_wrapper() {
			return GetRuleContext<Expression_wrapperContext>(0);
		}
		public Error_logging_reject_partContext error_logging_reject_part() {
			return GetRuleContext<Error_logging_reject_partContext>(0);
		}
		public Error_logging_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_error_logging_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterError_logging_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitError_logging_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitError_logging_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Error_logging_clauseContext error_logging_clause() {
		Error_logging_clauseContext _localctx = new Error_logging_clauseContext(_ctx, State);
		EnterRule(_localctx, 482, RULE_error_logging_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3686; Match(LOG);
			State = 3687; Match(ERRORS);
			State = 3689;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,441,_ctx) ) {
			case 1:
				{
				State = 3688; error_logging_into_part();
				}
				break;
			}
			State = 3692;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,442,_ctx) ) {
			case 1:
				{
				State = 3691; expression_wrapper();
				}
				break;
			}
			State = 3695;
			_la = _input.La(1);
			if (_la==REJECT) {
				{
				State = 3694; error_logging_reject_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Error_logging_into_partContext : ParserRuleContext {
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Error_logging_into_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_error_logging_into_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterError_logging_into_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitError_logging_into_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitError_logging_into_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Error_logging_into_partContext error_logging_into_part() {
		Error_logging_into_partContext _localctx = new Error_logging_into_partContext(_ctx, State);
		EnterRule(_localctx, 484, RULE_error_logging_into_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3697; Match(INTO);
			State = 3698; tableview_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Error_logging_reject_partContext : ParserRuleContext {
		public ITerminalNode REJECT() { return GetToken(PlSqlParser.REJECT, 0); }
		public ITerminalNode LIMIT() { return GetToken(PlSqlParser.LIMIT, 0); }
		public ITerminalNode UNLIMITED() { return GetToken(PlSqlParser.UNLIMITED, 0); }
		public Expression_wrapperContext expression_wrapper() {
			return GetRuleContext<Expression_wrapperContext>(0);
		}
		public Error_logging_reject_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_error_logging_reject_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterError_logging_reject_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitError_logging_reject_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitError_logging_reject_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Error_logging_reject_partContext error_logging_reject_part() {
		Error_logging_reject_partContext _localctx = new Error_logging_reject_partContext(_ctx, State);
		EnterRule(_localctx, 486, RULE_error_logging_reject_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3700; Match(REJECT);
			State = 3701; Match(LIMIT);
			State = 3704;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,444,_ctx) ) {
			case 1:
				{
				State = 3702; Match(UNLIMITED);
				}
				break;

			case 2:
				{
				State = 3703; expression_wrapper();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dml_table_expression_clauseContext : ParserRuleContext {
		public Table_collection_expressionContext table_collection_expression() {
			return GetRuleContext<Table_collection_expressionContext>(0);
		}
		public Select_statementContext select_statement() {
			return GetRuleContext<Select_statementContext>(0);
		}
		public Subquery_restriction_clauseContext subquery_restriction_clause() {
			return GetRuleContext<Subquery_restriction_clauseContext>(0);
		}
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public Sample_clauseContext sample_clause() {
			return GetRuleContext<Sample_clauseContext>(0);
		}
		public Dml_table_expression_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dml_table_expression_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDml_table_expression_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDml_table_expression_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDml_table_expression_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dml_table_expression_clauseContext dml_table_expression_clause() {
		Dml_table_expression_clauseContext _localctx = new Dml_table_expression_clauseContext(_ctx, State);
		EnterRule(_localctx, 488, RULE_dml_table_expression_clause);
		int _la;
		try {
			State = 3718;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,447,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3706; table_collection_expression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3707; Match(LEFT_PAREN);
				State = 3708; select_statement();
				State = 3710;
				_la = _input.La(1);
				if (_la==WITH) {
					{
					State = 3709; subquery_restriction_clause();
					}
				}

				State = 3712; Match(RIGHT_PAREN);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3714; tableview_name();
				State = 3716;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,446,_ctx) ) {
				case 1:
					{
					State = 3715; sample_clause();
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_collection_expressionContext : ParserRuleContext {
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public ITerminalNode THE() { return GetToken(PlSqlParser.THE, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Table_collection_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_collection_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTable_collection_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTable_collection_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_collection_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_collection_expressionContext table_collection_expression() {
		Table_collection_expressionContext _localctx = new Table_collection_expressionContext(_ctx, State);
		EnterRule(_localctx, 490, RULE_table_collection_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3720;
			_la = _input.La(1);
			if ( !(_la==TABLE || _la==THE) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 3733;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,449,_ctx) ) {
			case 1:
				{
				State = 3721; Match(LEFT_PAREN);
				State = 3722; subquery();
				State = 3723; Match(RIGHT_PAREN);
				}
				break;

			case 2:
				{
				State = 3725; Match(LEFT_PAREN);
				State = 3726; expression();
				State = 3727; Match(RIGHT_PAREN);
				State = 3731;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,448,_ctx) ) {
				case 1:
					{
					State = 3728; Match(LEFT_PAREN);
					State = 3729; Match(PLUS_SIGN);
					State = 3730; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subquery_restriction_clauseContext : ParserRuleContext {
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode READ() { return GetToken(PlSqlParser.READ, 0); }
		public ITerminalNode ONLY() { return GetToken(PlSqlParser.ONLY, 0); }
		public ITerminalNode CHECK() { return GetToken(PlSqlParser.CHECK, 0); }
		public ITerminalNode OPTION() { return GetToken(PlSqlParser.OPTION, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public Constraint_nameContext constraint_name() {
			return GetRuleContext<Constraint_nameContext>(0);
		}
		public Subquery_restriction_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subquery_restriction_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSubquery_restriction_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSubquery_restriction_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubquery_restriction_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subquery_restriction_clauseContext subquery_restriction_clause() {
		Subquery_restriction_clauseContext _localctx = new Subquery_restriction_clauseContext(_ctx, State);
		EnterRule(_localctx, 492, RULE_subquery_restriction_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3735; Match(WITH);
			State = 3744;
			switch (_input.La(1)) {
			case READ:
				{
				State = 3736; Match(READ);
				State = 3737; Match(ONLY);
				}
				break;
			case CHECK:
				{
				State = 3738; Match(CHECK);
				State = 3739; Match(OPTION);
				State = 3742;
				_la = _input.La(1);
				if (_la==CONSTRAINT) {
					{
					State = 3740; Match(CONSTRAINT);
					State = 3741; constraint_name();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sample_clauseContext : ParserRuleContext {
		public ITerminalNode SAMPLE() { return GetToken(PlSqlParser.SAMPLE, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode BLOCK() { return GetToken(PlSqlParser.BLOCK, 0); }
		public Seed_partContext seed_part() {
			return GetRuleContext<Seed_partContext>(0);
		}
		public Sample_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sample_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSample_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSample_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSample_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sample_clauseContext sample_clause() {
		Sample_clauseContext _localctx = new Sample_clauseContext(_ctx, State);
		EnterRule(_localctx, 494, RULE_sample_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3746; Match(SAMPLE);
			State = 3748;
			_la = _input.La(1);
			if (_la==BLOCK) {
				{
				State = 3747; Match(BLOCK);
				}
			}

			State = 3750; Match(LEFT_PAREN);
			State = 3751; expression();
			State = 3754;
			_la = _input.La(1);
			if (_la==COMMA) {
				{
				State = 3752; Match(COMMA);
				State = 3753; expression();
				}
			}

			State = 3756; Match(RIGHT_PAREN);
			State = 3758;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,454,_ctx) ) {
			case 1:
				{
				State = 3757; seed_part();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Seed_partContext : ParserRuleContext {
		public ITerminalNode SEED() { return GetToken(PlSqlParser.SEED, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Seed_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_seed_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSeed_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSeed_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSeed_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Seed_partContext seed_part() {
		Seed_partContext _localctx = new Seed_partContext(_ctx, State);
		EnterRule(_localctx, 496, RULE_seed_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3760; Match(SEED);
			State = 3761; Match(LEFT_PAREN);
			State = 3762; expression();
			State = 3763; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_expressionContext : ParserRuleContext {
		public ITerminalNode CURSOR() { return GetToken(PlSqlParser.CURSOR, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public ITerminalNode PERCENT_NOTFOUND() { return GetToken(PlSqlParser.PERCENT_NOTFOUND, 0); }
		public ITerminalNode PERCENT_FOUND() { return GetToken(PlSqlParser.PERCENT_FOUND, 0); }
		public ITerminalNode PERCENT_ISOPEN() { return GetToken(PlSqlParser.PERCENT_ISOPEN, 0); }
		public ITerminalNode PERCENT_ROWCOUNT() { return GetToken(PlSqlParser.PERCENT_ROWCOUNT, 0); }
		public Sql_cursor_expressionContext sql_cursor_expression() {
			return GetRuleContext<Sql_cursor_expressionContext>(0);
		}
		public Cursor_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCursor_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCursor_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_expressionContext cursor_expression() {
		Cursor_expressionContext _localctx = new Cursor_expressionContext(_ctx, State);
		EnterRule(_localctx, 498, RULE_cursor_expression);
		try {
			State = 3783;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,455,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3765; Match(CURSOR);
				State = 3766; Match(LEFT_PAREN);
				State = 3767; subquery();
				State = 3768; Match(RIGHT_PAREN);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3770; cursor_name();
				State = 3771; Match(PERCENT_NOTFOUND);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3773; cursor_name();
				State = 3774; Match(PERCENT_FOUND);
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3776; cursor_name();
				State = 3777; Match(PERCENT_ISOPEN);
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3779; cursor_name();
				State = 3780; Match(PERCENT_ROWCOUNT);
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 3782; sql_cursor_expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sql_cursor_expressionContext : ParserRuleContext {
		public ITerminalNode SQL_PERCENT_ROWCOUNT() { return GetToken(PlSqlParser.SQL_PERCENT_ROWCOUNT, 0); }
		public Sql_cursor_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sql_cursor_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSql_cursor_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSql_cursor_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSql_cursor_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sql_cursor_expressionContext sql_cursor_expression() {
		Sql_cursor_expressionContext _localctx = new Sql_cursor_expressionContext(_ctx, State);
		EnterRule(_localctx, 500, RULE_sql_cursor_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3785; Match(SQL_PERCENT_ROWCOUNT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Collection_assoc_expressionContext : ParserRuleContext {
		public Collection_nameContext collection_name() {
			return GetRuleContext<Collection_nameContext>(0);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Variable_nameContext variable_name() {
			return GetRuleContext<Variable_nameContext>(0);
		}
		public Collection_assoc_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collection_assoc_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCollection_assoc_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCollection_assoc_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollection_assoc_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Collection_assoc_expressionContext collection_assoc_expression() {
		Collection_assoc_expressionContext _localctx = new Collection_assoc_expressionContext(_ctx, State);
		EnterRule(_localctx, 502, RULE_collection_assoc_expression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3787; collection_name();
			State = 3794;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,456,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3788; Match(LEFT_PAREN);
					State = 3789; expression();
					State = 3790; Match(RIGHT_PAREN);
					}
					} 
				}
				State = 3796;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,456,_ctx);
			}
			State = 3799;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,457,_ctx) ) {
			case 1:
				{
				State = 3797; Match(PERIOD);
				State = 3798; variable_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Collection_type_expressionContext : ParserRuleContext {
		public Collection_assoc_expressionContext collection_assoc_expression() {
			return GetRuleContext<Collection_assoc_expressionContext>(0);
		}
		public ITerminalNode FIRST() { return GetToken(PlSqlParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(PlSqlParser.LAST, 0); }
		public ITerminalNode EXISTS() { return GetToken(PlSqlParser.EXISTS, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode PRIOR() { return GetToken(PlSqlParser.PRIOR, 0); }
		public ITerminalNode NEXT() { return GetToken(PlSqlParser.NEXT, 0); }
		public ITerminalNode COUNT() { return GetToken(PlSqlParser.COUNT, 0); }
		public ITerminalNode LIMIT() { return GetToken(PlSqlParser.LIMIT, 0); }
		public Collection_type_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collection_type_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCollection_type_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCollection_type_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollection_type_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Collection_type_expressionContext collection_type_expression() {
		Collection_type_expressionContext _localctx = new Collection_type_expressionContext(_ctx, State);
		EnterRule(_localctx, 504, RULE_collection_type_expression);
		try {
			State = 3839;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,458,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3801; collection_assoc_expression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3802; collection_assoc_expression();
				State = 3803; Match(PERIOD);
				State = 3804; Match(FIRST);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3806; collection_assoc_expression();
				State = 3807; Match(PERIOD);
				State = 3808; Match(LAST);
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3810; collection_assoc_expression();
				State = 3811; Match(PERIOD);
				State = 3812; Match(EXISTS);
				State = 3813; Match(LEFT_PAREN);
				State = 3814; expression();
				State = 3815; Match(RIGHT_PAREN);
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3817; collection_assoc_expression();
				State = 3818; Match(PERIOD);
				State = 3819; Match(PRIOR);
				State = 3820; Match(LEFT_PAREN);
				State = 3821; expression();
				State = 3822; Match(RIGHT_PAREN);
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 3824; collection_assoc_expression();
				State = 3825; Match(PERIOD);
				State = 3826; Match(NEXT);
				State = 3827; Match(LEFT_PAREN);
				State = 3828; expression();
				State = 3829; Match(RIGHT_PAREN);
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 3831; collection_assoc_expression();
				State = 3832; Match(PERIOD);
				State = 3833; Match(COUNT);
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 3835; collection_assoc_expression();
				State = 3836; Match(PERIOD);
				State = 3837; Match(LIMIT);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression_listContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Expression_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression_list; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterExpression_list(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitExpression_list(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression_listContext expression_list() {
		Expression_listContext _localctx = new Expression_listContext(_ctx, State);
		EnterRule(_localctx, 506, RULE_expression_list);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3841; Match(LEFT_PAREN);
			State = 3843;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MOD - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TO_NUMBER - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (LEFT_PAREN - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (PLUS_SIGN - 512)) | (1L << (MINUS_SIGN - 512)) | (1L << (BINDVAR - 512)) | (1L << (COLON - 512)) | (1L << (INTRODUCER - 512)))) != 0) || _la==REGULAR_ID) {
				{
				State = 3842; expression();
				}
			}

			State = 3849;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 3845; Match(COMMA);
				State = 3846; expression();
				}
				}
				State = 3851;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 3852; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ConditionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_condition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCondition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCondition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCondition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionContext condition() {
		ConditionContext _localctx = new ConditionContext(_ctx, State);
		EnterRule(_localctx, 508, RULE_condition);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3854; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Condition_wrapperContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Condition_wrapperContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_condition_wrapper; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCondition_wrapper(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCondition_wrapper(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCondition_wrapper(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Condition_wrapperContext condition_wrapper() {
		Condition_wrapperContext _localctx = new Condition_wrapperContext(_ctx, State);
		EnterRule(_localctx, 510, RULE_condition_wrapper);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3856; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public Logical_and_expressionContext logical_and_expression() {
			return GetRuleContext<Logical_and_expressionContext>(0);
		}
		public ITerminalNode[] OR() { return GetTokens(PlSqlParser.OR); }
		public ITerminalNode OR(int i) {
			return GetToken(PlSqlParser.OR, i);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(_ctx, State);
		EnterRule(_localctx, 512, RULE_expression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 3858; logical_and_expression();
			}
			State = 3863;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,461,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3859; Match(OR);
					State = 3860; expression();
					}
					} 
				}
				State = 3865;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,461,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression_wrapperContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Expression_wrapperContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression_wrapper; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterExpression_wrapper(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitExpression_wrapper(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression_wrapper(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression_wrapperContext expression_wrapper() {
		Expression_wrapperContext _localctx = new Expression_wrapperContext(_ctx, State);
		EnterRule(_localctx, 514, RULE_expression_wrapper);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3866; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Logical_and_expressionContext : ParserRuleContext {
		public Negated_expressionContext[] negated_expression() {
			return GetRuleContexts<Negated_expressionContext>();
		}
		public Negated_expressionContext negated_expression(int i) {
			return GetRuleContext<Negated_expressionContext>(i);
		}
		public ITerminalNode[] AND() { return GetTokens(PlSqlParser.AND); }
		public ITerminalNode AND(int i) {
			return GetToken(PlSqlParser.AND, i);
		}
		public Logical_and_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_logical_and_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterLogical_and_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitLogical_and_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLogical_and_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Logical_and_expressionContext logical_and_expression() {
		Logical_and_expressionContext _localctx = new Logical_and_expressionContext(_ctx, State);
		EnterRule(_localctx, 516, RULE_logical_and_expression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3868; negated_expression();
			State = 3873;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,462,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3869; Match(AND);
					State = 3870; negated_expression();
					}
					} 
				}
				State = 3875;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,462,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Negated_expressionContext : ParserRuleContext {
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public Negated_expressionContext negated_expression() {
			return GetRuleContext<Negated_expressionContext>(0);
		}
		public Equality_expressionContext equality_expression() {
			return GetRuleContext<Equality_expressionContext>(0);
		}
		public Negated_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_negated_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterNegated_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitNegated_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNegated_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Negated_expressionContext negated_expression() {
		Negated_expressionContext _localctx = new Negated_expressionContext(_ctx, State);
		EnterRule(_localctx, 518, RULE_negated_expression);
		try {
			State = 3879;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,463,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3876; Match(NOT);
				State = 3877; negated_expression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3878; equality_expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Equality_expressionContext : ParserRuleContext {
		public Collection_type_expressionContext collection_type_expression() {
			return GetRuleContext<Collection_type_expressionContext>(0);
		}
		public Multiset_expressionContext multiset_expression() {
			return GetRuleContext<Multiset_expressionContext>(0);
		}
		public ITerminalNode[] IS() { return GetTokens(PlSqlParser.IS); }
		public ITerminalNode IS(int i) {
			return GetToken(PlSqlParser.IS, i);
		}
		public ITerminalNode[] NULL() { return GetTokens(PlSqlParser.NULL); }
		public ITerminalNode NULL(int i) {
			return GetToken(PlSqlParser.NULL, i);
		}
		public ITerminalNode[] NAN() { return GetTokens(PlSqlParser.NAN); }
		public ITerminalNode NAN(int i) {
			return GetToken(PlSqlParser.NAN, i);
		}
		public ITerminalNode[] PRESENT() { return GetTokens(PlSqlParser.PRESENT); }
		public ITerminalNode PRESENT(int i) {
			return GetToken(PlSqlParser.PRESENT, i);
		}
		public ITerminalNode[] INFINITE() { return GetTokens(PlSqlParser.INFINITE); }
		public ITerminalNode INFINITE(int i) {
			return GetToken(PlSqlParser.INFINITE, i);
		}
		public ITerminalNode[] A_LETTER() { return GetTokens(PlSqlParser.A_LETTER); }
		public ITerminalNode A_LETTER(int i) {
			return GetToken(PlSqlParser.A_LETTER, i);
		}
		public ITerminalNode[] SET() { return GetTokens(PlSqlParser.SET); }
		public ITerminalNode SET(int i) {
			return GetToken(PlSqlParser.SET, i);
		}
		public ITerminalNode[] EMPTY() { return GetTokens(PlSqlParser.EMPTY); }
		public ITerminalNode EMPTY(int i) {
			return GetToken(PlSqlParser.EMPTY, i);
		}
		public ITerminalNode[] OF() { return GetTokens(PlSqlParser.OF); }
		public ITerminalNode OF(int i) {
			return GetToken(PlSqlParser.OF, i);
		}
		public Type_specContext[] type_spec() {
			return GetRuleContexts<Type_specContext>();
		}
		public Type_specContext type_spec(int i) {
			return GetRuleContext<Type_specContext>(i);
		}
		public ITerminalNode[] NOT() { return GetTokens(PlSqlParser.NOT); }
		public ITerminalNode NOT(int i) {
			return GetToken(PlSqlParser.NOT, i);
		}
		public ITerminalNode[] TYPE() { return GetTokens(PlSqlParser.TYPE); }
		public ITerminalNode TYPE(int i) {
			return GetToken(PlSqlParser.TYPE, i);
		}
		public ITerminalNode[] ONLY() { return GetTokens(PlSqlParser.ONLY); }
		public ITerminalNode ONLY(int i) {
			return GetToken(PlSqlParser.ONLY, i);
		}
		public Cursor_expressionContext cursor_expression() {
			return GetRuleContext<Cursor_expressionContext>(0);
		}
		public Equality_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equality_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterEquality_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitEquality_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEquality_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Equality_expressionContext equality_expression() {
		Equality_expressionContext _localctx = new Equality_expressionContext(_ctx, State);
		EnterRule(_localctx, 520, RULE_equality_expression);
		int _la;
		try {
			int _alt;
			State = 3920;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,470,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3881; collection_type_expression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 3882; multiset_expression();
				State = 3916;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,469,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 3883; Match(IS);
						State = 3885;
						_la = _input.La(1);
						if (_la==NOT) {
							{
							State = 3884; Match(NOT);
							}
						}

						State = 3912;
						switch (_input.La(1)) {
						case NULL:
							{
							State = 3887; Match(NULL);
							}
							break;
						case NAN:
							{
							State = 3888; Match(NAN);
							}
							break;
						case PRESENT:
							{
							State = 3889; Match(PRESENT);
							}
							break;
						case INFINITE:
							{
							State = 3890; Match(INFINITE);
							}
							break;
						case A_LETTER:
							{
							State = 3891; Match(A_LETTER);
							State = 3892; Match(SET);
							}
							break;
						case EMPTY:
							{
							State = 3893; Match(EMPTY);
							}
							break;
						case OF:
							{
							State = 3894; Match(OF);
							State = 3896;
							_la = _input.La(1);
							if (_la==TYPE) {
								{
								State = 3895; Match(TYPE);
								}
							}

							State = 3898; Match(LEFT_PAREN);
							State = 3900;
							_errHandler.Sync(this);
							switch ( Interpreter.AdaptivePredict(_input,466,_ctx) ) {
							case 1:
								{
								State = 3899; Match(ONLY);
								}
								break;
							}
							State = 3902; type_spec();
							State = 3907;
							_errHandler.Sync(this);
							_la = _input.La(1);
							while (_la==COMMA) {
								{
								{
								State = 3903; Match(COMMA);
								State = 3904; type_spec();
								}
								}
								State = 3909;
								_errHandler.Sync(this);
								_la = _input.La(1);
							}
							State = 3910; Match(RIGHT_PAREN);
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						} 
					}
					State = 3918;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,469,_ctx);
				}
				}
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3919; cursor_expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multiset_partContext : ParserRuleContext {
		public Collection_nameContext collection_name() {
			return GetRuleContext<Collection_nameContext>(0);
		}
		public Collection_assoc_expressionContext collection_assoc_expression() {
			return GetRuleContext<Collection_assoc_expressionContext>(0);
		}
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public Multiset_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiset_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMultiset_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMultiset_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiset_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multiset_partContext multiset_part() {
		Multiset_partContext _localctx = new Multiset_partContext(_ctx, State);
		EnterRule(_localctx, 522, RULE_multiset_part);
		try {
			State = 3925;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,471,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3922; collection_name();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3923; collection_assoc_expression();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3924; function_call();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multiset_expressionContext : ParserRuleContext {
		public Multiset_partContext[] multiset_part() {
			return GetRuleContexts<Multiset_partContext>();
		}
		public Multiset_partContext multiset_part(int i) {
			return GetRuleContext<Multiset_partContext>(i);
		}
		public ITerminalNode[] MULTISET() { return GetTokens(PlSqlParser.MULTISET); }
		public ITerminalNode MULTISET(int i) {
			return GetToken(PlSqlParser.MULTISET, i);
		}
		public ITerminalNode[] EXCEPT() { return GetTokens(PlSqlParser.EXCEPT); }
		public ITerminalNode EXCEPT(int i) {
			return GetToken(PlSqlParser.EXCEPT, i);
		}
		public ITerminalNode[] INTERSECT() { return GetTokens(PlSqlParser.INTERSECT); }
		public ITerminalNode INTERSECT(int i) {
			return GetToken(PlSqlParser.INTERSECT, i);
		}
		public ITerminalNode[] UNION() { return GetTokens(PlSqlParser.UNION); }
		public ITerminalNode UNION(int i) {
			return GetToken(PlSqlParser.UNION, i);
		}
		public ITerminalNode[] ALL() { return GetTokens(PlSqlParser.ALL); }
		public ITerminalNode ALL(int i) {
			return GetToken(PlSqlParser.ALL, i);
		}
		public ITerminalNode[] DISTINCT() { return GetTokens(PlSqlParser.DISTINCT); }
		public ITerminalNode DISTINCT(int i) {
			return GetToken(PlSqlParser.DISTINCT, i);
		}
		public Relational_expressionContext relational_expression() {
			return GetRuleContext<Relational_expressionContext>(0);
		}
		public Multiset_typeContext multiset_type() {
			return GetRuleContext<Multiset_typeContext>(0);
		}
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Multiset_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiset_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMultiset_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMultiset_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiset_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multiset_expressionContext multiset_expression() {
		Multiset_expressionContext _localctx = new Multiset_expressionContext(_ctx, State);
		EnterRule(_localctx, 524, RULE_multiset_expression);
		int _la;
		try {
			int _alt;
			State = 3950;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,477,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3927; multiset_part();
				State = 3934;
				_errHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 3928; Match(MULTISET);
						State = 3929;
						_la = _input.La(1);
						if ( !(_la==EXCEPT || _la==INTERSECT || _la==UNION) ) {
						_errHandler.RecoverInline(this);
						} else {
							Consume();
						}
						State = 3931;
						_errHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(_input,472,_ctx) ) {
						case 1:
							{
							State = 3930;
							_la = _input.La(1);
							if ( !(_la==ALL || _la==DISTINCT) ) {
							_errHandler.RecoverInline(this);
							} else {
								Consume();
							}
							}
							break;
						}
						State = 3933; multiset_part();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 3936;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,473,_ctx);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 3938; relational_expression();
				State = 3948;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,476,_ctx) ) {
				case 1:
					{
					State = 3940;
					_la = _input.La(1);
					if (_la==NOT) {
						{
						State = 3939; Match(NOT);
						}
					}

					State = 3942; multiset_type();
					State = 3944;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,475,_ctx) ) {
					case 1:
						{
						State = 3943; Match(OF);
						}
						break;
					}
					State = 3946; concatenation();
					}
					break;
				}
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multiset_typeContext : ParserRuleContext {
		public ITerminalNode MEMBER() { return GetToken(PlSqlParser.MEMBER, 0); }
		public ITerminalNode SUBMULTISET() { return GetToken(PlSqlParser.SUBMULTISET, 0); }
		public Multiset_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiset_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMultiset_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMultiset_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiset_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multiset_typeContext multiset_type() {
		Multiset_typeContext _localctx = new Multiset_typeContext(_ctx, State);
		EnterRule(_localctx, 526, RULE_multiset_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3952;
			_la = _input.La(1);
			if ( !(_la==MEMBER || _la==SUBMULTISET) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Relational_expressionContext : ParserRuleContext {
		public Compound_expressionContext[] compound_expression() {
			return GetRuleContexts<Compound_expressionContext>();
		}
		public Compound_expressionContext compound_expression(int i) {
			return GetRuleContext<Compound_expressionContext>(i);
		}
		public Not_equal_opContext[] not_equal_op() {
			return GetRuleContexts<Not_equal_opContext>();
		}
		public Not_equal_opContext not_equal_op(int i) {
			return GetRuleContext<Not_equal_opContext>(i);
		}
		public Less_than_or_equals_opContext[] less_than_or_equals_op() {
			return GetRuleContexts<Less_than_or_equals_opContext>();
		}
		public Less_than_or_equals_opContext less_than_or_equals_op(int i) {
			return GetRuleContext<Less_than_or_equals_opContext>(i);
		}
		public Greater_than_or_equals_opContext[] greater_than_or_equals_op() {
			return GetRuleContexts<Greater_than_or_equals_opContext>();
		}
		public Greater_than_or_equals_opContext greater_than_or_equals_op(int i) {
			return GetRuleContext<Greater_than_or_equals_opContext>(i);
		}
		public Relational_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relational_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRelational_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRelational_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelational_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Relational_expressionContext relational_expression() {
		Relational_expressionContext _localctx = new Relational_expressionContext(_ctx, State);
		EnterRule(_localctx, 528, RULE_relational_expression);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 3954; compound_expression();
			State = 3966;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,479,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 3961;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,478,_ctx) ) {
					case 1:
						{
						State = 3955; Match(EQUALS_OP);
						}
						break;

					case 2:
						{
						State = 3956; not_equal_op();
						}
						break;

					case 3:
						{
						State = 3957; Match(LESS_THAN_OP);
						}
						break;

					case 4:
						{
						State = 3958; Match(GREATER_THAN_OP);
						}
						break;

					case 5:
						{
						State = 3959; less_than_or_equals_op();
						}
						break;

					case 6:
						{
						State = 3960; greater_than_or_equals_op();
						}
						break;
					}
					State = 3963; compound_expression();
					}
					} 
				}
				State = 3968;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,479,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Compound_expressionContext : ParserRuleContext {
		public ConcatenationContext[] concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public In_elementsContext in_elements() {
			return GetRuleContext<In_elementsContext>(0);
		}
		public ITerminalNode BETWEEN() { return GetToken(PlSqlParser.BETWEEN, 0); }
		public Between_elementsContext between_elements() {
			return GetRuleContext<Between_elementsContext>(0);
		}
		public Like_typeContext like_type() {
			return GetRuleContext<Like_typeContext>(0);
		}
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public Like_escape_partContext like_escape_part() {
			return GetRuleContext<Like_escape_partContext>(0);
		}
		public Function_callContext function_call() {
			return GetRuleContext<Function_callContext>(0);
		}
		public Compound_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compound_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCompound_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCompound_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompound_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Compound_expressionContext compound_expression() {
		Compound_expressionContext _localctx = new Compound_expressionContext(_ctx, State);
		EnterRule(_localctx, 530, RULE_compound_expression);
		int _la;
		try {
			State = 3987;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,484,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3969; concatenation();
				State = 3984;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,483,_ctx) ) {
				case 1:
					{
					State = 3971;
					_la = _input.La(1);
					if (_la==NOT) {
						{
						State = 3970; Match(NOT);
						}
					}

					State = 3982;
					switch (_input.La(1)) {
					case IN:
						{
						State = 3973; Match(IN);
						State = 3974; in_elements();
						}
						break;
					case BETWEEN:
						{
						State = 3975; Match(BETWEEN);
						State = 3976; between_elements();
						}
						break;
					case LIKE:
					case LIKE2:
					case LIKE4:
					case LIKEC:
						{
						State = 3977; like_type();
						State = 3978; concatenation();
						State = 3980;
						_errHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(_input,481,_ctx) ) {
						case 1:
							{
							State = 3979; like_escape_part();
							}
							break;
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				}
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3986; function_call();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Like_typeContext : ParserRuleContext {
		public ITerminalNode LIKE() { return GetToken(PlSqlParser.LIKE, 0); }
		public ITerminalNode LIKEC() { return GetToken(PlSqlParser.LIKEC, 0); }
		public ITerminalNode LIKE2() { return GetToken(PlSqlParser.LIKE2, 0); }
		public ITerminalNode LIKE4() { return GetToken(PlSqlParser.LIKE4, 0); }
		public Like_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_like_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterLike_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitLike_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLike_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Like_typeContext like_type() {
		Like_typeContext _localctx = new Like_typeContext(_ctx, State);
		EnterRule(_localctx, 532, RULE_like_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3989;
			_la = _input.La(1);
			if ( !(((((_la - 207)) & ~0x3f) == 0 && ((1L << (_la - 207)) & ((1L << (LIKE - 207)) | (1L << (LIKE2 - 207)) | (1L << (LIKE4 - 207)) | (1L << (LIKEC - 207)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Like_escape_partContext : ParserRuleContext {
		public ITerminalNode ESCAPE() { return GetToken(PlSqlParser.ESCAPE, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Like_escape_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_like_escape_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterLike_escape_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitLike_escape_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLike_escape_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Like_escape_partContext like_escape_part() {
		Like_escape_partContext _localctx = new Like_escape_partContext(_ctx, State);
		EnterRule(_localctx, 534, RULE_like_escape_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3991; Match(ESCAPE);
			State = 3992; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class In_elementsContext : ParserRuleContext {
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Concatenation_wrapperContext[] concatenation_wrapper() {
			return GetRuleContexts<Concatenation_wrapperContext>();
		}
		public Concatenation_wrapperContext concatenation_wrapper(int i) {
			return GetRuleContext<Concatenation_wrapperContext>(i);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public General_elementContext general_element() {
			return GetRuleContext<General_elementContext>(0);
		}
		public In_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_in_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterIn_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitIn_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIn_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public In_elementsContext in_elements() {
		In_elementsContext _localctx = new In_elementsContext(_ctx, State);
		EnterRule(_localctx, 536, RULE_in_elements);
		int _la;
		try {
			State = 4012;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,486,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3994; Match(LEFT_PAREN);
				State = 3995; subquery();
				State = 3996; Match(RIGHT_PAREN);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3998; Match(LEFT_PAREN);
				State = 3999; concatenation_wrapper();
				State = 4004;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4000; Match(COMMA);
					State = 4001; concatenation_wrapper();
					}
					}
					State = 4006;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4007; Match(RIGHT_PAREN);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4009; constant();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4010; bind_variable();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4011; general_element();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Between_elementsContext : ParserRuleContext {
		public ConcatenationContext[] concatenation() {
			return GetRuleContexts<ConcatenationContext>();
		}
		public ConcatenationContext concatenation(int i) {
			return GetRuleContext<ConcatenationContext>(i);
		}
		public ITerminalNode AND() { return GetToken(PlSqlParser.AND, 0); }
		public Between_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_between_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterBetween_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitBetween_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBetween_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Between_elementsContext between_elements() {
		Between_elementsContext _localctx = new Between_elementsContext(_ctx, State);
		EnterRule(_localctx, 538, RULE_between_elements);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4014; concatenation();
			State = 4015; Match(AND);
			State = 4016; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConcatenationContext : ParserRuleContext {
		public Additive_expressionContext[] additive_expression() {
			return GetRuleContexts<Additive_expressionContext>();
		}
		public Additive_expressionContext additive_expression(int i) {
			return GetRuleContext<Additive_expressionContext>(i);
		}
		public Concatenation_opContext[] concatenation_op() {
			return GetRuleContexts<Concatenation_opContext>();
		}
		public Concatenation_opContext concatenation_op(int i) {
			return GetRuleContext<Concatenation_opContext>(i);
		}
		public ConcatenationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_concatenation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterConcatenation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitConcatenation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatenation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConcatenationContext concatenation() {
		ConcatenationContext _localctx = new ConcatenationContext(_ctx, State);
		EnterRule(_localctx, 540, RULE_concatenation);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4018; additive_expression();
			State = 4024;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,487,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 4019; concatenation_op();
					State = 4020; additive_expression();
					}
					} 
				}
				State = 4026;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,487,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Concatenation_wrapperContext : ParserRuleContext {
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public Concatenation_wrapperContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_concatenation_wrapper; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterConcatenation_wrapper(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitConcatenation_wrapper(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatenation_wrapper(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Concatenation_wrapperContext concatenation_wrapper() {
		Concatenation_wrapperContext _localctx = new Concatenation_wrapperContext(_ctx, State);
		EnterRule(_localctx, 542, RULE_concatenation_wrapper);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4027; concatenation();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Additive_expressionContext : ParserRuleContext {
		public Multiply_expressionContext[] multiply_expression() {
			return GetRuleContexts<Multiply_expressionContext>();
		}
		public Multiply_expressionContext multiply_expression(int i) {
			return GetRuleContext<Multiply_expressionContext>(i);
		}
		public Additive_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_additive_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAdditive_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAdditive_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditive_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Additive_expressionContext additive_expression() {
		Additive_expressionContext _localctx = new Additive_expressionContext(_ctx, State);
		EnterRule(_localctx, 544, RULE_additive_expression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4029; multiply_expression();
			State = 4034;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,488,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 4030;
					_la = _input.La(1);
					if ( !(_la==PLUS_SIGN || _la==MINUS_SIGN) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					State = 4031; multiply_expression();
					}
					} 
				}
				State = 4036;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,488,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multiply_expressionContext : ParserRuleContext {
		public Datetime_expressionContext[] datetime_expression() {
			return GetRuleContexts<Datetime_expressionContext>();
		}
		public Datetime_expressionContext datetime_expression(int i) {
			return GetRuleContext<Datetime_expressionContext>(i);
		}
		public ITerminalNode[] MOD() { return GetTokens(PlSqlParser.MOD); }
		public ITerminalNode MOD(int i) {
			return GetToken(PlSqlParser.MOD, i);
		}
		public Multiply_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiply_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMultiply_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMultiply_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiply_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multiply_expressionContext multiply_expression() {
		Multiply_expressionContext _localctx = new Multiply_expressionContext(_ctx, State);
		EnterRule(_localctx, 546, RULE_multiply_expression);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4037; datetime_expression();
			State = 4042;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,489,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 4038;
					_la = _input.La(1);
					if ( !(_la==MOD || _la==ASTERISK || _la==SOLIDUS) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					State = 4039; datetime_expression();
					}
					} 
				}
				State = 4044;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,489,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Datetime_expressionContext : ParserRuleContext {
		public Model_expressionContext model_expression() {
			return GetRuleContext<Model_expressionContext>(0);
		}
		public ITerminalNode AT() { return GetToken(PlSqlParser.AT, 0); }
		public Interval_expressionContext interval_expression() {
			return GetRuleContext<Interval_expressionContext>(0);
		}
		public ITerminalNode LOCAL() { return GetToken(PlSqlParser.LOCAL, 0); }
		public ITerminalNode TIME() { return GetToken(PlSqlParser.TIME, 0); }
		public ITerminalNode ZONE() { return GetToken(PlSqlParser.ZONE, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Datetime_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_datetime_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDatetime_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDatetime_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDatetime_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Datetime_expressionContext datetime_expression() {
		Datetime_expressionContext _localctx = new Datetime_expressionContext(_ctx, State);
		EnterRule(_localctx, 548, RULE_datetime_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4045; model_expression();
			State = 4054;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,491,_ctx) ) {
			case 1:
				{
				State = 4046; Match(AT);
				State = 4051;
				switch (_input.La(1)) {
				case LOCAL:
					{
					State = 4047; Match(LOCAL);
					}
					break;
				case TIME:
					{
					State = 4048; Match(TIME);
					State = 4049; Match(ZONE);
					State = 4050; concatenation_wrapper();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;

			case 2:
				{
				State = 4053; interval_expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Interval_expressionContext : ParserRuleContext {
		public ITerminalNode DAY() { return GetToken(PlSqlParser.DAY, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ITerminalNode SECOND() { return GetToken(PlSqlParser.SECOND, 0); }
		public Concatenation_wrapperContext[] concatenation_wrapper() {
			return GetRuleContexts<Concatenation_wrapperContext>();
		}
		public Concatenation_wrapperContext concatenation_wrapper(int i) {
			return GetRuleContext<Concatenation_wrapperContext>(i);
		}
		public ITerminalNode YEAR() { return GetToken(PlSqlParser.YEAR, 0); }
		public ITerminalNode MONTH() { return GetToken(PlSqlParser.MONTH, 0); }
		public Interval_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_interval_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterInterval_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitInterval_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInterval_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Interval_expressionContext interval_expression() {
		Interval_expressionContext _localctx = new Interval_expressionContext(_ctx, State);
		EnterRule(_localctx, 550, RULE_interval_expression);
		int _la;
		try {
			State = 4080;
			switch (_input.La(1)) {
			case DAY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4056; Match(DAY);
				State = 4061;
				_la = _input.La(1);
				if (_la==LEFT_PAREN) {
					{
					State = 4057; Match(LEFT_PAREN);
					State = 4058; concatenation_wrapper();
					State = 4059; Match(RIGHT_PAREN);
					}
				}

				State = 4063; Match(TO);
				State = 4064; Match(SECOND);
				State = 4069;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,493,_ctx) ) {
				case 1:
					{
					State = 4065; Match(LEFT_PAREN);
					State = 4066; concatenation_wrapper();
					State = 4067; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			case YEAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4071; Match(YEAR);
				State = 4076;
				_la = _input.La(1);
				if (_la==LEFT_PAREN) {
					{
					State = 4072; Match(LEFT_PAREN);
					State = 4073; concatenation_wrapper();
					State = 4074; Match(RIGHT_PAREN);
					}
				}

				State = 4078; Match(TO);
				State = 4079; Match(MONTH);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_expressionContext : ParserRuleContext {
		public Unary_expressionContext unary_expression() {
			return GetRuleContext<Unary_expressionContext>(0);
		}
		public Model_expression_elementContext model_expression_element() {
			return GetRuleContext<Model_expression_elementContext>(0);
		}
		public Model_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterModel_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitModel_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_expressionContext model_expression() {
		Model_expressionContext _localctx = new Model_expressionContext(_ctx, State);
		EnterRule(_localctx, 552, RULE_model_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4082; unary_expression();
			State = 4087;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,496,_ctx) ) {
			case 1:
				{
				State = 4083; Match(LEFT_BRACKET);
				State = 4084; model_expression_element();
				State = 4085; Match(RIGHT_BRACKET);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Model_expression_elementContext : ParserRuleContext {
		public ITerminalNode[] ANY() { return GetTokens(PlSqlParser.ANY); }
		public ITerminalNode ANY(int i) {
			return GetToken(PlSqlParser.ANY, i);
		}
		public Condition_wrapperContext[] condition_wrapper() {
			return GetRuleContexts<Condition_wrapperContext>();
		}
		public Condition_wrapperContext condition_wrapper(int i) {
			return GetRuleContext<Condition_wrapperContext>(i);
		}
		public Single_column_for_loopContext[] single_column_for_loop() {
			return GetRuleContexts<Single_column_for_loopContext>();
		}
		public Single_column_for_loopContext single_column_for_loop(int i) {
			return GetRuleContext<Single_column_for_loopContext>(i);
		}
		public Multi_column_for_loopContext multi_column_for_loop() {
			return GetRuleContext<Multi_column_for_loopContext>(0);
		}
		public Model_expression_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_model_expression_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterModel_expression_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitModel_expression_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitModel_expression_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Model_expression_elementContext model_expression_element() {
		Model_expression_elementContext _localctx = new Model_expression_elementContext(_ctx, State);
		EnterRule(_localctx, 554, RULE_model_expression_element);
		int _la;
		try {
			State = 4112;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,501,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4091;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,497,_ctx) ) {
				case 1:
					{
					State = 4089; Match(ANY);
					}
					break;

				case 2:
					{
					State = 4090; condition_wrapper();
					}
					break;
				}
				State = 4100;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4093; Match(COMMA);
					State = 4096;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,498,_ctx) ) {
					case 1:
						{
						State = 4094; Match(ANY);
						}
						break;

					case 2:
						{
						State = 4095; condition_wrapper();
						}
						break;
					}
					}
					}
					State = 4102;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4103; single_column_for_loop();
				State = 4108;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4104; Match(COMMA);
					State = 4105; single_column_for_loop();
					}
					}
					State = 4110;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4111; multi_column_for_loop();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Single_column_for_loopContext : ParserRuleContext {
		public ExpressionContext ex1;
		public ExpressionContext ex2;
		public ExpressionContext ex3;
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ITerminalNode FROM() { return GetToken(PlSqlParser.FROM, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public For_increment_decrement_typeContext for_increment_decrement_type() {
			return GetRuleContext<For_increment_decrement_typeContext>(0);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public For_like_partContext for_like_part() {
			return GetRuleContext<For_like_partContext>(0);
		}
		public Single_column_for_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_single_column_for_loop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSingle_column_for_loop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSingle_column_for_loop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingle_column_for_loop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Single_column_for_loopContext single_column_for_loop() {
		Single_column_for_loopContext _localctx = new Single_column_for_loopContext(_ctx, State);
		EnterRule(_localctx, 556, RULE_single_column_for_loop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4114; Match(FOR);
			State = 4115; column_name();
			State = 4128;
			switch (_input.La(1)) {
			case IN:
				{
				State = 4116; Match(IN);
				State = 4117; expression_list();
				}
				break;
			case FROM:
			case LIKE:
				{
				State = 4119;
				_la = _input.La(1);
				if (_la==LIKE) {
					{
					State = 4118; for_like_part();
					}
				}

				State = 4121; Match(FROM);
				State = 4122; _localctx.ex1 = expression();
				State = 4123; Match(TO);
				State = 4124; _localctx.ex2 = expression();
				State = 4125; for_increment_decrement_type();
				State = 4126; _localctx.ex3 = expression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_like_partContext : ParserRuleContext {
		public ITerminalNode LIKE() { return GetToken(PlSqlParser.LIKE, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public For_like_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_like_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFor_like_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFor_like_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_like_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_like_partContext for_like_part() {
		For_like_partContext _localctx = new For_like_partContext(_ctx, State);
		EnterRule(_localctx, 558, RULE_for_like_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4130; Match(LIKE);
			State = 4131; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class For_increment_decrement_typeContext : ParserRuleContext {
		public ITerminalNode INCREMENT() { return GetToken(PlSqlParser.INCREMENT, 0); }
		public ITerminalNode DECREMENT() { return GetToken(PlSqlParser.DECREMENT, 0); }
		public For_increment_decrement_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_for_increment_decrement_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFor_increment_decrement_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFor_increment_decrement_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFor_increment_decrement_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public For_increment_decrement_typeContext for_increment_decrement_type() {
		For_increment_decrement_typeContext _localctx = new For_increment_decrement_typeContext(_ctx, State);
		EnterRule(_localctx, 560, RULE_for_increment_decrement_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4133;
			_la = _input.La(1);
			if ( !(_la==DECREMENT || _la==INCREMENT) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Multi_column_for_loopContext : ParserRuleContext {
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Column_nameContext[] column_name() {
			return GetRuleContexts<Column_nameContext>();
		}
		public Column_nameContext column_name(int i) {
			return GetRuleContext<Column_nameContext>(i);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Expression_listContext[] expression_list() {
			return GetRuleContexts<Expression_listContext>();
		}
		public Expression_listContext expression_list(int i) {
			return GetRuleContext<Expression_listContext>(i);
		}
		public Multi_column_for_loopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multi_column_for_loop; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMulti_column_for_loop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMulti_column_for_loop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulti_column_for_loop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Multi_column_for_loopContext multi_column_for_loop() {
		Multi_column_for_loopContext _localctx = new Multi_column_for_loopContext(_ctx, State);
		EnterRule(_localctx, 562, RULE_multi_column_for_loop);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4135; Match(FOR);
			State = 4136; Match(LEFT_PAREN);
			State = 4137; column_name();
			State = 4142;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4138; Match(COMMA);
				State = 4139; column_name();
				}
				}
				State = 4144;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 4145; Match(RIGHT_PAREN);
			State = 4146; Match(IN);
			State = 4147; Match(LEFT_PAREN);
			State = 4160;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,506,_ctx) ) {
			case 1:
				{
				State = 4148; subquery();
				}
				break;

			case 2:
				{
				State = 4149; Match(LEFT_PAREN);
				State = 4150; expression_list();
				State = 4155;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4151; Match(COMMA);
					State = 4152; expression_list();
					}
					}
					State = 4157;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4158; Match(RIGHT_PAREN);
				}
				break;
			}
			State = 4162; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unary_expressionContext : ParserRuleContext {
		public Unary_expressionContext unary_expression() {
			return GetRuleContext<Unary_expressionContext>(0);
		}
		public ITerminalNode PRIOR() { return GetToken(PlSqlParser.PRIOR, 0); }
		public ITerminalNode CONNECT_BY_ROOT() { return GetToken(PlSqlParser.CONNECT_BY_ROOT, 0); }
		public ITerminalNode NEW() { return GetToken(PlSqlParser.NEW, 0); }
		public ITerminalNode DISTINCT() { return GetToken(PlSqlParser.DISTINCT, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Case_statementContext case_statement() {
			return GetRuleContext<Case_statementContext>(0);
		}
		public Quantified_expressionContext quantified_expression() {
			return GetRuleContext<Quantified_expressionContext>(0);
		}
		public Standard_functionContext standard_function() {
			return GetRuleContext<Standard_functionContext>(0);
		}
		public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		public Unary_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unary_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterUnary_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitUnary_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Unary_expressionContext unary_expression() {
		Unary_expressionContext _localctx = new Unary_expressionContext(_ctx, State);
		EnterRule(_localctx, 564, RULE_unary_expression);
		try {
			State = 4182;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,507,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4164; Match(MINUS_SIGN);
				State = 4165; unary_expression();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4166; Match(PLUS_SIGN);
				State = 4167; unary_expression();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4168; Match(PRIOR);
				State = 4169; unary_expression();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4170; Match(CONNECT_BY_ROOT);
				State = 4171; unary_expression();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4172; Match(NEW);
				State = 4173; unary_expression();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4174; Match(DISTINCT);
				State = 4175; unary_expression();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 4176; Match(ALL);
				State = 4177; unary_expression();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 4178; case_statement();
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 4179; quantified_expression();
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 4180; standard_function();
				}
				break;

			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 4181; atom();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Case_statementContext : ParserRuleContext {
		public Searched_case_statementContext searched_case_statement() {
			return GetRuleContext<Searched_case_statementContext>(0);
		}
		public Simple_case_statementContext simple_case_statement() {
			return GetRuleContext<Simple_case_statementContext>(0);
		}
		public Case_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_case_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCase_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCase_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCase_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Case_statementContext case_statement() {
		Case_statementContext _localctx = new Case_statementContext(_ctx, State);
		EnterRule(_localctx, 566, RULE_case_statement);
		try {
			State = 4186;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,508,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4184; searched_case_statement();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4185; simple_case_statement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Simple_case_statementContext : ParserRuleContext {
		public IToken ck1;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public ITerminalNode[] CASE() { return GetTokens(PlSqlParser.CASE); }
		public ITerminalNode CASE(int i) {
			return GetToken(PlSqlParser.CASE, i);
		}
		public Label_nameContext[] label_name() {
			return GetRuleContexts<Label_nameContext>();
		}
		public Label_nameContext label_name(int i) {
			return GetRuleContext<Label_nameContext>(i);
		}
		public Simple_case_when_partContext[] simple_case_when_part() {
			return GetRuleContexts<Simple_case_when_partContext>();
		}
		public Simple_case_when_partContext simple_case_when_part(int i) {
			return GetRuleContext<Simple_case_when_partContext>(i);
		}
		public Case_else_partContext case_else_part() {
			return GetRuleContext<Case_else_partContext>(0);
		}
		public Simple_case_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple_case_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSimple_case_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSimple_case_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimple_case_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Simple_case_statementContext simple_case_statement() {
		Simple_case_statementContext _localctx = new Simple_case_statementContext(_ctx, State);
		EnterRule(_localctx, 568, RULE_simple_case_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4189;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,509,_ctx) ) {
			case 1:
				{
				State = 4188; label_name();
				}
				break;
			}
			State = 4191; _localctx.ck1 = Match(CASE);
			State = 4192; expression();
			State = 4194;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 4193; simple_case_when_part();
				}
				}
				State = 4196;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WHEN );
			State = 4199;
			_la = _input.La(1);
			if (_la==ELSE) {
				{
				State = 4198; case_else_part();
				}
			}

			State = 4201; Match(END);
			State = 4203;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,512,_ctx) ) {
			case 1:
				{
				State = 4202; Match(CASE);
				}
				break;
			}
			State = 4206;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,513,_ctx) ) {
			case 1:
				{
				State = 4205; label_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Simple_case_when_partContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public Expression_wrapperContext[] expression_wrapper() {
			return GetRuleContexts<Expression_wrapperContext>();
		}
		public Expression_wrapperContext expression_wrapper(int i) {
			return GetRuleContext<Expression_wrapperContext>(i);
		}
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Simple_case_when_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple_case_when_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSimple_case_when_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSimple_case_when_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimple_case_when_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Simple_case_when_partContext simple_case_when_part() {
		Simple_case_when_partContext _localctx = new Simple_case_when_partContext(_ctx, State);
		EnterRule(_localctx, 570, RULE_simple_case_when_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4208; Match(WHEN);
			State = 4209; expression_wrapper();
			State = 4210; Match(THEN);
			State = 4213;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,514,_ctx) ) {
			case 1:
				{
				State = 4211; seq_of_statements();
				}
				break;

			case 2:
				{
				State = 4212; expression_wrapper();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Searched_case_statementContext : ParserRuleContext {
		public IToken ck1;
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public ITerminalNode[] CASE() { return GetTokens(PlSqlParser.CASE); }
		public ITerminalNode CASE(int i) {
			return GetToken(PlSqlParser.CASE, i);
		}
		public Label_nameContext[] label_name() {
			return GetRuleContexts<Label_nameContext>();
		}
		public Label_nameContext label_name(int i) {
			return GetRuleContext<Label_nameContext>(i);
		}
		public Searched_case_when_partContext[] searched_case_when_part() {
			return GetRuleContexts<Searched_case_when_partContext>();
		}
		public Searched_case_when_partContext searched_case_when_part(int i) {
			return GetRuleContext<Searched_case_when_partContext>(i);
		}
		public Case_else_partContext case_else_part() {
			return GetRuleContext<Case_else_partContext>(0);
		}
		public Searched_case_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searched_case_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSearched_case_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSearched_case_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSearched_case_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Searched_case_statementContext searched_case_statement() {
		Searched_case_statementContext _localctx = new Searched_case_statementContext(_ctx, State);
		EnterRule(_localctx, 572, RULE_searched_case_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4216;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,515,_ctx) ) {
			case 1:
				{
				State = 4215; label_name();
				}
				break;
			}
			State = 4218; _localctx.ck1 = Match(CASE);
			State = 4220;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 4219; searched_case_when_part();
				}
				}
				State = 4222;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==WHEN );
			State = 4225;
			_la = _input.La(1);
			if (_la==ELSE) {
				{
				State = 4224; case_else_part();
				}
			}

			State = 4227; Match(END);
			State = 4229;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,518,_ctx) ) {
			case 1:
				{
				State = 4228; Match(CASE);
				}
				break;
			}
			State = 4232;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,519,_ctx) ) {
			case 1:
				{
				State = 4231; label_name();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Searched_case_when_partContext : ParserRuleContext {
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public Condition_wrapperContext condition_wrapper() {
			return GetRuleContext<Condition_wrapperContext>(0);
		}
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Expression_wrapperContext expression_wrapper() {
			return GetRuleContext<Expression_wrapperContext>(0);
		}
		public Searched_case_when_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_searched_case_when_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSearched_case_when_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSearched_case_when_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSearched_case_when_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Searched_case_when_partContext searched_case_when_part() {
		Searched_case_when_partContext _localctx = new Searched_case_when_partContext(_ctx, State);
		EnterRule(_localctx, 574, RULE_searched_case_when_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4234; Match(WHEN);
			State = 4235; condition_wrapper();
			State = 4236; Match(THEN);
			State = 4239;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,520,_ctx) ) {
			case 1:
				{
				State = 4237; seq_of_statements();
				}
				break;

			case 2:
				{
				State = 4238; expression_wrapper();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Case_else_partContext : ParserRuleContext {
		public ITerminalNode ELSE() { return GetToken(PlSqlParser.ELSE, 0); }
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Expression_wrapperContext expression_wrapper() {
			return GetRuleContext<Expression_wrapperContext>(0);
		}
		public Case_else_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_case_else_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCase_else_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCase_else_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCase_else_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Case_else_partContext case_else_part() {
		Case_else_partContext _localctx = new Case_else_partContext(_ctx, State);
		EnterRule(_localctx, 576, RULE_case_else_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4241; Match(ELSE);
			State = 4244;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,521,_ctx) ) {
			case 1:
				{
				State = 4242; seq_of_statements();
				}
				break;

			case 2:
				{
				State = 4243; expression_wrapper();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomContext : ParserRuleContext {
		public Table_elementContext table_element() {
			return GetRuleContext<Table_elementContext>(0);
		}
		public Outer_join_signContext outer_join_sign() {
			return GetRuleContext<Outer_join_signContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public General_elementContext general_element() {
			return GetRuleContext<General_elementContext>(0);
		}
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Expression_or_vectorContext expression_or_vector() {
			return GetRuleContext<Expression_or_vectorContext>(0);
		}
		public Subquery_operation_partContext[] subquery_operation_part() {
			return GetRuleContexts<Subquery_operation_partContext>();
		}
		public Subquery_operation_partContext subquery_operation_part(int i) {
			return GetRuleContext<Subquery_operation_partContext>(i);
		}
		public Collection_type_expressionContext collection_type_expression() {
			return GetRuleContext<Collection_type_expressionContext>(0);
		}
		public AtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atom; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAtom(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAtom(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAtom(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AtomContext atom() {
		AtomContext _localctx = new AtomContext(_ctx, State);
		EnterRule(_localctx, 578, RULE_atom);
		try {
			int _alt;
			State = 4267;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,524,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4246; table_element();
				State = 4247; outer_join_sign();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4249; bind_variable();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4250; constant();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4251; general_element();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4252; Match(LEFT_PAREN);
				State = 4264;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,523,_ctx) ) {
				case 1:
					{
					State = 4253; subquery();
					State = 4254; Match(RIGHT_PAREN);
					State = 4258;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,522,_ctx);
					while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
						if ( _alt==1 ) {
							{
							{
							State = 4255; subquery_operation_part();
							}
							} 
						}
						State = 4260;
						_errHandler.Sync(this);
						_alt = Interpreter.AdaptivePredict(_input,522,_ctx);
					}
					}
					break;

				case 2:
					{
					State = 4261; expression_or_vector();
					State = 4262; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4266; collection_type_expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression_or_vectorContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Vector_exprContext vector_expr() {
			return GetRuleContext<Vector_exprContext>(0);
		}
		public Expression_or_vectorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression_or_vector; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterExpression_or_vector(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitExpression_or_vector(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression_or_vector(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression_or_vectorContext expression_or_vector() {
		Expression_or_vectorContext _localctx = new Expression_or_vectorContext(_ctx, State);
		EnterRule(_localctx, 580, RULE_expression_or_vector);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4269; expression();
			State = 4271;
			_la = _input.La(1);
			if (_la==COMMA) {
				{
				State = 4270; vector_expr();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Vector_exprContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Vector_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vector_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterVector_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitVector_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVector_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Vector_exprContext vector_expr() {
		Vector_exprContext _localctx = new Vector_exprContext(_ctx, State);
		EnterRule(_localctx, 582, RULE_vector_expr);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4273; Match(COMMA);
			State = 4274; expression();
			State = 4279;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4275; Match(COMMA);
				State = 4276; expression();
				}
				}
				State = 4281;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Quantified_expressionContext : ParserRuleContext {
		public ITerminalNode SOME() { return GetToken(PlSqlParser.SOME, 0); }
		public ITerminalNode EXISTS() { return GetToken(PlSqlParser.EXISTS, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode ANY() { return GetToken(PlSqlParser.ANY, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Quantified_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quantified_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterQuantified_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitQuantified_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuantified_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Quantified_expressionContext quantified_expression() {
		Quantified_expressionContext _localctx = new Quantified_expressionContext(_ctx, State);
		EnterRule(_localctx, 584, RULE_quantified_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4282;
			_la = _input.La(1);
			if ( !(_la==ALL || _la==ANY || _la==EXISTS || _la==SOME) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 4298;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,528,_ctx) ) {
			case 1:
				{
				State = 4283; Match(LEFT_PAREN);
				State = 4284; subquery();
				State = 4285; Match(RIGHT_PAREN);
				}
				break;

			case 2:
				{
				State = 4287; Match(LEFT_PAREN);
				State = 4288; expression();
				State = 4293;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4289; Match(COMMA);
					State = 4290; expression();
					}
					}
					State = 4295;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4296; Match(RIGHT_PAREN);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Plsql_type_conversionContext : ParserRuleContext {
		public ITerminalNode TO_CHAR() { return GetToken(PlSqlParser.TO_CHAR, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode TO_NUMBER() { return GetToken(PlSqlParser.TO_NUMBER, 0); }
		public Plsql_type_conversionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_plsql_type_conversion; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPlsql_type_conversion(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPlsql_type_conversion(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPlsql_type_conversion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Plsql_type_conversionContext plsql_type_conversion() {
		Plsql_type_conversionContext _localctx = new Plsql_type_conversionContext(_ctx, State);
		EnterRule(_localctx, 586, RULE_plsql_type_conversion);
		int _la;
		try {
			State = 4324;
			switch (_input.La(1)) {
			case TO_CHAR:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4300; Match(TO_CHAR);
				State = 4301; Match(LEFT_PAREN);
				State = 4302; expression();
				State = 4307;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4303; Match(COMMA);
					State = 4304; expression();
					}
					}
					State = 4309;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4310; Match(RIGHT_PAREN);
				}
				break;
			case TO_NUMBER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4312; Match(TO_NUMBER);
				State = 4313; Match(LEFT_PAREN);
				State = 4314; expression();
				State = 4319;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4315; Match(COMMA);
					State = 4316; expression();
					}
					}
					State = 4321;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4322; Match(RIGHT_PAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sql_type_conversionContext : ParserRuleContext {
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode CAST() { return GetToken(PlSqlParser.CAST, 0); }
		public ITerminalNode XMLCAST() { return GetToken(PlSqlParser.XMLCAST, 0); }
		public ITerminalNode MULTISET() { return GetToken(PlSqlParser.MULTISET, 0); }
		public SubqueryContext subquery() {
			return GetRuleContext<SubqueryContext>(0);
		}
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Plsql_type_conversionContext plsql_type_conversion() {
			return GetRuleContext<Plsql_type_conversionContext>(0);
		}
		public Sql_type_conversionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sql_type_conversion; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSql_type_conversion(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSql_type_conversion(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSql_type_conversion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sql_type_conversionContext sql_type_conversion() {
		Sql_type_conversionContext _localctx = new Sql_type_conversionContext(_ctx, State);
		EnterRule(_localctx, 588, RULE_sql_type_conversion);
		int _la;
		try {
			State = 4341;
			switch (_input.La(1)) {
			case CAST:
			case XMLCAST:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4326;
				_la = _input.La(1);
				if ( !(_la==CAST || _la==XMLCAST) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 4327; Match(LEFT_PAREN);
				State = 4334;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,532,_ctx) ) {
				case 1:
					{
					State = 4328; Match(MULTISET);
					State = 4329; Match(LEFT_PAREN);
					State = 4330; subquery();
					State = 4331; Match(RIGHT_PAREN);
					}
					break;

				case 2:
					{
					State = 4333; concatenation_wrapper();
					}
					break;
				}
				State = 4336; Match(AS);
				State = 4337; type_spec();
				State = 4338; Match(RIGHT_PAREN);
				}
				break;
			case TO_CHAR:
			case TO_NUMBER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4340; plsql_type_conversion();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_table_columnsContext : ParserRuleContext {
		public ITerminalNode COLUMNS() { return GetToken(PlSqlParser.COLUMNS, 0); }
		public Xml_table_columnContext[] xml_table_column() {
			return GetRuleContexts<Xml_table_columnContext>();
		}
		public Xml_table_columnContext xml_table_column(int i) {
			return GetRuleContext<Xml_table_columnContext>(i);
		}
		public Xml_table_columnsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_table_columns; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXml_table_columns(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXml_table_columns(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_table_columns(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_table_columnsContext xml_table_columns() {
		Xml_table_columnsContext _localctx = new Xml_table_columnsContext(_ctx, State);
		EnterRule(_localctx, 590, RULE_xml_table_columns);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4343; Match(COLUMNS);
			State = 4344; xml_table_column();
			State = 4349;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4345; Match(COMMA);
				State = 4346; xml_table_column();
				}
				}
				State = 4351;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_tableContext : ParserRuleContext {
		public ITerminalNode XMLTABLE() { return GetToken(PlSqlParser.XMLTABLE, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Xml_namespaces_clauseContext xml_namespaces_clause() {
			return GetRuleContext<Xml_namespaces_clauseContext>(0);
		}
		public Xml_passing_clauseContext xml_passing_clause() {
			return GetRuleContext<Xml_passing_clauseContext>(0);
		}
		public Xml_table_columnsContext xml_table_columns() {
			return GetRuleContext<Xml_table_columnsContext>(0);
		}
		public General_element_partContext general_element_part() {
			return GetRuleContext<General_element_partContext>(0);
		}
		public Xml_tableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_table; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXml_table(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXml_table(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_table(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_tableContext xml_table() {
		Xml_tableContext _localctx = new Xml_tableContext(_ctx, State);
		EnterRule(_localctx, 592, RULE_xml_table);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4352; Match(XMLTABLE);
			State = 4353; Match(LEFT_PAREN);
			State = 4357;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,535,_ctx) ) {
			case 1:
				{
				State = 4354; xml_namespaces_clause();
				State = 4355; Match(COMMA);
				}
				break;
			}
			State = 4359; concatenation_wrapper();
			State = 4361;
			_la = _input.La(1);
			if (_la==PASSING) {
				{
				State = 4360; xml_passing_clause();
				}
			}

			State = 4364;
			_la = _input.La(1);
			if (_la==COLUMNS) {
				{
				State = 4363; xml_table_columns();
				}
			}

			State = 4366; Match(RIGHT_PAREN);
			State = 4369;
			_la = _input.La(1);
			if (_la==PERIOD) {
				{
				State = 4367; Match(PERIOD);
				State = 4368; general_element_part();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Standard_functionContext : ParserRuleContext {
		public Over_clause_keywordContext over_clause_keyword() {
			return GetRuleContext<Over_clause_keywordContext>(0);
		}
		public Function_argument_analyticContext function_argument_analytic() {
			return GetRuleContext<Function_argument_analyticContext>(0);
		}
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public Regular_idContext regular_id() {
			return GetRuleContext<Regular_idContext>(0);
		}
		public Function_argument_modelingContext function_argument_modeling() {
			return GetRuleContext<Function_argument_modelingContext>(0);
		}
		public Using_clauseContext using_clause() {
			return GetRuleContext<Using_clauseContext>(0);
		}
		public ITerminalNode COUNT() { return GetToken(PlSqlParser.COUNT, 0); }
		public Concatenation_wrapperContext[] concatenation_wrapper() {
			return GetRuleContexts<Concatenation_wrapperContext>();
		}
		public Concatenation_wrapperContext concatenation_wrapper(int i) {
			return GetRuleContext<Concatenation_wrapperContext>(i);
		}
		public ITerminalNode DISTINCT() { return GetToken(PlSqlParser.DISTINCT, 0); }
		public ITerminalNode UNIQUE() { return GetToken(PlSqlParser.UNIQUE, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public Sql_type_conversionContext sql_type_conversion() {
			return GetRuleContext<Sql_type_conversionContext>(0);
		}
		public ITerminalNode CHR() { return GetToken(PlSqlParser.CHR, 0); }
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode NCHAR_CS() { return GetToken(PlSqlParser.NCHAR_CS, 0); }
		public ITerminalNode COLLECT() { return GetToken(PlSqlParser.COLLECT, 0); }
		public Collect_order_by_partContext collect_order_by_part() {
			return GetRuleContext<Collect_order_by_partContext>(0);
		}
		public Within_or_over_clause_keywordContext within_or_over_clause_keyword() {
			return GetRuleContext<Within_or_over_clause_keywordContext>(0);
		}
		public Function_argumentContext function_argument() {
			return GetRuleContext<Function_argumentContext>(0);
		}
		public Within_or_over_partContext[] within_or_over_part() {
			return GetRuleContexts<Within_or_over_partContext>();
		}
		public Within_or_over_partContext within_or_over_part(int i) {
			return GetRuleContext<Within_or_over_partContext>(i);
		}
		public ITerminalNode DECOMPOSE() { return GetToken(PlSqlParser.DECOMPOSE, 0); }
		public ITerminalNode CANONICAL() { return GetToken(PlSqlParser.CANONICAL, 0); }
		public ITerminalNode COMPATIBILITY() { return GetToken(PlSqlParser.COMPATIBILITY, 0); }
		public ITerminalNode EXTRACT() { return GetToken(PlSqlParser.EXTRACT, 0); }
		public ITerminalNode FROM() { return GetToken(PlSqlParser.FROM, 0); }
		public ITerminalNode FIRST_VALUE() { return GetToken(PlSqlParser.FIRST_VALUE, 0); }
		public ITerminalNode LAST_VALUE() { return GetToken(PlSqlParser.LAST_VALUE, 0); }
		public Respect_or_ignore_nullsContext respect_or_ignore_nulls() {
			return GetRuleContext<Respect_or_ignore_nullsContext>(0);
		}
		public Standard_prediction_function_keywordContext standard_prediction_function_keyword() {
			return GetRuleContext<Standard_prediction_function_keywordContext>(0);
		}
		public Expression_wrapperContext[] expression_wrapper() {
			return GetRuleContexts<Expression_wrapperContext>();
		}
		public Expression_wrapperContext expression_wrapper(int i) {
			return GetRuleContext<Expression_wrapperContext>(i);
		}
		public Cost_matrix_clauseContext cost_matrix_clause() {
			return GetRuleContext<Cost_matrix_clauseContext>(0);
		}
		public ITerminalNode MOD() { return GetToken(PlSqlParser.MOD, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode TRANSLATE() { return GetToken(PlSqlParser.TRANSLATE, 0); }
		public ITerminalNode CHAR_CS() { return GetToken(PlSqlParser.CHAR_CS, 0); }
		public ITerminalNode TREAT() { return GetToken(PlSqlParser.TREAT, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode REF() { return GetToken(PlSqlParser.REF, 0); }
		public ITerminalNode TRIM() { return GetToken(PlSqlParser.TRIM, 0); }
		public ITerminalNode LEADING() { return GetToken(PlSqlParser.LEADING, 0); }
		public ITerminalNode TRAILING() { return GetToken(PlSqlParser.TRAILING, 0); }
		public ITerminalNode BOTH() { return GetToken(PlSqlParser.BOTH, 0); }
		public ITerminalNode XMLAGG() { return GetToken(PlSqlParser.XMLAGG, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public General_element_partContext general_element_part() {
			return GetRuleContext<General_element_partContext>(0);
		}
		public Xml_multiuse_expression_elementContext[] xml_multiuse_expression_element() {
			return GetRuleContexts<Xml_multiuse_expression_elementContext>();
		}
		public Xml_multiuse_expression_elementContext xml_multiuse_expression_element(int i) {
			return GetRuleContext<Xml_multiuse_expression_elementContext>(i);
		}
		public ITerminalNode XMLCOLATTVAL() { return GetToken(PlSqlParser.XMLCOLATTVAL, 0); }
		public ITerminalNode XMLFOREST() { return GetToken(PlSqlParser.XMLFOREST, 0); }
		public ITerminalNode XMLELEMENT() { return GetToken(PlSqlParser.XMLELEMENT, 0); }
		public Xml_attributes_clauseContext xml_attributes_clause() {
			return GetRuleContext<Xml_attributes_clauseContext>(0);
		}
		public ITerminalNode ENTITYESCAPING() { return GetToken(PlSqlParser.ENTITYESCAPING, 0); }
		public ITerminalNode NOENTITYESCAPING() { return GetToken(PlSqlParser.NOENTITYESCAPING, 0); }
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ITerminalNode EVALNAME() { return GetToken(PlSqlParser.EVALNAME, 0); }
		public Column_aliasContext[] column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public ITerminalNode XMLEXISTS() { return GetToken(PlSqlParser.XMLEXISTS, 0); }
		public Xml_passing_clauseContext xml_passing_clause() {
			return GetRuleContext<Xml_passing_clauseContext>(0);
		}
		public ITerminalNode XMLPARSE() { return GetToken(PlSqlParser.XMLPARSE, 0); }
		public ITerminalNode DOCUMENT() { return GetToken(PlSqlParser.DOCUMENT, 0); }
		public ITerminalNode CONTENT() { return GetToken(PlSqlParser.CONTENT, 0); }
		public ITerminalNode WELLFORMED() { return GetToken(PlSqlParser.WELLFORMED, 0); }
		public ITerminalNode XMLPI() { return GetToken(PlSqlParser.XMLPI, 0); }
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public ITerminalNode XMLQUERY() { return GetToken(PlSqlParser.XMLQUERY, 0); }
		public ITerminalNode RETURNING() { return GetToken(PlSqlParser.RETURNING, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode EMPTY() { return GetToken(PlSqlParser.EMPTY, 0); }
		public ITerminalNode XMLROOT() { return GetToken(PlSqlParser.XMLROOT, 0); }
		public Xmlroot_param_version_partContext xmlroot_param_version_part() {
			return GetRuleContext<Xmlroot_param_version_partContext>(0);
		}
		public Xmlroot_param_standalone_partContext xmlroot_param_standalone_part() {
			return GetRuleContext<Xmlroot_param_standalone_partContext>(0);
		}
		public ITerminalNode XMLSERIALIZE() { return GetToken(PlSqlParser.XMLSERIALIZE, 0); }
		public Xmlserialize_param_enconding_partContext xmlserialize_param_enconding_part() {
			return GetRuleContext<Xmlserialize_param_enconding_partContext>(0);
		}
		public Xmlserialize_param_version_partContext xmlserialize_param_version_part() {
			return GetRuleContext<Xmlserialize_param_version_partContext>(0);
		}
		public Xmlserialize_param_ident_partContext xmlserialize_param_ident_part() {
			return GetRuleContext<Xmlserialize_param_ident_partContext>(0);
		}
		public ITerminalNode DEFAULTS() { return GetToken(PlSqlParser.DEFAULTS, 0); }
		public ITerminalNode HIDE() { return GetToken(PlSqlParser.HIDE, 0); }
		public ITerminalNode SHOW() { return GetToken(PlSqlParser.SHOW, 0); }
		public Xml_tableContext xml_table() {
			return GetRuleContext<Xml_tableContext>(0);
		}
		public Standard_functionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_standard_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterStandard_function(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitStandard_function(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStandard_function(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Standard_functionContext standard_function() {
		Standard_functionContext _localctx = new Standard_functionContext(_ctx, State);
		EnterRule(_localctx, 594, RULE_standard_function);
		int _la;
		try {
			int _alt;
			State = 4659;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,586,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4371; over_clause_keyword();
				State = 4372; function_argument_analytic();
				State = 4374;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,539,_ctx) ) {
				case 1:
					{
					State = 4373; over_clause();
					}
					break;
				}
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4376; regular_id();
				State = 4377; function_argument_modeling();
				State = 4379;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,540,_ctx) ) {
				case 1:
					{
					State = 4378; using_clause();
					}
					break;
				}
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4381; Match(COUNT);
				State = 4382; Match(LEFT_PAREN);
				State = 4388;
				switch (_input.La(1)) {
				case ASTERISK:
					{
					State = 4383; Match(ASTERISK);
					}
					break;
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ALL:
				case ALTER:
				case ANALYZE:
				case AND:
				case ANY:
				case ARRAY:
				case AS:
				case ASC:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BEGIN:
				case BETWEEN:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BREADTH:
				case BULK:
				case BY:
				case BYTE:
				case C_LETTER:
				case CACHE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CASE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHECK:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONNECT:
				case CONNECT_BY_ROOT:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CREATE:
				case CROSS:
				case CUBE:
				case CURRENT:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DATE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECLARE:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DEPTH:
				case DESC:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DISTINCT:
				case DOCUMENT:
				case DOUBLE:
				case DROP:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case ELSE:
				case ELSIF:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case END:
				case ENTITYESCAPING:
				case ERRORS:
				case ESCAPE:
				case EXCEPT:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXCLUSIVE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FALSE:
				case FETCH:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FOR:
				case FORALL:
				case FORCE:
				case FROM:
				case FULL:
				case FUNCTION:
				case GOTO:
				case GRANT:
				case GROUP:
				case GROUPING:
				case HASH:
				case HAVING:
				case HIDE:
				case HOUR:
				case IF:
				case IGNORE:
				case IMMEDIATE:
				case IN:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEX:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSERT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERSECT:
				case INTERVAL:
				case INTO:
				case INVALIDATE:
				case IS:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCK:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUS:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MOD:
				case MODE:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCACHE:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NOMAXVALUE:
				case NOMINVALUE:
				case NONE:
				case NOORDER:
				case NOSCHEMACHECK:
				case NOT:
				case NOWAIT:
				case NULL:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OF:
				case OFF:
				case OID:
				case OLD:
				case ON:
				case ONLY:
				case OPEN:
				case OPTION:
				case OR:
				case ORADATA:
				case ORDER:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PIVOT:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIOR:
				case PROCEDURE:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SEARCH:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELECT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHARE:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case SQL_PERCENT_ROWCOUNT:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TABLE:
				case THE:
				case THEN:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TO:
				case TO_CHAR:
				case TO_NUMBER:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRIM:
				case TRUE:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNION:
				case UNIQUE:
				case UNLIMITED:
				case UNPIVOT:
				case UNTIL:
				case UPDATE:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case USING:
				case VALIDATE:
				case VALUE:
				case VALUES:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHEN:
				case WHENEVER:
				case WHERE:
				case WHILE:
				case WITH:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case ROW_NUMBER:
				case SUM:
				case VARIANCE:
				case REGR_:
				case STDDEV:
				case VAR_:
				case COVAR_:
				case NATIONAL_CHAR_STRING_LIT:
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
				case CHAR_STRING:
				case DELIMITED_ID:
				case LEFT_PAREN:
				case PLUS_SIGN:
				case MINUS_SIGN:
				case BINDVAR:
				case COLON:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 4385;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,541,_ctx) ) {
					case 1:
						{
						State = 4384;
						_la = _input.La(1);
						if ( !(_la==ALL || _la==DISTINCT || _la==UNIQUE) ) {
						_errHandler.RecoverInline(this);
						} else {
							Consume();
						}
						}
						break;
					}
					State = 4387; concatenation_wrapper();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4390; Match(RIGHT_PAREN);
				State = 4392;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,543,_ctx) ) {
				case 1:
					{
					State = 4391; over_clause();
					}
					break;
				}
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 4394; sql_type_conversion();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 4395; Match(CHR);
				State = 4396; Match(LEFT_PAREN);
				State = 4397; concatenation_wrapper();
				State = 4398; Match(USING);
				State = 4399; Match(NCHAR_CS);
				State = 4400; Match(RIGHT_PAREN);
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 4402; Match(COLLECT);
				State = 4403; Match(LEFT_PAREN);
				State = 4405;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,544,_ctx) ) {
				case 1:
					{
					State = 4404;
					_la = _input.La(1);
					if ( !(_la==DISTINCT || _la==UNIQUE) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					}
					break;
				}
				State = 4407; concatenation_wrapper();
				State = 4409;
				_la = _input.La(1);
				if (_la==ORDER) {
					{
					State = 4408; collect_order_by_part();
					}
				}

				State = 4411; Match(RIGHT_PAREN);
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 4413; within_or_over_clause_keyword();
				State = 4414; function_argument();
				State = 4416;
				_errHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						State = 4415; within_or_over_part();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 4418;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,546,_ctx);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber );
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 4420; Match(DECOMPOSE);
				State = 4421; Match(LEFT_PAREN);
				State = 4422; concatenation_wrapper();
				State = 4424;
				_la = _input.La(1);
				if (_la==CANONICAL || _la==COMPATIBILITY) {
					{
					State = 4423;
					_la = _input.La(1);
					if ( !(_la==CANONICAL || _la==COMPATIBILITY) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					}
				}

				State = 4426; Match(RIGHT_PAREN);
				}
				break;

			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 4428; Match(EXTRACT);
				State = 4429; Match(LEFT_PAREN);
				State = 4430; regular_id();
				State = 4431; Match(FROM);
				State = 4432; concatenation_wrapper();
				State = 4433; Match(RIGHT_PAREN);
				}
				break;

			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 4435;
				_la = _input.La(1);
				if ( !(_la==FIRST_VALUE || _la==LAST_VALUE) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 4436; function_argument_analytic();
				State = 4438;
				_la = _input.La(1);
				if (_la==IGNORE || _la==RESPECT) {
					{
					State = 4437; respect_or_ignore_nulls();
					}
				}

				State = 4440; over_clause();
				}
				break;

			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 4442; standard_prediction_function_keyword();
				State = 4443; Match(LEFT_PAREN);
				State = 4444; expression_wrapper();
				State = 4449;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4445; Match(COMMA);
					State = 4446; expression_wrapper();
					}
					}
					State = 4451;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4453;
				_la = _input.La(1);
				if (_la==COST) {
					{
					State = 4452; cost_matrix_clause();
					}
				}

				State = 4456;
				_la = _input.La(1);
				if (_la==USING) {
					{
					State = 4455; using_clause();
					}
				}

				State = 4458; Match(RIGHT_PAREN);
				}
				break;

			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 4460; Match(MOD);
				State = 4461; Match(LEFT_PAREN);
				State = 4462; expression();
				State = 4463; Match(COMMA);
				State = 4464; expression();
				State = 4465; Match(RIGHT_PAREN);
				}
				break;

			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 4467; Match(TRANSLATE);
				State = 4468; Match(LEFT_PAREN);
				State = 4469; expression_wrapper();
				State = 4472;
				_la = _input.La(1);
				if (_la==USING) {
					{
					State = 4470; Match(USING);
					State = 4471;
					_la = _input.La(1);
					if ( !(_la==CHAR_CS || _la==NCHAR_CS) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					}
				}

				State = 4478;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4474; Match(COMMA);
					State = 4475; expression_wrapper();
					}
					}
					State = 4480;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4481; Match(RIGHT_PAREN);
				}
				break;

			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 4483; Match(TREAT);
				State = 4484; Match(LEFT_PAREN);
				State = 4485; expression_wrapper();
				State = 4486; Match(AS);
				State = 4488;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,554,_ctx) ) {
				case 1:
					{
					State = 4487; Match(REF);
					}
					break;
				}
				State = 4490; type_spec();
				State = 4491; Match(RIGHT_PAREN);
				}
				break;

			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 4493; Match(TRIM);
				State = 4494; Match(LEFT_PAREN);
				State = 4502;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,557,_ctx) ) {
				case 1:
					{
					State = 4496;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,555,_ctx) ) {
					case 1:
						{
						State = 4495;
						_la = _input.La(1);
						if ( !(_la==BOTH || _la==LEADING || _la==TRAILING) ) {
						_errHandler.RecoverInline(this);
						} else {
							Consume();
						}
						}
						break;
					}
					State = 4499;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,556,_ctx) ) {
					case 1:
						{
						State = 4498; expression_wrapper();
						}
						break;
					}
					State = 4501; Match(FROM);
					}
					break;
				}
				State = 4504; expression_wrapper();
				State = 4505; Match(RIGHT_PAREN);
				}
				break;

			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 4507; Match(XMLAGG);
				State = 4508; Match(LEFT_PAREN);
				State = 4509; expression_wrapper();
				State = 4511;
				_la = _input.La(1);
				if (_la==ORDER) {
					{
					State = 4510; order_by_clause();
					}
				}

				State = 4513; Match(RIGHT_PAREN);
				State = 4516;
				_la = _input.La(1);
				if (_la==PERIOD) {
					{
					State = 4514; Match(PERIOD);
					State = 4515; general_element_part();
					}
				}

				}
				break;

			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 4518;
				_la = _input.La(1);
				if ( !(_la==XMLCOLATTVAL || _la==XMLFOREST) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 4519; Match(LEFT_PAREN);
				State = 4520; xml_multiuse_expression_element();
				State = 4525;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4521; Match(COMMA);
					State = 4522; xml_multiuse_expression_element();
					}
					}
					State = 4527;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4528; Match(RIGHT_PAREN);
				State = 4531;
				_la = _input.La(1);
				if (_la==PERIOD) {
					{
					State = 4529; Match(PERIOD);
					State = 4530; general_element_part();
					}
				}

				}
				break;

			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 4533; Match(XMLELEMENT);
				State = 4534; Match(LEFT_PAREN);
				State = 4536;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,562,_ctx) ) {
				case 1:
					{
					State = 4535;
					_la = _input.La(1);
					if ( !(_la==ENTITYESCAPING || _la==NOENTITYESCAPING) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					}
					break;
				}
				State = 4539;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,563,_ctx) ) {
				case 1:
					{
					State = 4538;
					_la = _input.La(1);
					if ( !(_la==EVALNAME || _la==NAME) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					}
					break;
				}
				State = 4541; expression_wrapper();
				State = 4544;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,564,_ctx) ) {
				case 1:
					{
					State = 4542; Match(COMMA);
					State = 4543; xml_attributes_clause();
					}
					break;
				}
				State = 4553;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4546; Match(COMMA);
					State = 4547; expression_wrapper();
					State = 4549;
					_la = _input.La(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						State = 4548; column_alias();
						}
					}

					}
					}
					State = 4555;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4556; Match(RIGHT_PAREN);
				State = 4559;
				_la = _input.La(1);
				if (_la==PERIOD) {
					{
					State = 4557; Match(PERIOD);
					State = 4558; general_element_part();
					}
				}

				}
				break;

			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 4561; Match(XMLEXISTS);
				State = 4562; Match(LEFT_PAREN);
				State = 4563; expression_wrapper();
				State = 4565;
				_la = _input.La(1);
				if (_la==PASSING) {
					{
					State = 4564; xml_passing_clause();
					}
				}

				State = 4567; Match(RIGHT_PAREN);
				}
				break;

			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 4569; Match(XMLPARSE);
				State = 4570; Match(LEFT_PAREN);
				State = 4571;
				_la = _input.La(1);
				if ( !(_la==CONTENT || _la==DOCUMENT) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 4572; concatenation_wrapper();
				State = 4574;
				_la = _input.La(1);
				if (_la==WELLFORMED) {
					{
					State = 4573; Match(WELLFORMED);
					}
				}

				State = 4576; Match(RIGHT_PAREN);
				State = 4579;
				_la = _input.La(1);
				if (_la==PERIOD) {
					{
					State = 4577; Match(PERIOD);
					State = 4578; general_element_part();
					}
				}

				}
				break;

			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 4581; Match(XMLPI);
				State = 4582; Match(LEFT_PAREN);
				State = 4587;
				switch (_input.La(1)) {
				case NAME:
					{
					State = 4583; Match(NAME);
					State = 4584; id();
					}
					break;
				case EVALNAME:
					{
					State = 4585; Match(EVALNAME);
					State = 4586; concatenation_wrapper();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 4591;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 4589; Match(COMMA);
					State = 4590; concatenation_wrapper();
					}
				}

				State = 4593; Match(RIGHT_PAREN);
				State = 4596;
				_la = _input.La(1);
				if (_la==PERIOD) {
					{
					State = 4594; Match(PERIOD);
					State = 4595; general_element_part();
					}
				}

				}
				break;

			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 4598; Match(XMLQUERY);
				State = 4599; Match(LEFT_PAREN);
				State = 4600; concatenation_wrapper();
				State = 4602;
				_la = _input.La(1);
				if (_la==PASSING) {
					{
					State = 4601; xml_passing_clause();
					}
				}

				State = 4604; Match(RETURNING);
				State = 4605; Match(CONTENT);
				State = 4609;
				_la = _input.La(1);
				if (_la==NULL) {
					{
					State = 4606; Match(NULL);
					State = 4607; Match(ON);
					State = 4608; Match(EMPTY);
					}
				}

				State = 4611; Match(RIGHT_PAREN);
				State = 4614;
				_la = _input.La(1);
				if (_la==PERIOD) {
					{
					State = 4612; Match(PERIOD);
					State = 4613; general_element_part();
					}
				}

				}
				break;

			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 4616; Match(XMLROOT);
				State = 4617; Match(LEFT_PAREN);
				State = 4618; concatenation_wrapper();
				State = 4621;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,577,_ctx) ) {
				case 1:
					{
					State = 4619; Match(COMMA);
					State = 4620; xmlroot_param_version_part();
					}
					break;
				}
				State = 4625;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 4623; Match(COMMA);
					State = 4624; xmlroot_param_standalone_part();
					}
				}

				State = 4627; Match(RIGHT_PAREN);
				State = 4630;
				_la = _input.La(1);
				if (_la==PERIOD) {
					{
					State = 4628; Match(PERIOD);
					State = 4629; general_element_part();
					}
				}

				}
				break;

			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 4632; Match(XMLSERIALIZE);
				State = 4633; Match(LEFT_PAREN);
				State = 4634;
				_la = _input.La(1);
				if ( !(_la==CONTENT || _la==DOCUMENT) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 4635; concatenation_wrapper();
				State = 4638;
				_la = _input.La(1);
				if (_la==AS) {
					{
					State = 4636; Match(AS);
					State = 4637; type_spec();
					}
				}

				State = 4641;
				_la = _input.La(1);
				if (_la==ENCODING) {
					{
					State = 4640; xmlserialize_param_enconding_part();
					}
				}

				State = 4644;
				_la = _input.La(1);
				if (_la==VERSION) {
					{
					State = 4643; xmlserialize_param_version_part();
					}
				}

				State = 4647;
				_la = _input.La(1);
				if (_la==INDENT || _la==NO) {
					{
					State = 4646; xmlserialize_param_ident_part();
					}
				}

				State = 4651;
				_la = _input.La(1);
				if (_la==HIDE || _la==SHOW) {
					{
					State = 4649;
					_la = _input.La(1);
					if ( !(_la==HIDE || _la==SHOW) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					State = 4650; Match(DEFAULTS);
					}
				}

				State = 4653; Match(RIGHT_PAREN);
				State = 4656;
				_la = _input.La(1);
				if (_la==PERIOD) {
					{
					State = 4654; Match(PERIOD);
					State = 4655; general_element_part();
					}
				}

				}
				break;

			case 25:
				EnterOuterAlt(_localctx, 25);
				{
				State = 4658; xml_table();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Over_clause_keywordContext : ParserRuleContext {
		public ITerminalNode AVG() { return GetToken(PlSqlParser.AVG, 0); }
		public ITerminalNode CORR() { return GetToken(PlSqlParser.CORR, 0); }
		public ITerminalNode LAG() { return GetToken(PlSqlParser.LAG, 0); }
		public ITerminalNode LEAD() { return GetToken(PlSqlParser.LEAD, 0); }
		public ITerminalNode MAX() { return GetToken(PlSqlParser.MAX, 0); }
		public ITerminalNode MEDIAN() { return GetToken(PlSqlParser.MEDIAN, 0); }
		public ITerminalNode MIN() { return GetToken(PlSqlParser.MIN, 0); }
		public ITerminalNode NTILE() { return GetToken(PlSqlParser.NTILE, 0); }
		public ITerminalNode RATIO_TO_REPORT() { return GetToken(PlSqlParser.RATIO_TO_REPORT, 0); }
		public ITerminalNode ROW_NUMBER() { return GetToken(PlSqlParser.ROW_NUMBER, 0); }
		public ITerminalNode SUM() { return GetToken(PlSqlParser.SUM, 0); }
		public ITerminalNode VARIANCE() { return GetToken(PlSqlParser.VARIANCE, 0); }
		public ITerminalNode REGR_() { return GetToken(PlSqlParser.REGR_, 0); }
		public ITerminalNode STDDEV() { return GetToken(PlSqlParser.STDDEV, 0); }
		public ITerminalNode VAR_() { return GetToken(PlSqlParser.VAR_, 0); }
		public ITerminalNode COVAR_() { return GetToken(PlSqlParser.COVAR_, 0); }
		public Over_clause_keywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_over_clause_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterOver_clause_keyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitOver_clause_keyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOver_clause_keyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Over_clause_keywordContext over_clause_keyword() {
		Over_clause_keywordContext _localctx = new Over_clause_keywordContext(_ctx, State);
		EnterRule(_localctx, 596, RULE_over_clause_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4661;
			_la = _input.La(1);
			if ( !(((((_la - 480)) & ~0x3f) == 0 && ((1L << (_la - 480)) & ((1L << (AVG - 480)) | (1L << (CORR - 480)) | (1L << (LAG - 480)) | (1L << (LEAD - 480)) | (1L << (MAX - 480)) | (1L << (MEDIAN - 480)) | (1L << (MIN - 480)) | (1L << (NTILE - 480)) | (1L << (RATIO_TO_REPORT - 480)) | (1L << (ROW_NUMBER - 480)) | (1L << (SUM - 480)) | (1L << (VARIANCE - 480)) | (1L << (REGR_ - 480)) | (1L << (STDDEV - 480)) | (1L << (VAR_ - 480)) | (1L << (COVAR_ - 480)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Within_or_over_clause_keywordContext : ParserRuleContext {
		public ITerminalNode CUME_DIST() { return GetToken(PlSqlParser.CUME_DIST, 0); }
		public ITerminalNode DENSE_RANK() { return GetToken(PlSqlParser.DENSE_RANK, 0); }
		public ITerminalNode LISTAGG() { return GetToken(PlSqlParser.LISTAGG, 0); }
		public ITerminalNode PERCENT_RANK() { return GetToken(PlSqlParser.PERCENT_RANK, 0); }
		public ITerminalNode PERCENTILE_CONT() { return GetToken(PlSqlParser.PERCENTILE_CONT, 0); }
		public ITerminalNode PERCENTILE_DISC() { return GetToken(PlSqlParser.PERCENTILE_DISC, 0); }
		public ITerminalNode RANK() { return GetToken(PlSqlParser.RANK, 0); }
		public Within_or_over_clause_keywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_within_or_over_clause_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterWithin_or_over_clause_keyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitWithin_or_over_clause_keyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithin_or_over_clause_keyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Within_or_over_clause_keywordContext within_or_over_clause_keyword() {
		Within_or_over_clause_keywordContext _localctx = new Within_or_over_clause_keywordContext(_ctx, State);
		EnterRule(_localctx, 598, RULE_within_or_over_clause_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4663;
			_la = _input.La(1);
			if ( !(((((_la - 473)) & ~0x3f) == 0 && ((1L << (_la - 473)) & ((1L << (CUME_DIST - 473)) | (1L << (DENSE_RANK - 473)) | (1L << (LISTAGG - 473)) | (1L << (PERCENT_RANK - 473)) | (1L << (PERCENTILE_CONT - 473)) | (1L << (PERCENTILE_DISC - 473)) | (1L << (RANK - 473)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Standard_prediction_function_keywordContext : ParserRuleContext {
		public ITerminalNode PREDICTION() { return GetToken(PlSqlParser.PREDICTION, 0); }
		public ITerminalNode PREDICTION_BOUNDS() { return GetToken(PlSqlParser.PREDICTION_BOUNDS, 0); }
		public ITerminalNode PREDICTION_COST() { return GetToken(PlSqlParser.PREDICTION_COST, 0); }
		public ITerminalNode PREDICTION_DETAILS() { return GetToken(PlSqlParser.PREDICTION_DETAILS, 0); }
		public ITerminalNode PREDICTION_PROBABILITY() { return GetToken(PlSqlParser.PREDICTION_PROBABILITY, 0); }
		public ITerminalNode PREDICTION_SET() { return GetToken(PlSqlParser.PREDICTION_SET, 0); }
		public Standard_prediction_function_keywordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_standard_prediction_function_keyword; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterStandard_prediction_function_keyword(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitStandard_prediction_function_keyword(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStandard_prediction_function_keyword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Standard_prediction_function_keywordContext standard_prediction_function_keyword() {
		Standard_prediction_function_keywordContext _localctx = new Standard_prediction_function_keywordContext(_ctx, State);
		EnterRule(_localctx, 600, RULE_standard_prediction_function_keyword);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4665;
			_la = _input.La(1);
			if ( !(((((_la - 467)) & ~0x3f) == 0 && ((1L << (_la - 467)) & ((1L << (PREDICTION - 467)) | (1L << (PREDICTION_BOUNDS - 467)) | (1L << (PREDICTION_COST - 467)) | (1L << (PREDICTION_DETAILS - 467)) | (1L << (PREDICTION_PROBABILITY - 467)) | (1L << (PREDICTION_SET - 467)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Over_clauseContext : ParserRuleContext {
		public ITerminalNode OVER() { return GetToken(PlSqlParser.OVER, 0); }
		public Query_partition_clauseContext query_partition_clause() {
			return GetRuleContext<Query_partition_clauseContext>(0);
		}
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public Windowing_clauseContext windowing_clause() {
			return GetRuleContext<Windowing_clauseContext>(0);
		}
		public Over_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_over_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterOver_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitOver_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOver_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Over_clauseContext over_clause() {
		Over_clauseContext _localctx = new Over_clauseContext(_ctx, State);
		EnterRule(_localctx, 602, RULE_over_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4667; Match(OVER);
			State = 4668; Match(LEFT_PAREN);
			State = 4670;
			_la = _input.La(1);
			if (_la==PARTITION) {
				{
				State = 4669; query_partition_clause();
				}
			}

			State = 4676;
			_la = _input.La(1);
			if (_la==ORDER) {
				{
				State = 4672; order_by_clause();
				State = 4674;
				_la = _input.La(1);
				if (_la==RANGE || _la==ROWS) {
					{
					State = 4673; windowing_clause();
					}
				}

				}
			}

			State = 4678; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Windowing_clauseContext : ParserRuleContext {
		public Windowing_typeContext windowing_type() {
			return GetRuleContext<Windowing_typeContext>(0);
		}
		public ITerminalNode BETWEEN() { return GetToken(PlSqlParser.BETWEEN, 0); }
		public Windowing_elementsContext[] windowing_elements() {
			return GetRuleContexts<Windowing_elementsContext>();
		}
		public Windowing_elementsContext windowing_elements(int i) {
			return GetRuleContext<Windowing_elementsContext>(i);
		}
		public ITerminalNode AND() { return GetToken(PlSqlParser.AND, 0); }
		public Windowing_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_windowing_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterWindowing_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitWindowing_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWindowing_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Windowing_clauseContext windowing_clause() {
		Windowing_clauseContext _localctx = new Windowing_clauseContext(_ctx, State);
		EnterRule(_localctx, 604, RULE_windowing_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4680; windowing_type();
			State = 4687;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,590,_ctx) ) {
			case 1:
				{
				State = 4681; Match(BETWEEN);
				State = 4682; windowing_elements();
				State = 4683; Match(AND);
				State = 4684; windowing_elements();
				}
				break;

			case 2:
				{
				State = 4686; windowing_elements();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Windowing_typeContext : ParserRuleContext {
		public ITerminalNode ROWS() { return GetToken(PlSqlParser.ROWS, 0); }
		public ITerminalNode RANGE() { return GetToken(PlSqlParser.RANGE, 0); }
		public Windowing_typeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_windowing_type; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterWindowing_type(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitWindowing_type(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWindowing_type(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Windowing_typeContext windowing_type() {
		Windowing_typeContext _localctx = new Windowing_typeContext(_ctx, State);
		EnterRule(_localctx, 606, RULE_windowing_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4689;
			_la = _input.La(1);
			if ( !(_la==RANGE || _la==ROWS) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Windowing_elementsContext : ParserRuleContext {
		public ITerminalNode UNBOUNDED() { return GetToken(PlSqlParser.UNBOUNDED, 0); }
		public ITerminalNode PRECEDING() { return GetToken(PlSqlParser.PRECEDING, 0); }
		public ITerminalNode CURRENT() { return GetToken(PlSqlParser.CURRENT, 0); }
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public ITerminalNode FOLLOWING() { return GetToken(PlSqlParser.FOLLOWING, 0); }
		public Windowing_elementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_windowing_elements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterWindowing_elements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitWindowing_elements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWindowing_elements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Windowing_elementsContext windowing_elements() {
		Windowing_elementsContext _localctx = new Windowing_elementsContext(_ctx, State);
		EnterRule(_localctx, 608, RULE_windowing_elements);
		int _la;
		try {
			State = 4698;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,591,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4691; Match(UNBOUNDED);
				State = 4692; Match(PRECEDING);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4693; Match(CURRENT);
				State = 4694; Match(ROW);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4695; concatenation_wrapper();
				State = 4696;
				_la = _input.La(1);
				if ( !(_la==FOLLOWING || _la==PRECEDING) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Using_clauseContext : ParserRuleContext {
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public Using_elementContext[] using_element() {
			return GetRuleContexts<Using_elementContext>();
		}
		public Using_elementContext using_element(int i) {
			return GetRuleContext<Using_elementContext>(i);
		}
		public Using_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_using_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterUsing_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitUsing_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsing_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Using_clauseContext using_clause() {
		Using_clauseContext _localctx = new Using_clauseContext(_ctx, State);
		EnterRule(_localctx, 610, RULE_using_clause);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 4700; Match(USING);
			State = 4710;
			switch (_input.La(1)) {
			case ASTERISK:
				{
				State = 4701; Match(ASTERISK);
				}
				break;
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MOD:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TO_NUMBER:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case NATIONAL_CHAR_STRING_LIT:
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
			case CHAR_STRING:
			case DELIMITED_ID:
			case LEFT_PAREN:
			case PLUS_SIGN:
			case MINUS_SIGN:
			case BINDVAR:
			case COLON:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 4702; using_element();
				State = 4707;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,592,_ctx);
				while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1 ) {
						{
						{
						State = 4703; Match(COMMA);
						State = 4704; using_element();
						}
						} 
					}
					State = 4709;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,592,_ctx);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Using_elementContext : ParserRuleContext {
		public Select_list_elementsContext select_list_elements() {
			return GetRuleContext<Select_list_elementsContext>(0);
		}
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode OUT() { return GetToken(PlSqlParser.OUT, 0); }
		public Column_aliasContext column_alias() {
			return GetRuleContext<Column_aliasContext>(0);
		}
		public Using_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_using_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterUsing_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitUsing_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUsing_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Using_elementContext using_element() {
		Using_elementContext _localctx = new Using_elementContext(_ctx, State);
		EnterRule(_localctx, 612, RULE_using_element);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4717;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,595,_ctx) ) {
			case 1:
				{
				State = 4712; Match(IN);
				State = 4714;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,594,_ctx) ) {
				case 1:
					{
					State = 4713; Match(OUT);
					}
					break;
				}
				}
				break;

			case 2:
				{
				State = 4716; Match(OUT);
				}
				break;
			}
			State = 4719; select_list_elements();
			State = 4721;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,596,_ctx) ) {
			case 1:
				{
				State = 4720; column_alias();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Collect_order_by_partContext : ParserRuleContext {
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Collect_order_by_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collect_order_by_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCollect_order_by_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCollect_order_by_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollect_order_by_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Collect_order_by_partContext collect_order_by_part() {
		Collect_order_by_partContext _localctx = new Collect_order_by_partContext(_ctx, State);
		EnterRule(_localctx, 614, RULE_collect_order_by_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4723; Match(ORDER);
			State = 4724; Match(BY);
			State = 4725; concatenation_wrapper();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Within_or_over_partContext : ParserRuleContext {
		public ITerminalNode WITHIN() { return GetToken(PlSqlParser.WITHIN, 0); }
		public ITerminalNode GROUP() { return GetToken(PlSqlParser.GROUP, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public Within_or_over_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_within_or_over_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterWithin_or_over_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitWithin_or_over_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithin_or_over_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Within_or_over_partContext within_or_over_part() {
		Within_or_over_partContext _localctx = new Within_or_over_partContext(_ctx, State);
		EnterRule(_localctx, 616, RULE_within_or_over_part);
		try {
			State = 4734;
			switch (_input.La(1)) {
			case WITHIN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4727; Match(WITHIN);
				State = 4728; Match(GROUP);
				State = 4729; Match(LEFT_PAREN);
				State = 4730; order_by_clause();
				State = 4731; Match(RIGHT_PAREN);
				}
				break;
			case OVER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4733; over_clause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cost_matrix_clauseContext : ParserRuleContext {
		public ITerminalNode COST() { return GetToken(PlSqlParser.COST, 0); }
		public ITerminalNode MODEL() { return GetToken(PlSqlParser.MODEL, 0); }
		public Cost_class_nameContext[] cost_class_name() {
			return GetRuleContexts<Cost_class_nameContext>();
		}
		public Cost_class_nameContext cost_class_name(int i) {
			return GetRuleContext<Cost_class_nameContext>(i);
		}
		public ITerminalNode VALUES() { return GetToken(PlSqlParser.VALUES, 0); }
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ITerminalNode AUTO() { return GetToken(PlSqlParser.AUTO, 0); }
		public Cost_matrix_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cost_matrix_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCost_matrix_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCost_matrix_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCost_matrix_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cost_matrix_clauseContext cost_matrix_clause() {
		Cost_matrix_clauseContext _localctx = new Cost_matrix_clauseContext(_ctx, State);
		EnterRule(_localctx, 618, RULE_cost_matrix_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4736; Match(COST);
			State = 4754;
			switch (_input.La(1)) {
			case MODEL:
				{
				State = 4737; Match(MODEL);
				State = 4739;
				_la = _input.La(1);
				if (_la==AUTO) {
					{
					State = 4738; Match(AUTO);
					}
				}

				}
				break;
			case LEFT_PAREN:
				{
				State = 4741; Match(LEFT_PAREN);
				State = 4742; cost_class_name();
				State = 4747;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4743; Match(COMMA);
					State = 4744; cost_class_name();
					}
					}
					State = 4749;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				State = 4750; Match(RIGHT_PAREN);
				State = 4751; Match(VALUES);
				State = 4752; expression_list();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_passing_clauseContext : ParserRuleContext {
		public ITerminalNode PASSING() { return GetToken(PlSqlParser.PASSING, 0); }
		public Expression_wrapperContext[] expression_wrapper() {
			return GetRuleContexts<Expression_wrapperContext>();
		}
		public Expression_wrapperContext expression_wrapper(int i) {
			return GetRuleContext<Expression_wrapperContext>(i);
		}
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode VALUE() { return GetToken(PlSqlParser.VALUE, 0); }
		public Column_aliasContext[] column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public Xml_passing_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_passing_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXml_passing_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXml_passing_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_passing_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_passing_clauseContext xml_passing_clause() {
		Xml_passing_clauseContext _localctx = new Xml_passing_clauseContext(_ctx, State);
		EnterRule(_localctx, 620, RULE_xml_passing_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4756; Match(PASSING);
			State = 4759;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,601,_ctx) ) {
			case 1:
				{
				State = 4757; Match(BY);
				State = 4758; Match(VALUE);
				}
				break;
			}
			State = 4761; expression_wrapper();
			State = 4763;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,602,_ctx) ) {
			case 1:
				{
				State = 4762; column_alias();
				}
				break;
			}
			State = 4772;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4765; Match(COMMA);
				State = 4766; expression_wrapper();
				State = 4768;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,603,_ctx) ) {
				case 1:
					{
					State = 4767; column_alias();
					}
					break;
				}
				}
				}
				State = 4774;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_attributes_clauseContext : ParserRuleContext {
		public ITerminalNode XMLATTRIBUTES() { return GetToken(PlSqlParser.XMLATTRIBUTES, 0); }
		public Xml_multiuse_expression_elementContext[] xml_multiuse_expression_element() {
			return GetRuleContexts<Xml_multiuse_expression_elementContext>();
		}
		public Xml_multiuse_expression_elementContext xml_multiuse_expression_element(int i) {
			return GetRuleContext<Xml_multiuse_expression_elementContext>(i);
		}
		public ITerminalNode ENTITYESCAPING() { return GetToken(PlSqlParser.ENTITYESCAPING, 0); }
		public ITerminalNode NOENTITYESCAPING() { return GetToken(PlSqlParser.NOENTITYESCAPING, 0); }
		public ITerminalNode SCHEMACHECK() { return GetToken(PlSqlParser.SCHEMACHECK, 0); }
		public ITerminalNode NOSCHEMACHECK() { return GetToken(PlSqlParser.NOSCHEMACHECK, 0); }
		public Xml_attributes_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_attributes_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXml_attributes_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXml_attributes_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_attributes_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_attributes_clauseContext xml_attributes_clause() {
		Xml_attributes_clauseContext _localctx = new Xml_attributes_clauseContext(_ctx, State);
		EnterRule(_localctx, 622, RULE_xml_attributes_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4775; Match(XMLATTRIBUTES);
			State = 4776; Match(LEFT_PAREN);
			State = 4778;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,605,_ctx) ) {
			case 1:
				{
				State = 4777;
				_la = _input.La(1);
				if ( !(_la==ENTITYESCAPING || _la==NOENTITYESCAPING) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
				break;
			}
			State = 4781;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,606,_ctx) ) {
			case 1:
				{
				State = 4780;
				_la = _input.La(1);
				if ( !(_la==NOSCHEMACHECK || _la==SCHEMACHECK) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
				break;
			}
			State = 4783; xml_multiuse_expression_element();
			State = 4788;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 4784; Match(COMMA);
				State = 4785; xml_multiuse_expression_element();
				}
				}
				State = 4790;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 4791; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_namespaces_clauseContext : ParserRuleContext {
		public ITerminalNode XMLNAMESPACES() { return GetToken(PlSqlParser.XMLNAMESPACES, 0); }
		public Concatenation_wrapperContext[] concatenation_wrapper() {
			return GetRuleContexts<Concatenation_wrapperContext>();
		}
		public Concatenation_wrapperContext concatenation_wrapper(int i) {
			return GetRuleContext<Concatenation_wrapperContext>(i);
		}
		public Column_aliasContext[] column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public Xml_general_default_partContext xml_general_default_part() {
			return GetRuleContext<Xml_general_default_partContext>(0);
		}
		public Xml_namespaces_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_namespaces_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXml_namespaces_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXml_namespaces_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_namespaces_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_namespaces_clauseContext xml_namespaces_clause() {
		Xml_namespaces_clauseContext _localctx = new Xml_namespaces_clauseContext(_ctx, State);
		EnterRule(_localctx, 624, RULE_xml_namespaces_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4793; Match(XMLNAMESPACES);
			State = 4794; Match(LEFT_PAREN);
			State = 4806;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,609,_ctx) ) {
			case 1:
				{
				State = 4795; concatenation_wrapper();
				State = 4796; column_alias();
				State = 4803;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4797; Match(COMMA);
					State = 4798; concatenation_wrapper();
					State = 4799; column_alias();
					}
					}
					State = 4805;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			}
			State = 4809;
			_la = _input.La(1);
			if (_la==DEFAULT) {
				{
				State = 4808; xml_general_default_part();
				}
			}

			State = 4811; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_table_columnContext : ParserRuleContext {
		public Xml_column_nameContext xml_column_name() {
			return GetRuleContext<Xml_column_nameContext>(0);
		}
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public ITerminalNode ORDINALITY() { return GetToken(PlSqlParser.ORDINALITY, 0); }
		public Type_specContext type_spec() {
			return GetRuleContext<Type_specContext>(0);
		}
		public ITerminalNode PATH() { return GetToken(PlSqlParser.PATH, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Xml_general_default_partContext xml_general_default_part() {
			return GetRuleContext<Xml_general_default_partContext>(0);
		}
		public Xml_table_columnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_table_column; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXml_table_column(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXml_table_column(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_table_column(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_table_columnContext xml_table_column() {
		Xml_table_columnContext _localctx = new Xml_table_columnContext(_ctx, State);
		EnterRule(_localctx, 626, RULE_xml_table_column);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4813; xml_column_name();
			State = 4824;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,613,_ctx) ) {
			case 1:
				{
				State = 4814; Match(FOR);
				State = 4815; Match(ORDINALITY);
				}
				break;

			case 2:
				{
				State = 4816; type_spec();
				State = 4819;
				_la = _input.La(1);
				if (_la==PATH) {
					{
					State = 4817; Match(PATH);
					State = 4818; concatenation_wrapper();
					}
				}

				State = 4822;
				_la = _input.La(1);
				if (_la==DEFAULT) {
					{
					State = 4821; xml_general_default_part();
					}
				}

				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_general_default_partContext : ParserRuleContext {
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Xml_general_default_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_general_default_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXml_general_default_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXml_general_default_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_general_default_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_general_default_partContext xml_general_default_part() {
		Xml_general_default_partContext _localctx = new Xml_general_default_partContext(_ctx, State);
		EnterRule(_localctx, 628, RULE_xml_general_default_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4826; Match(DEFAULT);
			State = 4827; concatenation_wrapper();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_multiuse_expression_elementContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public ITerminalNode EVALNAME() { return GetToken(PlSqlParser.EVALNAME, 0); }
		public ConcatenationContext concatenation() {
			return GetRuleContext<ConcatenationContext>(0);
		}
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Xml_multiuse_expression_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_multiuse_expression_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXml_multiuse_expression_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXml_multiuse_expression_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_multiuse_expression_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_multiuse_expression_elementContext xml_multiuse_expression_element() {
		Xml_multiuse_expression_elementContext _localctx = new Xml_multiuse_expression_elementContext(_ctx, State);
		EnterRule(_localctx, 630, RULE_xml_multiuse_expression_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4829; expression();
			State = 4838;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (DELIMITED_ID - 448)))) != 0) || _la==REGULAR_ID) {
				{
				State = 4831;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,614,_ctx) ) {
				case 1:
					{
					State = 4830; Match(AS);
					}
					break;
				}
				State = 4836;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,615,_ctx) ) {
				case 1:
					{
					State = 4833; id_expression();
					}
					break;

				case 2:
					{
					State = 4834; Match(EVALNAME);
					State = 4835; concatenation();
					}
					break;
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlroot_param_version_partContext : ParserRuleContext {
		public ITerminalNode VERSION() { return GetToken(PlSqlParser.VERSION, 0); }
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode VALUE() { return GetToken(PlSqlParser.VALUE, 0); }
		public Expression_wrapperContext expression_wrapper() {
			return GetRuleContext<Expression_wrapperContext>(0);
		}
		public Xmlroot_param_version_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlroot_param_version_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXmlroot_param_version_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXmlroot_param_version_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlroot_param_version_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlroot_param_version_partContext xmlroot_param_version_part() {
		Xmlroot_param_version_partContext _localctx = new Xmlroot_param_version_partContext(_ctx, State);
		EnterRule(_localctx, 632, RULE_xmlroot_param_version_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4840; Match(VERSION);
			State = 4844;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,617,_ctx) ) {
			case 1:
				{
				State = 4841; Match(NO);
				State = 4842; Match(VALUE);
				}
				break;

			case 2:
				{
				State = 4843; expression_wrapper();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlroot_param_standalone_partContext : ParserRuleContext {
		public ITerminalNode STANDALONE() { return GetToken(PlSqlParser.STANDALONE, 0); }
		public ITerminalNode YES() { return GetToken(PlSqlParser.YES, 0); }
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode VALUE() { return GetToken(PlSqlParser.VALUE, 0); }
		public Xmlroot_param_standalone_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlroot_param_standalone_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXmlroot_param_standalone_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXmlroot_param_standalone_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlroot_param_standalone_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlroot_param_standalone_partContext xmlroot_param_standalone_part() {
		Xmlroot_param_standalone_partContext _localctx = new Xmlroot_param_standalone_partContext(_ctx, State);
		EnterRule(_localctx, 634, RULE_xmlroot_param_standalone_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4846; Match(STANDALONE);
			State = 4852;
			switch (_input.La(1)) {
			case YES:
				{
				State = 4847; Match(YES);
				}
				break;
			case NO:
				{
				State = 4848; Match(NO);
				State = 4850;
				_la = _input.La(1);
				if (_la==VALUE) {
					{
					State = 4849; Match(VALUE);
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlserialize_param_enconding_partContext : ParserRuleContext {
		public ITerminalNode ENCODING() { return GetToken(PlSqlParser.ENCODING, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Xmlserialize_param_enconding_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlserialize_param_enconding_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXmlserialize_param_enconding_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXmlserialize_param_enconding_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlserialize_param_enconding_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlserialize_param_enconding_partContext xmlserialize_param_enconding_part() {
		Xmlserialize_param_enconding_partContext _localctx = new Xmlserialize_param_enconding_partContext(_ctx, State);
		EnterRule(_localctx, 636, RULE_xmlserialize_param_enconding_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4854; Match(ENCODING);
			State = 4855; concatenation_wrapper();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlserialize_param_version_partContext : ParserRuleContext {
		public ITerminalNode VERSION() { return GetToken(PlSqlParser.VERSION, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Xmlserialize_param_version_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlserialize_param_version_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXmlserialize_param_version_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXmlserialize_param_version_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlserialize_param_version_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlserialize_param_version_partContext xmlserialize_param_version_part() {
		Xmlserialize_param_version_partContext _localctx = new Xmlserialize_param_version_partContext(_ctx, State);
		EnterRule(_localctx, 638, RULE_xmlserialize_param_version_part);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4857; Match(VERSION);
			State = 4858; concatenation_wrapper();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xmlserialize_param_ident_partContext : ParserRuleContext {
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode INDENT() { return GetToken(PlSqlParser.INDENT, 0); }
		public ITerminalNode SIZE() { return GetToken(PlSqlParser.SIZE, 0); }
		public Concatenation_wrapperContext concatenation_wrapper() {
			return GetRuleContext<Concatenation_wrapperContext>(0);
		}
		public Xmlserialize_param_ident_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xmlserialize_param_ident_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXmlserialize_param_ident_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXmlserialize_param_ident_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXmlserialize_param_ident_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xmlserialize_param_ident_partContext xmlserialize_param_ident_part() {
		Xmlserialize_param_ident_partContext _localctx = new Xmlserialize_param_ident_partContext(_ctx, State);
		EnterRule(_localctx, 640, RULE_xmlserialize_param_ident_part);
		int _la;
		try {
			State = 4868;
			switch (_input.La(1)) {
			case NO:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4860; Match(NO);
				State = 4861; Match(INDENT);
				}
				break;
			case INDENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4862; Match(INDENT);
				State = 4866;
				_la = _input.La(1);
				if (_la==SIZE) {
					{
					State = 4863; Match(SIZE);
					State = 4864; Match(EQUALS_OP);
					State = 4865; concatenation_wrapper();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Boolean_static_expressionContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public Boolean_static_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_boolean_static_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterBoolean_static_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitBoolean_static_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBoolean_static_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Boolean_static_expressionContext boolean_static_expression() {
		Boolean_static_expressionContext _localctx = new Boolean_static_expressionContext(_ctx, State);
		EnterRule(_localctx, 642, RULE_boolean_static_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4870; expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Preprocessor_internal_statementContext : ParserRuleContext {
		public Declare_specContext[] declare_spec() {
			return GetRuleContexts<Declare_specContext>();
		}
		public Declare_specContext declare_spec(int i) {
			return GetRuleContext<Declare_specContext>(i);
		}
		public Seq_of_statementsContext seq_of_statements() {
			return GetRuleContext<Seq_of_statementsContext>(0);
		}
		public Sql_scriptContext sql_script() {
			return GetRuleContext<Sql_scriptContext>(0);
		}
		public Preprocessor_internal_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_preprocessor_internal_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPreprocessor_internal_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPreprocessor_internal_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreprocessor_internal_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Preprocessor_internal_statementContext preprocessor_internal_statement() {
		Preprocessor_internal_statementContext _localctx = new Preprocessor_internal_statementContext(_ctx, State);
		EnterRule(_localctx, 644, RULE_preprocessor_internal_statement);
		int _la;
		try {
			State = 4879;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,623,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4873;
				_errHandler.Sync(this);
				_la = _input.La(1);
				do {
					{
					{
					State = 4872; declare_spec();
					}
					}
					State = 4875;
					_errHandler.Sync(this);
					_la = _input.La(1);
				} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << PP_IF) | (1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (DELIMITED_ID - 448)))) != 0) || ((((_la - 518)) & ~0x3f) == 0 && ((1L << (_la - 518)) & ((1L << (BINDVAR - 518)) | (1L << (COLON - 518)) | (1L << (INTRODUCER - 518)))) != 0) || _la==REGULAR_ID );
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4877; seq_of_statements();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 4878; sql_script();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Preprocessor_statementContext : ParserRuleContext {
		public ITerminalNode PP_IF() { return GetToken(PlSqlParser.PP_IF, 0); }
		public Boolean_static_expressionContext[] boolean_static_expression() {
			return GetRuleContexts<Boolean_static_expressionContext>();
		}
		public Boolean_static_expressionContext boolean_static_expression(int i) {
			return GetRuleContext<Boolean_static_expressionContext>(i);
		}
		public ITerminalNode[] PP_THEN() { return GetTokens(PlSqlParser.PP_THEN); }
		public ITerminalNode PP_THEN(int i) {
			return GetToken(PlSqlParser.PP_THEN, i);
		}
		public Preprocessor_internal_statementContext[] preprocessor_internal_statement() {
			return GetRuleContexts<Preprocessor_internal_statementContext>();
		}
		public Preprocessor_internal_statementContext preprocessor_internal_statement(int i) {
			return GetRuleContext<Preprocessor_internal_statementContext>(i);
		}
		public ITerminalNode PP_END() { return GetToken(PlSqlParser.PP_END, 0); }
		public ITerminalNode[] PP_ELSIF() { return GetTokens(PlSqlParser.PP_ELSIF); }
		public ITerminalNode PP_ELSIF(int i) {
			return GetToken(PlSqlParser.PP_ELSIF, i);
		}
		public ITerminalNode PP_ELSE() { return GetToken(PlSqlParser.PP_ELSE, 0); }
		public Preprocessor_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_preprocessor_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPreprocessor_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPreprocessor_statement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPreprocessor_statement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Preprocessor_statementContext preprocessor_statement() {
		Preprocessor_statementContext _localctx = new Preprocessor_statementContext(_ctx, State);
		EnterRule(_localctx, 646, RULE_preprocessor_statement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4881; Match(PP_IF);
			State = 4882; boolean_static_expression();
			State = 4883; Match(PP_THEN);
			State = 4884; preprocessor_internal_statement();
			State = 4892;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PP_ELSIF) {
				{
				{
				State = 4885; Match(PP_ELSIF);
				State = 4886; boolean_static_expression();
				State = 4887; Match(PP_THEN);
				State = 4888; preprocessor_internal_statement();
				}
				}
				State = 4894;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 4897;
			_la = _input.La(1);
			if (_la==PP_ELSE) {
				{
				State = 4895; Match(PP_ELSE);
				State = 4896; preprocessor_internal_statement();
				}
			}

			State = 4899; Match(PP_END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Partition_extension_clauseContext : ParserRuleContext {
		public Expression_listContext expression_list() {
			return GetRuleContext<Expression_listContext>(0);
		}
		public ITerminalNode SUBPARTITION() { return GetToken(PlSqlParser.SUBPARTITION, 0); }
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public Partition_extension_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_partition_extension_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPartition_extension_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPartition_extension_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPartition_extension_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Partition_extension_clauseContext partition_extension_clause() {
		Partition_extension_clauseContext _localctx = new Partition_extension_clauseContext(_ctx, State);
		EnterRule(_localctx, 648, RULE_partition_extension_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4901;
			_la = _input.La(1);
			if ( !(_la==PARTITION || _la==SUBPARTITION) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 4903;
			_la = _input.La(1);
			if (_la==FOR) {
				{
				State = 4902; Match(FOR);
				}
			}

			State = 4905; expression_list();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_aliasContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Alias_quoted_stringContext alias_quoted_string() {
			return GetRuleContext<Alias_quoted_stringContext>(0);
		}
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public Column_aliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_alias; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterColumn_alias(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitColumn_alias(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_alias(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_aliasContext column_alias() {
		Column_aliasContext _localctx = new Column_aliasContext(_ctx, State);
		EnterRule(_localctx, 650, RULE_column_alias);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4908;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,627,_ctx) ) {
			case 1:
				{
				State = 4907; Match(AS);
				}
				break;
			}
			State = 4912;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 4910; id();
				}
				break;
			case NATIONAL_CHAR_STRING_LIT:
			case CHAR_STRING:
				{
				State = 4911; alias_quoted_string();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_aliasContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Alias_quoted_stringContext alias_quoted_string() {
			return GetRuleContext<Alias_quoted_stringContext>(0);
		}
		public Table_aliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_alias; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTable_alias(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTable_alias(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_alias(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_aliasContext table_alias() {
		Table_aliasContext _localctx = new Table_aliasContext(_ctx, State);
		EnterRule(_localctx, 652, RULE_table_alias);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4916;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				{
				State = 4914; id();
				}
				break;
			case NATIONAL_CHAR_STRING_LIT:
			case CHAR_STRING:
				{
				State = 4915; alias_quoted_string();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Alias_quoted_stringContext : ParserRuleContext {
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public Alias_quoted_stringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alias_quoted_string; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAlias_quoted_string(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAlias_quoted_string(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlias_quoted_string(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Alias_quoted_stringContext alias_quoted_string() {
		Alias_quoted_stringContext _localctx = new Alias_quoted_stringContext(_ctx, State);
		EnterRule(_localctx, 654, RULE_alias_quoted_string);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4918; quoted_string();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Where_clauseContext : ParserRuleContext {
		public ITerminalNode WHERE() { return GetToken(PlSqlParser.WHERE, 0); }
		public Current_of_clauseContext current_of_clause() {
			return GetRuleContext<Current_of_clauseContext>(0);
		}
		public Condition_wrapperContext condition_wrapper() {
			return GetRuleContext<Condition_wrapperContext>(0);
		}
		public Where_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_where_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterWhere_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitWhere_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhere_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Where_clauseContext where_clause() {
		Where_clauseContext _localctx = new Where_clauseContext(_ctx, State);
		EnterRule(_localctx, 656, RULE_where_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4920; Match(WHERE);
			State = 4923;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,630,_ctx) ) {
			case 1:
				{
				State = 4921; current_of_clause();
				}
				break;

			case 2:
				{
				State = 4922; condition_wrapper();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Current_of_clauseContext : ParserRuleContext {
		public ITerminalNode CURRENT() { return GetToken(PlSqlParser.CURRENT, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public Cursor_nameContext cursor_name() {
			return GetRuleContext<Cursor_nameContext>(0);
		}
		public Current_of_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_current_of_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCurrent_of_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCurrent_of_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCurrent_of_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Current_of_clauseContext current_of_clause() {
		Current_of_clauseContext _localctx = new Current_of_clauseContext(_ctx, State);
		EnterRule(_localctx, 658, RULE_current_of_clause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4925; Match(CURRENT);
			State = 4926; Match(OF);
			State = 4927; cursor_name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Into_clause_variableContext : ParserRuleContext {
		public Variable_nameContext variable_name() {
			return GetRuleContext<Variable_nameContext>(0);
		}
		public Collection_assoc_expressionContext collection_assoc_expression() {
			return GetRuleContext<Collection_assoc_expressionContext>(0);
		}
		public Into_clause_variableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_into_clause_variable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterInto_clause_variable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitInto_clause_variable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInto_clause_variable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Into_clause_variableContext into_clause_variable() {
		Into_clause_variableContext _localctx = new Into_clause_variableContext(_ctx, State);
		EnterRule(_localctx, 660, RULE_into_clause_variable);
		try {
			State = 4931;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,631,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4929; variable_name();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4930; collection_assoc_expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Into_clauseContext : ParserRuleContext {
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public Into_clause_variableContext[] into_clause_variable() {
			return GetRuleContexts<Into_clause_variableContext>();
		}
		public Into_clause_variableContext into_clause_variable(int i) {
			return GetRuleContext<Into_clause_variableContext>(i);
		}
		public ITerminalNode BULK() { return GetToken(PlSqlParser.BULK, 0); }
		public ITerminalNode COLLECT() { return GetToken(PlSqlParser.COLLECT, 0); }
		public Into_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_into_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterInto_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitInto_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInto_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Into_clauseContext into_clause() {
		Into_clauseContext _localctx = new Into_clauseContext(_ctx, State);
		EnterRule(_localctx, 662, RULE_into_clause);
		int _la;
		try {
			State = 4953;
			switch (_input.La(1)) {
			case INTO:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4933; Match(INTO);
				State = 4934; into_clause_variable();
				State = 4939;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4935; Match(COMMA);
					State = 4936; into_clause_variable();
					}
					}
					State = 4941;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			case BULK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4942; Match(BULK);
				State = 4943; Match(COLLECT);
				State = 4944; Match(INTO);
				State = 4945; into_clause_variable();
				State = 4950;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 4946; Match(COMMA);
					State = 4947; into_clause_variable();
					}
					}
					State = 4952;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Xml_column_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Quoted_stringContext quoted_string() {
			return GetRuleContext<Quoted_stringContext>(0);
		}
		public Xml_column_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_xml_column_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterXml_column_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitXml_column_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitXml_column_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Xml_column_nameContext xml_column_name() {
		Xml_column_nameContext _localctx = new Xml_column_nameContext(_ctx, State);
		EnterRule(_localctx, 664, RULE_xml_column_name);
		try {
			State = 4957;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4955; id();
				}
				break;
			case NATIONAL_CHAR_STRING_LIT:
			case CHAR_STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4956; quoted_string();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cost_class_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Cost_class_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cost_class_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCost_class_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCost_class_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCost_class_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cost_class_nameContext cost_class_name() {
		Cost_class_nameContext _localctx = new Cost_class_nameContext(_ctx, State);
		EnterRule(_localctx, 666, RULE_cost_class_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4959; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Attribute_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Attribute_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_attribute_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAttribute_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAttribute_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAttribute_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Attribute_nameContext attribute_name() {
		Attribute_nameContext _localctx = new Attribute_nameContext(_ctx, State);
		EnterRule(_localctx, 668, RULE_attribute_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4961; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Savepoint_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Savepoint_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_savepoint_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSavepoint_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSavepoint_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSavepoint_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Savepoint_nameContext savepoint_name() {
		Savepoint_nameContext _localctx = new Savepoint_nameContext(_ctx, State);
		EnterRule(_localctx, 670, RULE_savepoint_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4963; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rollback_segment_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Rollback_segment_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rollback_segment_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRollback_segment_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRollback_segment_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRollback_segment_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Rollback_segment_nameContext rollback_segment_name() {
		Rollback_segment_nameContext _localctx = new Rollback_segment_nameContext(_ctx, State);
		EnterRule(_localctx, 672, RULE_rollback_segment_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4965; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_var_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Table_var_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_var_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTable_var_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTable_var_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_var_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_var_nameContext table_var_name() {
		Table_var_nameContext _localctx = new Table_var_nameContext(_ctx, State);
		EnterRule(_localctx, 674, RULE_table_var_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4967; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Schema_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Schema_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_schema_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSchema_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSchema_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSchema_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Schema_nameContext schema_name() {
		Schema_nameContext _localctx = new Schema_nameContext(_ctx, State);
		EnterRule(_localctx, 676, RULE_schema_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4969; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Routine_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public ITerminalNode AT_SIGN() { return GetToken(PlSqlParser.AT_SIGN, 0); }
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public Routine_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_routine_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRoutine_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRoutine_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoutine_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Routine_nameContext routine_name() {
		Routine_nameContext _localctx = new Routine_nameContext(_ctx, State);
		EnterRule(_localctx, 678, RULE_routine_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4971; id();
			State = 4976;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 4972; Match(PERIOD);
				State = 4973; id_expression();
				}
				}
				State = 4978;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 4981;
			_la = _input.La(1);
			if (_la==AT_SIGN) {
				{
				State = 4979; Match(AT_SIGN);
				State = 4980; link_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Package_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Schema_nameContext schema_name() {
			return GetRuleContext<Schema_nameContext>(0);
		}
		public Package_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_package_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPackage_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPackage_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPackage_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Package_nameContext package_name() {
		Package_nameContext _localctx = new Package_nameContext(_ctx, State);
		EnterRule(_localctx, 680, RULE_package_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4986;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,638,_ctx) ) {
			case 1:
				{
				State = 4983; schema_name();
				State = 4984; Match(PERIOD);
				}
				break;
			}
			State = 4988; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Implementation_type_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Implementation_type_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_implementation_type_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterImplementation_type_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitImplementation_type_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitImplementation_type_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Implementation_type_nameContext implementation_type_name() {
		Implementation_type_nameContext _localctx = new Implementation_type_nameContext(_ctx, State);
		EnterRule(_localctx, 682, RULE_implementation_type_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4990; id();
			State = 4993;
			_la = _input.La(1);
			if (_la==PERIOD) {
				{
				State = 4991; Match(PERIOD);
				State = 4992; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parameter_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Parameter_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterParameter_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitParameter_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parameter_nameContext parameter_name() {
		Parameter_nameContext _localctx = new Parameter_nameContext(_ctx, State);
		EnterRule(_localctx, 684, RULE_parameter_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4995; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Reference_model_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Reference_model_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reference_model_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterReference_model_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitReference_model_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReference_model_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Reference_model_nameContext reference_model_name() {
		Reference_model_nameContext _localctx = new Reference_model_nameContext(_ctx, State);
		EnterRule(_localctx, 686, RULE_reference_model_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4997; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Main_model_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Main_model_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_main_model_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterMain_model_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitMain_model_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMain_model_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Main_model_nameContext main_model_name() {
		Main_model_nameContext _localctx = new Main_model_nameContext(_ctx, State);
		EnterRule(_localctx, 688, RULE_main_model_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4999; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Aggregate_function_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Aggregate_function_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aggregate_function_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterAggregate_function_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitAggregate_function_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAggregate_function_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Aggregate_function_nameContext aggregate_function_name() {
		Aggregate_function_nameContext _localctx = new Aggregate_function_nameContext(_ctx, State);
		EnterRule(_localctx, 690, RULE_aggregate_function_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5001; id();
			State = 5006;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5002; Match(PERIOD);
				State = 5003; id_expression();
				}
				}
				State = 5008;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Query_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Query_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_query_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterQuery_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitQuery_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuery_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Query_nameContext query_name() {
		Query_nameContext _localctx = new Query_nameContext(_ctx, State);
		EnterRule(_localctx, 692, RULE_query_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5009; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Constraint_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public ITerminalNode AT_SIGN() { return GetToken(PlSqlParser.AT_SIGN, 0); }
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public Constraint_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraint_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterConstraint_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitConstraint_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstraint_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Constraint_nameContext constraint_name() {
		Constraint_nameContext _localctx = new Constraint_nameContext(_ctx, State);
		EnterRule(_localctx, 694, RULE_constraint_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5011; id();
			State = 5016;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5012; Match(PERIOD);
				State = 5013; id_expression();
				}
				}
				State = 5018;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 5021;
			_la = _input.La(1);
			if (_la==AT_SIGN) {
				{
				State = 5019; Match(AT_SIGN);
				State = 5020; link_name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Label_nameContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Label_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterLabel_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitLabel_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabel_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Label_nameContext label_name() {
		Label_nameContext _localctx = new Label_nameContext(_ctx, State);
		EnterRule(_localctx, 696, RULE_label_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5023; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_nameContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Type_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterType_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitType_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_nameContext type_name() {
		Type_nameContext _localctx = new Type_nameContext(_ctx, State);
		EnterRule(_localctx, 698, RULE_type_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5025; id_expression();
			State = 5030;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5026; Match(PERIOD);
				State = 5027; id_expression();
				}
				}
				State = 5032;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sequence_nameContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Sequence_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sequence_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterSequence_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitSequence_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSequence_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sequence_nameContext sequence_name() {
		Sequence_nameContext _localctx = new Sequence_nameContext(_ctx, State);
		EnterRule(_localctx, 700, RULE_sequence_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5033; id_expression();
			State = 5038;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5034; Match(PERIOD);
				State = 5035; id_expression();
				}
				}
				State = 5040;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exception_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Exception_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exception_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterException_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitException_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitException_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exception_nameContext exception_name() {
		Exception_nameContext _localctx = new Exception_nameContext(_ctx, State);
		EnterRule(_localctx, 702, RULE_exception_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5041; id();
			State = 5046;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5042; Match(PERIOD);
				State = 5043; id_expression();
				}
				}
				State = 5048;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Function_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFunction_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFunction_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_nameContext function_name() {
		Function_nameContext _localctx = new Function_nameContext(_ctx, State);
		EnterRule(_localctx, 704, RULE_function_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5049; id();
			State = 5052;
			_la = _input.La(1);
			if (_la==PERIOD) {
				{
				State = 5050; Match(PERIOD);
				State = 5051; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Procedure_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Procedure_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedure_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterProcedure_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitProcedure_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedure_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Procedure_nameContext procedure_name() {
		Procedure_nameContext _localctx = new Procedure_nameContext(_ctx, State);
		EnterRule(_localctx, 706, RULE_procedure_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5054; id();
			State = 5057;
			_la = _input.La(1);
			if (_la==PERIOD) {
				{
				State = 5055; Match(PERIOD);
				State = 5056; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Trigger_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Trigger_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTrigger_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTrigger_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Trigger_nameContext trigger_name() {
		Trigger_nameContext _localctx = new Trigger_nameContext(_ctx, State);
		EnterRule(_localctx, 708, RULE_trigger_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5059; id();
			State = 5062;
			_la = _input.La(1);
			if (_la==PERIOD) {
				{
				State = 5060; Match(PERIOD);
				State = 5061; id_expression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Variable_nameContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public ITerminalNode INTRODUCER() { return GetToken(PlSqlParser.INTRODUCER, 0); }
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public Variable_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variable_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterVariable_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitVariable_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Variable_nameContext variable_name() {
		Variable_nameContext _localctx = new Variable_nameContext(_ctx, State);
		EnterRule(_localctx, 710, RULE_variable_name);
		int _la;
		try {
			State = 5074;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5066;
				_la = _input.La(1);
				if (_la==INTRODUCER) {
					{
					State = 5064; Match(INTRODUCER);
					State = 5065; char_set_name();
					}
				}

				State = 5068; id_expression();
				State = 5071;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,650,_ctx) ) {
				case 1:
					{
					State = 5069; Match(PERIOD);
					State = 5070; id_expression();
					}
					break;
				}
				}
				break;
			case BINDVAR:
			case COLON:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5073; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Index_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Index_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_index_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterIndex_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitIndex_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndex_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Index_nameContext index_name() {
		Index_nameContext _localctx = new Index_nameContext(_ctx, State);
		EnterRule(_localctx, 712, RULE_index_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5076; id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cursor_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public Cursor_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cursor_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCursor_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCursor_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCursor_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cursor_nameContext cursor_name() {
		Cursor_nameContext _localctx = new Cursor_nameContext(_ctx, State);
		EnterRule(_localctx, 714, RULE_cursor_name);
		try {
			State = 5080;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5078; id();
				}
				break;
			case BINDVAR:
			case COLON:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5079; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Record_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Bind_variableContext bind_variable() {
			return GetRuleContext<Bind_variableContext>(0);
		}
		public Record_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_record_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRecord_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRecord_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRecord_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Record_nameContext record_name() {
		Record_nameContext _localctx = new Record_nameContext(_ctx, State);
		EnterRule(_localctx, 716, RULE_record_name);
		try {
			State = 5084;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case DELIMITED_ID:
			case INTRODUCER:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5082; id();
				}
				break;
			case BINDVAR:
			case COLON:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5083; bind_variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Collection_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public Collection_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collection_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterCollection_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitCollection_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollection_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Collection_nameContext collection_name() {
		Collection_nameContext _localctx = new Collection_nameContext(_ctx, State);
		EnterRule(_localctx, 718, RULE_collection_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5086; id();
			State = 5089;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,654,_ctx) ) {
			case 1:
				{
				State = 5087; Match(PERIOD);
				State = 5088; id_expression();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Link_nameContext : ParserRuleContext {
		public IdContext[] id() {
			return GetRuleContexts<IdContext>();
		}
		public IdContext id(int i) {
			return GetRuleContext<IdContext>(i);
		}
		public Link_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_link_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterLink_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitLink_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLink_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Link_nameContext link_name() {
		Link_nameContext _localctx = new Link_nameContext(_ctx, State);
		EnterRule(_localctx, 720, RULE_link_name);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5091; id();
			State = 5096;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,655,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 5092; Match(PERIOD);
					State = 5093; id();
					}
					} 
				}
				State = 5098;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,655,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Column_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Column_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_column_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterColumn_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitColumn_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumn_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Column_nameContext column_name() {
		Column_nameContext _localctx = new Column_nameContext(_ctx, State);
		EnterRule(_localctx, 722, RULE_column_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5099; id();
			State = 5104;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5100; Match(PERIOD);
				State = 5101; id_expression();
				}
				}
				State = 5106;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tableview_nameContext : ParserRuleContext {
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public ITerminalNode AT_SIGN() { return GetToken(PlSqlParser.AT_SIGN, 0); }
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public Partition_extension_clauseContext partition_extension_clause() {
			return GetRuleContext<Partition_extension_clauseContext>(0);
		}
		public Tableview_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableview_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTableview_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTableview_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableview_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tableview_nameContext tableview_name() {
		Tableview_nameContext _localctx = new Tableview_nameContext(_ctx, State);
		EnterRule(_localctx, 724, RULE_tableview_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5107; id();
			State = 5110;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,657,_ctx) ) {
			case 1:
				{
				State = 5108; Match(PERIOD);
				State = 5109; id_expression();
				}
				break;
			}
			State = 5115;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,658,_ctx) ) {
			case 1:
				{
				State = 5112; Match(AT_SIGN);
				State = 5113; link_name();
				}
				break;

			case 2:
				{
				State = 5114; partition_extension_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Char_set_nameContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public Char_set_nameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_char_set_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterChar_set_name(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitChar_set_name(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitChar_set_name(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Char_set_nameContext char_set_name() {
		Char_set_nameContext _localctx = new Char_set_nameContext(_ctx, State);
		EnterRule(_localctx, 726, RULE_char_set_name);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5117; id_expression();
			State = 5122;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5118; Match(PERIOD);
				State = 5119; id_expression();
				}
				}
				State = 5124;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Keep_clauseContext : ParserRuleContext {
		public ITerminalNode KEEP() { return GetToken(PlSqlParser.KEEP, 0); }
		public ITerminalNode DENSE_RANK() { return GetToken(PlSqlParser.DENSE_RANK, 0); }
		public Order_by_clauseContext order_by_clause() {
			return GetRuleContext<Order_by_clauseContext>(0);
		}
		public ITerminalNode FIRST() { return GetToken(PlSqlParser.FIRST, 0); }
		public ITerminalNode LAST() { return GetToken(PlSqlParser.LAST, 0); }
		public Over_clauseContext over_clause() {
			return GetRuleContext<Over_clauseContext>(0);
		}
		public Keep_clauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_keep_clause; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterKeep_clause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitKeep_clause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeep_clause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Keep_clauseContext keep_clause() {
		Keep_clauseContext _localctx = new Keep_clauseContext(_ctx, State);
		EnterRule(_localctx, 728, RULE_keep_clause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5125; Match(KEEP);
			State = 5126; Match(LEFT_PAREN);
			State = 5127; Match(DENSE_RANK);
			State = 5128;
			_la = _input.La(1);
			if ( !(_la==FIRST || _la==LAST) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 5129; order_by_clause();
			State = 5130; Match(RIGHT_PAREN);
			State = 5132;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,660,_ctx) ) {
			case 1:
				{
				State = 5131; over_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_argumentContext : ParserRuleContext {
		public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public Function_argumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_argument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFunction_argument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFunction_argument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_argument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_argumentContext function_argument() {
		Function_argumentContext _localctx = new Function_argumentContext(_ctx, State);
		EnterRule(_localctx, 730, RULE_function_argument);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5134; Match(LEFT_PAREN);
			State = 5136;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MOD - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TO_NUMBER - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (LEFT_PAREN - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (PLUS_SIGN - 512)) | (1L << (MINUS_SIGN - 512)) | (1L << (BINDVAR - 512)) | (1L << (COLON - 512)) | (1L << (INTRODUCER - 512)))) != 0) || _la==REGULAR_ID) {
				{
				State = 5135; argument();
				}
			}

			State = 5142;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 5138; Match(COMMA);
				State = 5139; argument();
				}
				}
				State = 5144;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 5145; Match(RIGHT_PAREN);
			State = 5147;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,663,_ctx) ) {
			case 1:
				{
				State = 5146; keep_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_argument_analyticContext : ParserRuleContext {
		public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public Respect_or_ignore_nullsContext[] respect_or_ignore_nulls() {
			return GetRuleContexts<Respect_or_ignore_nullsContext>();
		}
		public Respect_or_ignore_nullsContext respect_or_ignore_nulls(int i) {
			return GetRuleContext<Respect_or_ignore_nullsContext>(i);
		}
		public Function_argument_analyticContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_argument_analytic; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFunction_argument_analytic(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFunction_argument_analytic(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_argument_analytic(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_argument_analyticContext function_argument_analytic() {
		Function_argument_analyticContext _localctx = new Function_argument_analyticContext(_ctx, State);
		EnterRule(_localctx, 732, RULE_function_argument_analytic);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5149; Match(LEFT_PAREN);
			State = 5154;
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MOD - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TO_NUMBER - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (UNSIGNED_INTEGER - 448)) | (1L << (APPROXIMATE_NUM_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)) | (1L << (LEFT_PAREN - 448)))) != 0) || ((((_la - 512)) & ~0x3f) == 0 && ((1L << (_la - 512)) & ((1L << (PLUS_SIGN - 512)) | (1L << (MINUS_SIGN - 512)) | (1L << (BINDVAR - 512)) | (1L << (COLON - 512)) | (1L << (INTRODUCER - 512)))) != 0) || _la==REGULAR_ID) {
				{
				State = 5150; argument();
				State = 5152;
				_la = _input.La(1);
				if (_la==IGNORE || _la==RESPECT) {
					{
					State = 5151; respect_or_ignore_nulls();
					}
				}

				}
			}

			State = 5163;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==COMMA) {
				{
				{
				State = 5156; Match(COMMA);
				State = 5157; argument();
				State = 5159;
				_la = _input.La(1);
				if (_la==IGNORE || _la==RESPECT) {
					{
					State = 5158; respect_or_ignore_nulls();
					}
				}

				}
				}
				State = 5165;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 5166; Match(RIGHT_PAREN);
			State = 5168;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,668,_ctx) ) {
			case 1:
				{
				State = 5167; keep_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_argument_modelingContext : ParserRuleContext {
		public Column_nameContext column_name() {
			return GetRuleContext<Column_nameContext>(0);
		}
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public Tableview_nameContext tableview_name() {
			return GetRuleContext<Tableview_nameContext>(0);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public Keep_clauseContext keep_clause() {
			return GetRuleContext<Keep_clauseContext>(0);
		}
		public NumericContext[] numeric() {
			return GetRuleContexts<NumericContext>();
		}
		public NumericContext numeric(int i) {
			return GetRuleContext<NumericContext>(i);
		}
		public ITerminalNode[] NULL() { return GetTokens(PlSqlParser.NULL); }
		public ITerminalNode NULL(int i) {
			return GetToken(PlSqlParser.NULL, i);
		}
		public Column_aliasContext[] column_alias() {
			return GetRuleContexts<Column_aliasContext>();
		}
		public Column_aliasContext column_alias(int i) {
			return GetRuleContext<Column_aliasContext>(i);
		}
		public Function_argument_modelingContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_argument_modeling; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterFunction_argument_modeling(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitFunction_argument_modeling(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_argument_modeling(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_argument_modelingContext function_argument_modeling() {
		Function_argument_modelingContext _localctx = new Function_argument_modelingContext(_ctx, State);
		EnterRule(_localctx, 734, RULE_function_argument_modeling);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5170; Match(LEFT_PAREN);
			State = 5171; column_name();
			State = 5184;
			_la = _input.La(1);
			if (_la==COMMA) {
				{
				State = 5172; Match(COMMA);
				State = 5175;
				switch (_input.La(1)) {
				case UNSIGNED_INTEGER:
				case APPROXIMATE_NUM_LIT:
					{
					State = 5173; numeric();
					}
					break;
				case NULL:
					{
					State = 5174; Match(NULL);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5182;
				_la = _input.La(1);
				if (_la==COMMA) {
					{
					State = 5177; Match(COMMA);
					State = 5180;
					switch (_input.La(1)) {
					case UNSIGNED_INTEGER:
					case APPROXIMATE_NUM_LIT:
						{
						State = 5178; numeric();
						}
						break;
					case NULL:
						{
						State = 5179; Match(NULL);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
				}

				}
			}

			State = 5186; Match(USING);
			State = 5206;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,676,_ctx) ) {
			case 1:
				{
				State = 5187; tableview_name();
				State = 5188; Match(PERIOD);
				State = 5189; Match(ASTERISK);
				}
				break;

			case 2:
				{
				State = 5191; Match(ASTERISK);
				}
				break;

			case 3:
				{
				State = 5192; expression();
				State = 5194;
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
					{
					State = 5193; column_alias();
					}
				}

				State = 5203;
				_errHandler.Sync(this);
				_la = _input.La(1);
				while (_la==COMMA) {
					{
					{
					State = 5196; Match(COMMA);
					State = 5197; expression();
					State = 5199;
					_la = _input.La(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)) | (1L << (NATIONAL_CHAR_STRING_LIT - 448)) | (1L << (CHAR_STRING - 448)) | (1L << (DELIMITED_ID - 448)))) != 0) || _la==INTRODUCER || _la==REGULAR_ID) {
						{
						State = 5198; column_alias();
						}
					}

					}
					}
					State = 5205;
					_errHandler.Sync(this);
					_la = _input.La(1);
				}
				}
				break;
			}
			State = 5208; Match(RIGHT_PAREN);
			State = 5210;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,677,_ctx) ) {
			case 1:
				{
				State = 5209; keep_clause();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Respect_or_ignore_nullsContext : ParserRuleContext {
		public ITerminalNode NULLS() { return GetToken(PlSqlParser.NULLS, 0); }
		public ITerminalNode RESPECT() { return GetToken(PlSqlParser.RESPECT, 0); }
		public ITerminalNode IGNORE() { return GetToken(PlSqlParser.IGNORE, 0); }
		public Respect_or_ignore_nullsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_respect_or_ignore_nulls; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRespect_or_ignore_nulls(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRespect_or_ignore_nulls(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRespect_or_ignore_nulls(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Respect_or_ignore_nullsContext respect_or_ignore_nulls() {
		Respect_or_ignore_nullsContext _localctx = new Respect_or_ignore_nullsContext(_ctx, State);
		EnterRule(_localctx, 736, RULE_respect_or_ignore_nulls);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5212;
			_la = _input.La(1);
			if ( !(_la==IGNORE || _la==RESPECT) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			State = 5213; Match(NULLS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentContext : ParserRuleContext {
		public Expression_wrapperContext expression_wrapper() {
			return GetRuleContext<Expression_wrapperContext>(0);
		}
		public IdContext id() {
			return GetRuleContext<IdContext>(0);
		}
		public ITerminalNode ASSOCIATION_OPERATOR() { return GetToken(PlSqlParser.ASSOCIATION_OPERATOR, 0); }
		public ArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitArgument(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentContext argument() {
		ArgumentContext _localctx = new ArgumentContext(_ctx, State);
		EnterRule(_localctx, 738, RULE_argument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5218;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,678,_ctx) ) {
			case 1:
				{
				State = 5215; id();
				State = 5216; Match(ASSOCIATION_OPERATOR);
				}
				break;
			}
			State = 5220; expression_wrapper();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Type_specContext : ParserRuleContext {
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public Type_nameContext type_name() {
			return GetRuleContext<Type_nameContext>(0);
		}
		public ITerminalNode REF() { return GetToken(PlSqlParser.REF, 0); }
		public ITerminalNode AT_SIGN() { return GetToken(PlSqlParser.AT_SIGN, 0); }
		public Link_nameContext link_name() {
			return GetRuleContext<Link_nameContext>(0);
		}
		public ITerminalNode PERCENT_ROWTYPE() { return GetToken(PlSqlParser.PERCENT_ROWTYPE, 0); }
		public ITerminalNode PERCENT_TYPE() { return GetToken(PlSqlParser.PERCENT_TYPE, 0); }
		public Type_specContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type_spec; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterType_spec(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitType_spec(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType_spec(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Type_specContext type_spec() {
		Type_specContext _localctx = new Type_specContext(_ctx, State);
		EnterRule(_localctx, 740, RULE_type_spec);
		int _la;
		try {
			State = 5234;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,682,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5222; datatype();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5224;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,679,_ctx) ) {
				case 1:
					{
					State = 5223; Match(REF);
					}
					break;
				}
				State = 5226; type_name();
				State = 5229;
				_la = _input.La(1);
				if (_la==AT_SIGN) {
					{
					State = 5227; Match(AT_SIGN);
					State = 5228; link_name();
					}
				}

				State = 5232;
				_la = _input.La(1);
				if (_la==PERCENT_ROWTYPE || _la==PERCENT_TYPE) {
					{
					State = 5231;
					_la = _input.La(1);
					if ( !(_la==PERCENT_ROWTYPE || _la==PERCENT_TYPE) ) {
					_errHandler.RecoverInline(this);
					} else {
						Consume();
					}
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DatatypeContext : ParserRuleContext {
		public Native_datatype_elementContext native_datatype_element() {
			return GetRuleContext<Native_datatype_elementContext>(0);
		}
		public Precision_partContext precision_part() {
			return GetRuleContext<Precision_partContext>(0);
		}
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode TIME() { return GetToken(PlSqlParser.TIME, 0); }
		public ITerminalNode ZONE() { return GetToken(PlSqlParser.ZONE, 0); }
		public ITerminalNode LOCAL() { return GetToken(PlSqlParser.LOCAL, 0); }
		public ITerminalNode INTERVAL() { return GetToken(PlSqlParser.INTERVAL, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ITerminalNode YEAR() { return GetToken(PlSqlParser.YEAR, 0); }
		public ITerminalNode DAY() { return GetToken(PlSqlParser.DAY, 0); }
		public ITerminalNode MONTH() { return GetToken(PlSqlParser.MONTH, 0); }
		public ITerminalNode SECOND() { return GetToken(PlSqlParser.SECOND, 0); }
		public Expression_wrapperContext[] expression_wrapper() {
			return GetRuleContexts<Expression_wrapperContext>();
		}
		public Expression_wrapperContext expression_wrapper(int i) {
			return GetRuleContext<Expression_wrapperContext>(i);
		}
		public DatatypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_datatype; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterDatatype(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitDatatype(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDatatype(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DatatypeContext datatype() {
		DatatypeContext _localctx = new DatatypeContext(_ctx, State);
		EnterRule(_localctx, 742, RULE_datatype);
		int _la;
		try {
			State = 5264;
			switch (_input.La(1)) {
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BOOLEAN:
			case CHAR:
			case CHARACTER:
			case CLOB:
			case DATE:
			case DAY:
			case DEC:
			case DECIMAL:
			case DOUBLE:
			case DSINTERVAL_UNCONSTRAINED:
			case FLOAT:
			case HOUR:
			case INT:
			case INTEGER:
			case LONG:
			case MINUTE:
			case MLSLABEL:
			case MONTH:
			case NATURAL:
			case NATURALN:
			case NCHAR:
			case NCLOB:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case RAW:
			case REAL:
			case ROWID:
			case SECOND:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SMALLINT:
			case STRING:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case UROWID:
			case VARCHAR:
			case VARCHAR2:
			case YEAR:
			case YMINTERVAL_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5236; native_datatype_element();
				State = 5238;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,683,_ctx) ) {
				case 1:
					{
					State = 5237; precision_part();
					}
					break;
				}
				State = 5246;
				_la = _input.La(1);
				if (_la==WITH) {
					{
					State = 5240; Match(WITH);
					State = 5242;
					_la = _input.La(1);
					if (_la==LOCAL) {
						{
						State = 5241; Match(LOCAL);
						}
					}

					State = 5244; Match(TIME);
					State = 5245; Match(ZONE);
					}
				}

				}
				break;
			case INTERVAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5248; Match(INTERVAL);
				State = 5249;
				_la = _input.La(1);
				if ( !(_la==DAY || _la==YEAR) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 5254;
				_la = _input.La(1);
				if (_la==LEFT_PAREN) {
					{
					State = 5250; Match(LEFT_PAREN);
					State = 5251; expression_wrapper();
					State = 5252; Match(RIGHT_PAREN);
					}
				}

				State = 5256; Match(TO);
				State = 5257;
				_la = _input.La(1);
				if ( !(_la==MONTH || _la==SECOND) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 5262;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,687,_ctx) ) {
				case 1:
					{
					State = 5258; Match(LEFT_PAREN);
					State = 5259; expression_wrapper();
					State = 5260; Match(RIGHT_PAREN);
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Precision_partContext : ParserRuleContext {
		public NumericContext[] numeric() {
			return GetRuleContexts<NumericContext>();
		}
		public NumericContext numeric(int i) {
			return GetRuleContext<NumericContext>(i);
		}
		public ITerminalNode CHAR() { return GetToken(PlSqlParser.CHAR, 0); }
		public ITerminalNode BYTE() { return GetToken(PlSqlParser.BYTE, 0); }
		public Precision_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_precision_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterPrecision_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitPrecision_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrecision_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Precision_partContext precision_part() {
		Precision_partContext _localctx = new Precision_partContext(_ctx, State);
		EnterRule(_localctx, 744, RULE_precision_part);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5266; Match(LEFT_PAREN);
			State = 5267; numeric();
			State = 5270;
			_la = _input.La(1);
			if (_la==COMMA) {
				{
				State = 5268; Match(COMMA);
				State = 5269; numeric();
				}
			}

			State = 5273;
			_la = _input.La(1);
			if (_la==BYTE || _la==CHAR) {
				{
				State = 5272;
				_la = _input.La(1);
				if ( !(_la==BYTE || _la==CHAR) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				}
			}

			State = 5275; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Native_datatype_elementContext : ParserRuleContext {
		public ITerminalNode BINARY_INTEGER() { return GetToken(PlSqlParser.BINARY_INTEGER, 0); }
		public ITerminalNode PLS_INTEGER() { return GetToken(PlSqlParser.PLS_INTEGER, 0); }
		public ITerminalNode NATURAL() { return GetToken(PlSqlParser.NATURAL, 0); }
		public ITerminalNode BINARY_FLOAT() { return GetToken(PlSqlParser.BINARY_FLOAT, 0); }
		public ITerminalNode BINARY_DOUBLE() { return GetToken(PlSqlParser.BINARY_DOUBLE, 0); }
		public ITerminalNode NATURALN() { return GetToken(PlSqlParser.NATURALN, 0); }
		public ITerminalNode POSITIVE() { return GetToken(PlSqlParser.POSITIVE, 0); }
		public ITerminalNode POSITIVEN() { return GetToken(PlSqlParser.POSITIVEN, 0); }
		public ITerminalNode SIGNTYPE() { return GetToken(PlSqlParser.SIGNTYPE, 0); }
		public ITerminalNode SIMPLE_INTEGER() { return GetToken(PlSqlParser.SIMPLE_INTEGER, 0); }
		public ITerminalNode NVARCHAR2() { return GetToken(PlSqlParser.NVARCHAR2, 0); }
		public ITerminalNode DEC() { return GetToken(PlSqlParser.DEC, 0); }
		public ITerminalNode INTEGER() { return GetToken(PlSqlParser.INTEGER, 0); }
		public ITerminalNode INT() { return GetToken(PlSqlParser.INT, 0); }
		public ITerminalNode NUMERIC() { return GetToken(PlSqlParser.NUMERIC, 0); }
		public ITerminalNode SMALLINT() { return GetToken(PlSqlParser.SMALLINT, 0); }
		public ITerminalNode NUMBER() { return GetToken(PlSqlParser.NUMBER, 0); }
		public ITerminalNode DECIMAL() { return GetToken(PlSqlParser.DECIMAL, 0); }
		public ITerminalNode DOUBLE() { return GetToken(PlSqlParser.DOUBLE, 0); }
		public ITerminalNode PRECISION() { return GetToken(PlSqlParser.PRECISION, 0); }
		public ITerminalNode FLOAT() { return GetToken(PlSqlParser.FLOAT, 0); }
		public ITerminalNode REAL() { return GetToken(PlSqlParser.REAL, 0); }
		public ITerminalNode NCHAR() { return GetToken(PlSqlParser.NCHAR, 0); }
		public ITerminalNode LONG() { return GetToken(PlSqlParser.LONG, 0); }
		public ITerminalNode RAW() { return GetToken(PlSqlParser.RAW, 0); }
		public ITerminalNode CHAR() { return GetToken(PlSqlParser.CHAR, 0); }
		public ITerminalNode CHARACTER() { return GetToken(PlSqlParser.CHARACTER, 0); }
		public ITerminalNode VARCHAR2() { return GetToken(PlSqlParser.VARCHAR2, 0); }
		public ITerminalNode VARCHAR() { return GetToken(PlSqlParser.VARCHAR, 0); }
		public ITerminalNode STRING() { return GetToken(PlSqlParser.STRING, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(PlSqlParser.BOOLEAN, 0); }
		public ITerminalNode DATE() { return GetToken(PlSqlParser.DATE, 0); }
		public ITerminalNode ROWID() { return GetToken(PlSqlParser.ROWID, 0); }
		public ITerminalNode UROWID() { return GetToken(PlSqlParser.UROWID, 0); }
		public ITerminalNode YEAR() { return GetToken(PlSqlParser.YEAR, 0); }
		public ITerminalNode MONTH() { return GetToken(PlSqlParser.MONTH, 0); }
		public ITerminalNode DAY() { return GetToken(PlSqlParser.DAY, 0); }
		public ITerminalNode HOUR() { return GetToken(PlSqlParser.HOUR, 0); }
		public ITerminalNode MINUTE() { return GetToken(PlSqlParser.MINUTE, 0); }
		public ITerminalNode SECOND() { return GetToken(PlSqlParser.SECOND, 0); }
		public ITerminalNode TIMEZONE_HOUR() { return GetToken(PlSqlParser.TIMEZONE_HOUR, 0); }
		public ITerminalNode TIMEZONE_MINUTE() { return GetToken(PlSqlParser.TIMEZONE_MINUTE, 0); }
		public ITerminalNode TIMEZONE_REGION() { return GetToken(PlSqlParser.TIMEZONE_REGION, 0); }
		public ITerminalNode TIMEZONE_ABBR() { return GetToken(PlSqlParser.TIMEZONE_ABBR, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(PlSqlParser.TIMESTAMP, 0); }
		public ITerminalNode TIMESTAMP_UNCONSTRAINED() { return GetToken(PlSqlParser.TIMESTAMP_UNCONSTRAINED, 0); }
		public ITerminalNode TIMESTAMP_TZ_UNCONSTRAINED() { return GetToken(PlSqlParser.TIMESTAMP_TZ_UNCONSTRAINED, 0); }
		public ITerminalNode TIMESTAMP_LTZ_UNCONSTRAINED() { return GetToken(PlSqlParser.TIMESTAMP_LTZ_UNCONSTRAINED, 0); }
		public ITerminalNode YMINTERVAL_UNCONSTRAINED() { return GetToken(PlSqlParser.YMINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode DSINTERVAL_UNCONSTRAINED() { return GetToken(PlSqlParser.DSINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode BFILE() { return GetToken(PlSqlParser.BFILE, 0); }
		public ITerminalNode BLOB() { return GetToken(PlSqlParser.BLOB, 0); }
		public ITerminalNode CLOB() { return GetToken(PlSqlParser.CLOB, 0); }
		public ITerminalNode NCLOB() { return GetToken(PlSqlParser.NCLOB, 0); }
		public ITerminalNode MLSLABEL() { return GetToken(PlSqlParser.MLSLABEL, 0); }
		public Native_datatype_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_native_datatype_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterNative_datatype_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitNative_datatype_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNative_datatype_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Native_datatype_elementContext native_datatype_element() {
		Native_datatype_elementContext _localctx = new Native_datatype_elementContext(_ctx, State);
		EnterRule(_localctx, 746, RULE_native_datatype_element);
		int _la;
		try {
			State = 5337;
			switch (_input.La(1)) {
			case BINARY_INTEGER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5277; Match(BINARY_INTEGER);
				}
				break;
			case PLS_INTEGER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5278; Match(PLS_INTEGER);
				}
				break;
			case NATURAL:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5279; Match(NATURAL);
				}
				break;
			case BINARY_FLOAT:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5280; Match(BINARY_FLOAT);
				}
				break;
			case BINARY_DOUBLE:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5281; Match(BINARY_DOUBLE);
				}
				break;
			case NATURALN:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5282; Match(NATURALN);
				}
				break;
			case POSITIVE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5283; Match(POSITIVE);
				}
				break;
			case POSITIVEN:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5284; Match(POSITIVEN);
				}
				break;
			case SIGNTYPE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5285; Match(SIGNTYPE);
				}
				break;
			case SIMPLE_INTEGER:
				EnterOuterAlt(_localctx, 10);
				{
				State = 5286; Match(SIMPLE_INTEGER);
				}
				break;
			case NVARCHAR2:
				EnterOuterAlt(_localctx, 11);
				{
				State = 5287; Match(NVARCHAR2);
				}
				break;
			case DEC:
				EnterOuterAlt(_localctx, 12);
				{
				State = 5288; Match(DEC);
				}
				break;
			case INTEGER:
				EnterOuterAlt(_localctx, 13);
				{
				State = 5289; Match(INTEGER);
				}
				break;
			case INT:
				EnterOuterAlt(_localctx, 14);
				{
				State = 5290; Match(INT);
				}
				break;
			case NUMERIC:
				EnterOuterAlt(_localctx, 15);
				{
				State = 5291; Match(NUMERIC);
				}
				break;
			case SMALLINT:
				EnterOuterAlt(_localctx, 16);
				{
				State = 5292; Match(SMALLINT);
				}
				break;
			case NUMBER:
				EnterOuterAlt(_localctx, 17);
				{
				State = 5293; Match(NUMBER);
				}
				break;
			case DECIMAL:
				EnterOuterAlt(_localctx, 18);
				{
				State = 5294; Match(DECIMAL);
				}
				break;
			case DOUBLE:
				EnterOuterAlt(_localctx, 19);
				{
				State = 5295; Match(DOUBLE);
				State = 5297;
				_la = _input.La(1);
				if (_la==PRECISION) {
					{
					State = 5296; Match(PRECISION);
					}
				}

				}
				break;
			case FLOAT:
				EnterOuterAlt(_localctx, 20);
				{
				State = 5299; Match(FLOAT);
				}
				break;
			case REAL:
				EnterOuterAlt(_localctx, 21);
				{
				State = 5300; Match(REAL);
				}
				break;
			case NCHAR:
				EnterOuterAlt(_localctx, 22);
				{
				State = 5301; Match(NCHAR);
				}
				break;
			case LONG:
				EnterOuterAlt(_localctx, 23);
				{
				State = 5302; Match(LONG);
				State = 5304;
				_la = _input.La(1);
				if (_la==RAW) {
					{
					State = 5303; Match(RAW);
					}
				}

				}
				break;
			case CHAR:
				EnterOuterAlt(_localctx, 24);
				{
				State = 5306; Match(CHAR);
				}
				break;
			case CHARACTER:
				EnterOuterAlt(_localctx, 25);
				{
				State = 5307; Match(CHARACTER);
				}
				break;
			case VARCHAR2:
				EnterOuterAlt(_localctx, 26);
				{
				State = 5308; Match(VARCHAR2);
				}
				break;
			case VARCHAR:
				EnterOuterAlt(_localctx, 27);
				{
				State = 5309; Match(VARCHAR);
				}
				break;
			case STRING:
				EnterOuterAlt(_localctx, 28);
				{
				State = 5310; Match(STRING);
				}
				break;
			case RAW:
				EnterOuterAlt(_localctx, 29);
				{
				State = 5311; Match(RAW);
				}
				break;
			case BOOLEAN:
				EnterOuterAlt(_localctx, 30);
				{
				State = 5312; Match(BOOLEAN);
				}
				break;
			case DATE:
				EnterOuterAlt(_localctx, 31);
				{
				State = 5313; Match(DATE);
				}
				break;
			case ROWID:
				EnterOuterAlt(_localctx, 32);
				{
				State = 5314; Match(ROWID);
				}
				break;
			case UROWID:
				EnterOuterAlt(_localctx, 33);
				{
				State = 5315; Match(UROWID);
				}
				break;
			case YEAR:
				EnterOuterAlt(_localctx, 34);
				{
				State = 5316; Match(YEAR);
				}
				break;
			case MONTH:
				EnterOuterAlt(_localctx, 35);
				{
				State = 5317; Match(MONTH);
				}
				break;
			case DAY:
				EnterOuterAlt(_localctx, 36);
				{
				State = 5318; Match(DAY);
				}
				break;
			case HOUR:
				EnterOuterAlt(_localctx, 37);
				{
				State = 5319; Match(HOUR);
				}
				break;
			case MINUTE:
				EnterOuterAlt(_localctx, 38);
				{
				State = 5320; Match(MINUTE);
				}
				break;
			case SECOND:
				EnterOuterAlt(_localctx, 39);
				{
				State = 5321; Match(SECOND);
				}
				break;
			case TIMEZONE_HOUR:
				EnterOuterAlt(_localctx, 40);
				{
				State = 5322; Match(TIMEZONE_HOUR);
				}
				break;
			case TIMEZONE_MINUTE:
				EnterOuterAlt(_localctx, 41);
				{
				State = 5323; Match(TIMEZONE_MINUTE);
				}
				break;
			case TIMEZONE_REGION:
				EnterOuterAlt(_localctx, 42);
				{
				State = 5324; Match(TIMEZONE_REGION);
				}
				break;
			case TIMEZONE_ABBR:
				EnterOuterAlt(_localctx, 43);
				{
				State = 5325; Match(TIMEZONE_ABBR);
				}
				break;
			case TIMESTAMP:
				EnterOuterAlt(_localctx, 44);
				{
				State = 5326; Match(TIMESTAMP);
				}
				break;
			case TIMESTAMP_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 45);
				{
				State = 5327; Match(TIMESTAMP_UNCONSTRAINED);
				}
				break;
			case TIMESTAMP_TZ_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 46);
				{
				State = 5328; Match(TIMESTAMP_TZ_UNCONSTRAINED);
				}
				break;
			case TIMESTAMP_LTZ_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 47);
				{
				State = 5329; Match(TIMESTAMP_LTZ_UNCONSTRAINED);
				}
				break;
			case YMINTERVAL_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 48);
				{
				State = 5330; Match(YMINTERVAL_UNCONSTRAINED);
				}
				break;
			case DSINTERVAL_UNCONSTRAINED:
				EnterOuterAlt(_localctx, 49);
				{
				State = 5331; Match(DSINTERVAL_UNCONSTRAINED);
				}
				break;
			case BFILE:
				EnterOuterAlt(_localctx, 50);
				{
				State = 5332; Match(BFILE);
				}
				break;
			case BLOB:
				EnterOuterAlt(_localctx, 51);
				{
				State = 5333; Match(BLOB);
				}
				break;
			case CLOB:
				EnterOuterAlt(_localctx, 52);
				{
				State = 5334; Match(CLOB);
				}
				break;
			case NCLOB:
				EnterOuterAlt(_localctx, 53);
				{
				State = 5335; Match(NCLOB);
				}
				break;
			case MLSLABEL:
				EnterOuterAlt(_localctx, 54);
				{
				State = 5336; Match(MLSLABEL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Bind_variableContext : ParserRuleContext {
		public ITerminalNode[] BINDVAR() { return GetTokens(PlSqlParser.BINDVAR); }
		public ITerminalNode BINDVAR(int i) {
			return GetToken(PlSqlParser.BINDVAR, i);
		}
		public ITerminalNode[] UNSIGNED_INTEGER() { return GetTokens(PlSqlParser.UNSIGNED_INTEGER); }
		public ITerminalNode UNSIGNED_INTEGER(int i) {
			return GetToken(PlSqlParser.UNSIGNED_INTEGER, i);
		}
		public General_element_partContext[] general_element_part() {
			return GetRuleContexts<General_element_partContext>();
		}
		public General_element_partContext general_element_part(int i) {
			return GetRuleContext<General_element_partContext>(i);
		}
		public ITerminalNode INDICATOR() { return GetToken(PlSqlParser.INDICATOR, 0); }
		public Bind_variableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bind_variable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterBind_variable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitBind_variable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBind_variable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Bind_variableContext bind_variable() {
		Bind_variableContext _localctx = new Bind_variableContext(_ctx, State);
		EnterRule(_localctx, 748, RULE_bind_variable);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5342;
			switch (_input.La(1)) {
			case BINDVAR:
				{
				State = 5339; Match(BINDVAR);
				}
				break;
			case COLON:
				{
				State = 5340; Match(COLON);
				State = 5341; Match(UNSIGNED_INTEGER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 5352;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,697,_ctx) ) {
			case 1:
				{
				State = 5345;
				_la = _input.La(1);
				if (_la==INDICATOR) {
					{
					State = 5344; Match(INDICATOR);
					}
				}

				State = 5350;
				switch (_input.La(1)) {
				case BINDVAR:
					{
					State = 5347; Match(BINDVAR);
					}
					break;
				case COLON:
					{
					State = 5348; Match(COLON);
					State = 5349; Match(UNSIGNED_INTEGER);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
			State = 5358;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,698,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 5354; Match(PERIOD);
					State = 5355; general_element_part();
					}
					} 
				}
				State = 5360;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,698,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class General_elementContext : ParserRuleContext {
		public General_element_partContext[] general_element_part() {
			return GetRuleContexts<General_element_partContext>();
		}
		public General_element_partContext general_element_part(int i) {
			return GetRuleContext<General_element_partContext>(i);
		}
		public General_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_general_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterGeneral_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitGeneral_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGeneral_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public General_elementContext general_element() {
		General_elementContext _localctx = new General_elementContext(_ctx, State);
		EnterRule(_localctx, 750, RULE_general_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5361; general_element_part();
			State = 5366;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5362; Match(PERIOD);
				State = 5363; general_element_part();
				}
				}
				State = 5368;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class General_element_partContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public ITerminalNode INTRODUCER() { return GetToken(PlSqlParser.INTRODUCER, 0); }
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public Function_argumentContext function_argument() {
			return GetRuleContext<Function_argumentContext>(0);
		}
		public General_element_partContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_general_element_part; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterGeneral_element_part(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitGeneral_element_part(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGeneral_element_part(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public General_element_partContext general_element_part() {
		General_element_partContext _localctx = new General_element_partContext(_ctx, State);
		EnterRule(_localctx, 752, RULE_general_element_part);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 5371;
			_la = _input.La(1);
			if (_la==INTRODUCER) {
				{
				State = 5369; Match(INTRODUCER);
				State = 5370; char_set_name();
				}
			}

			State = 5373; id_expression();
			State = 5378;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,701,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 5374; Match(PERIOD);
					State = 5375; id_expression();
					}
					} 
				}
				State = 5380;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,701,_ctx);
			}
			State = 5382;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,702,_ctx) ) {
			case 1:
				{
				State = 5381; function_argument();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Table_elementContext : ParserRuleContext {
		public Id_expressionContext[] id_expression() {
			return GetRuleContexts<Id_expressionContext>();
		}
		public Id_expressionContext id_expression(int i) {
			return GetRuleContext<Id_expressionContext>(i);
		}
		public ITerminalNode INTRODUCER() { return GetToken(PlSqlParser.INTRODUCER, 0); }
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public Table_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_table_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterTable_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitTable_element(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTable_element(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Table_elementContext table_element() {
		Table_elementContext _localctx = new Table_elementContext(_ctx, State);
		EnterRule(_localctx, 754, RULE_table_element);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5386;
			_la = _input.La(1);
			if (_la==INTRODUCER) {
				{
				State = 5384; Match(INTRODUCER);
				State = 5385; char_set_name();
				}
			}

			State = 5388; id_expression();
			State = 5393;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==PERIOD) {
				{
				{
				State = 5389; Match(PERIOD);
				State = 5390; id_expression();
				}
				}
				State = 5395;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public ITerminalNode TIMESTAMP() { return GetToken(PlSqlParser.TIMESTAMP, 0); }
		public Quoted_stringContext[] quoted_string() {
			return GetRuleContexts<Quoted_stringContext>();
		}
		public Quoted_stringContext quoted_string(int i) {
			return GetRuleContext<Quoted_stringContext>(i);
		}
		public Bind_variableContext[] bind_variable() {
			return GetRuleContexts<Bind_variableContext>();
		}
		public Bind_variableContext bind_variable(int i) {
			return GetRuleContext<Bind_variableContext>(i);
		}
		public ITerminalNode AT() { return GetToken(PlSqlParser.AT, 0); }
		public ITerminalNode TIME() { return GetToken(PlSqlParser.TIME, 0); }
		public ITerminalNode ZONE() { return GetToken(PlSqlParser.ZONE, 0); }
		public ITerminalNode INTERVAL() { return GetToken(PlSqlParser.INTERVAL, 0); }
		public ITerminalNode[] DAY() { return GetTokens(PlSqlParser.DAY); }
		public ITerminalNode DAY(int i) {
			return GetToken(PlSqlParser.DAY, i);
		}
		public ITerminalNode[] HOUR() { return GetTokens(PlSqlParser.HOUR); }
		public ITerminalNode HOUR(int i) {
			return GetToken(PlSqlParser.HOUR, i);
		}
		public ITerminalNode[] MINUTE() { return GetTokens(PlSqlParser.MINUTE); }
		public ITerminalNode MINUTE(int i) {
			return GetToken(PlSqlParser.MINUTE, i);
		}
		public ITerminalNode[] SECOND() { return GetTokens(PlSqlParser.SECOND); }
		public ITerminalNode SECOND(int i) {
			return GetToken(PlSqlParser.SECOND, i);
		}
		public General_element_partContext general_element_part() {
			return GetRuleContext<General_element_partContext>(0);
		}
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ITerminalNode[] UNSIGNED_INTEGER() { return GetTokens(PlSqlParser.UNSIGNED_INTEGER); }
		public ITerminalNode UNSIGNED_INTEGER(int i) {
			return GetToken(PlSqlParser.UNSIGNED_INTEGER, i);
		}
		public NumericContext numeric() {
			return GetRuleContext<NumericContext>(0);
		}
		public ITerminalNode DATE() { return GetToken(PlSqlParser.DATE, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public ITerminalNode TRUE() { return GetToken(PlSqlParser.TRUE, 0); }
		public ITerminalNode FALSE() { return GetToken(PlSqlParser.FALSE, 0); }
		public ITerminalNode DBTIMEZONE() { return GetToken(PlSqlParser.DBTIMEZONE, 0); }
		public ITerminalNode SESSIONTIMEZONE() { return GetToken(PlSqlParser.SESSIONTIMEZONE, 0); }
		public ITerminalNode MINVALUE() { return GetToken(PlSqlParser.MINVALUE, 0); }
		public ITerminalNode MAXVALUE() { return GetToken(PlSqlParser.MAXVALUE, 0); }
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(_ctx, State);
		EnterRule(_localctx, 756, RULE_constant);
		int _la;
		try {
			State = 5458;
			switch (_input.La(1)) {
			case TIMESTAMP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5396; Match(TIMESTAMP);
				State = 5399;
				switch (_input.La(1)) {
				case NATIONAL_CHAR_STRING_LIT:
				case CHAR_STRING:
					{
					State = 5397; quoted_string();
					}
					break;
				case BINDVAR:
				case COLON:
					{
					State = 5398; bind_variable();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5405;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,706,_ctx) ) {
				case 1:
					{
					State = 5401; Match(AT);
					State = 5402; Match(TIME);
					State = 5403; Match(ZONE);
					State = 5404; quoted_string();
					}
					break;
				}
				}
				break;
			case INTERVAL:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5407; Match(INTERVAL);
				State = 5411;
				switch (_input.La(1)) {
				case NATIONAL_CHAR_STRING_LIT:
				case CHAR_STRING:
					{
					State = 5408; quoted_string();
					}
					break;
				case BINDVAR:
				case COLON:
					{
					State = 5409; bind_variable();
					}
					break;
				case A_LETTER:
				case ADD:
				case AFTER:
				case AGENT:
				case AGGREGATE:
				case ALL:
				case ALTER:
				case ANALYZE:
				case AND:
				case ANY:
				case ARRAY:
				case AS:
				case ASC:
				case ASSOCIATE:
				case AT:
				case ATTRIBUTE:
				case AUDIT:
				case AUTHID:
				case AUTO:
				case AUTOMATIC:
				case AUTONOMOUS_TRANSACTION:
				case BATCH:
				case BEFORE:
				case BEGIN:
				case BETWEEN:
				case BFILE:
				case BINARY_DOUBLE:
				case BINARY_FLOAT:
				case BINARY_INTEGER:
				case BLOB:
				case BLOCK:
				case BODY:
				case BOOLEAN:
				case BOTH:
				case BREADTH:
				case BULK:
				case BY:
				case BYTE:
				case C_LETTER:
				case CACHE:
				case CALL:
				case CANONICAL:
				case CASCADE:
				case CASE:
				case CAST:
				case CHAR:
				case CHAR_CS:
				case CHARACTER:
				case CHECK:
				case CHR:
				case CLOB:
				case CLOSE:
				case CLUSTER:
				case COLLECT:
				case COLUMNS:
				case COMMENT:
				case COMMIT:
				case COMMITTED:
				case COMPATIBILITY:
				case COMPILE:
				case COMPOUND:
				case CONNECT:
				case CONNECT_BY_ROOT:
				case CONSTANT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONSTRUCTOR:
				case CONTENT:
				case CONTEXT:
				case CONTINUE:
				case CONVERT:
				case CORRUPT_XID:
				case CORRUPT_XID_ALL:
				case COST:
				case COUNT:
				case CREATE:
				case CROSS:
				case CUBE:
				case CURRENT:
				case CURRENT_USER:
				case CURSOR:
				case CUSTOMDATUM:
				case CYCLE:
				case DATA:
				case DATABASE:
				case DATE:
				case DAY:
				case DB_ROLE_CHANGE:
				case DBTIMEZONE:
				case DDL:
				case DEBUG:
				case DEC:
				case DECIMAL:
				case DECLARE:
				case DECOMPOSE:
				case DECREMENT:
				case DEFAULT:
				case DEFAULTS:
				case DEFERRED:
				case DEFINER:
				case DELETE:
				case DEPTH:
				case DESC:
				case DETERMINISTIC:
				case DIMENSION:
				case DISABLE:
				case DISASSOCIATE:
				case DISTINCT:
				case DOCUMENT:
				case DOUBLE:
				case DROP:
				case DSINTERVAL_UNCONSTRAINED:
				case EACH:
				case ELEMENT:
				case ELSE:
				case ELSIF:
				case EMPTY:
				case ENABLE:
				case ENCODING:
				case END:
				case ENTITYESCAPING:
				case ERRORS:
				case ESCAPE:
				case EXCEPT:
				case EVALNAME:
				case EXCEPTION:
				case EXCEPTION_INIT:
				case EXCEPTIONS:
				case EXCLUDE:
				case EXCLUSIVE:
				case EXECUTE:
				case EXISTS:
				case EXIT:
				case EXPLAIN:
				case EXTERNAL:
				case EXTRACT:
				case FAILURE:
				case FALSE:
				case FETCH:
				case FINAL:
				case FIRST:
				case FIRST_VALUE:
				case FLOAT:
				case FOLLOWING:
				case FOLLOWS:
				case FOR:
				case FORALL:
				case FORCE:
				case FROM:
				case FULL:
				case FUNCTION:
				case GOTO:
				case GRANT:
				case GROUP:
				case GROUPING:
				case HASH:
				case HAVING:
				case HIDE:
				case HOUR:
				case IF:
				case IGNORE:
				case IMMEDIATE:
				case IN:
				case INCLUDE:
				case INCLUDING:
				case INCREMENT:
				case INDENT:
				case INDEX:
				case INDEXED:
				case INDICATOR:
				case INDICES:
				case INFINITE:
				case INLINE:
				case INNER:
				case INOUT:
				case INSERT:
				case INSTANTIABLE:
				case INSTEAD:
				case INT:
				case INTEGER:
				case INTERSECT:
				case INTERVAL:
				case INTO:
				case INVALIDATE:
				case IS:
				case ISOLATION:
				case ITERATE:
				case JAVA:
				case JOIN:
				case KEEP:
				case LANGUAGE:
				case LAST:
				case LAST_VALUE:
				case LEADING:
				case LEFT:
				case LEVEL:
				case LIBRARY:
				case LIKE:
				case LIKE2:
				case LIKE4:
				case LIKEC:
				case LIMIT:
				case LOCAL:
				case LOCK:
				case LOCKED:
				case LOG:
				case LOGOFF:
				case LOGON:
				case LONG:
				case LOOP:
				case MAIN:
				case MAP:
				case MATCHED:
				case MAXVALUE:
				case MEASURES:
				case MEMBER:
				case MERGE:
				case MINUS:
				case MINUTE:
				case MINVALUE:
				case MLSLABEL:
				case MODE:
				case MODEL:
				case MODIFY:
				case MONTH:
				case MULTISET:
				case NAME:
				case NAN:
				case NATURAL:
				case NATURALN:
				case NAV:
				case NCHAR:
				case NCHAR_CS:
				case NCLOB:
				case NESTED:
				case NEW:
				case NO:
				case NOAUDIT:
				case NOCACHE:
				case NOCOPY:
				case NOCYCLE:
				case NOENTITYESCAPING:
				case NOMAXVALUE:
				case NOMINVALUE:
				case NONE:
				case NOORDER:
				case NOSCHEMACHECK:
				case NOT:
				case NOWAIT:
				case NULL:
				case NULLS:
				case NUMBER:
				case NUMERIC:
				case NVARCHAR2:
				case OBJECT:
				case OF:
				case OFF:
				case OID:
				case OLD:
				case ON:
				case ONLY:
				case OPEN:
				case OPTION:
				case OR:
				case ORADATA:
				case ORDER:
				case ORDINALITY:
				case OSERROR:
				case OUT:
				case OUTER:
				case OVER:
				case OVERRIDING:
				case PACKAGE:
				case PARALLEL_ENABLE:
				case PARAMETERS:
				case PARENT:
				case PARTITION:
				case PASSING:
				case PATH:
				case PIPELINED:
				case PIVOT:
				case PLAN:
				case PLS_INTEGER:
				case POSITIVE:
				case POSITIVEN:
				case PRAGMA:
				case PRECEDING:
				case PRECISION:
				case PRESENT:
				case PRIOR:
				case PROCEDURE:
				case RAISE:
				case RANGE:
				case RAW:
				case READ:
				case REAL:
				case RECORD:
				case REF:
				case REFERENCE:
				case REFERENCING:
				case REJECT:
				case RELIES_ON:
				case RENAME:
				case REPLACE:
				case RESPECT:
				case RESTRICT_REFERENCES:
				case RESULT:
				case RESULT_CACHE:
				case RETURN:
				case RETURNING:
				case REUSE:
				case REVERSE:
				case REVOKE:
				case RIGHT:
				case ROLLBACK:
				case ROLLUP:
				case ROW:
				case ROWID:
				case ROWS:
				case RULES:
				case SAMPLE:
				case SAVE:
				case SAVEPOINT:
				case SCHEMA:
				case SCHEMACHECK:
				case SCN:
				case SEARCH:
				case SECOND:
				case SEED:
				case SEGMENT:
				case SELECT:
				case SELF:
				case SEQUENCE:
				case SEQUENTIAL:
				case SERIALIZABLE:
				case SERIALLY_REUSABLE:
				case SERVERERROR:
				case SESSIONTIMEZONE:
				case SET:
				case SETS:
				case SETTINGS:
				case SHARE:
				case SHOW:
				case SHUTDOWN:
				case SIBLINGS:
				case SIGNTYPE:
				case SIMPLE_INTEGER:
				case SINGLE:
				case SIZE:
				case SKIP_:
				case SMALLINT:
				case SNAPSHOT:
				case SOME:
				case SPECIFICATION:
				case SQLDATA:
				case SQLERROR:
				case SQL_PERCENT_ROWCOUNT:
				case STANDALONE:
				case START:
				case STARTUP:
				case STATEMENT:
				case STATEMENT_ID:
				case STATIC:
				case STATISTICS:
				case STRING:
				case SUBMULTISET:
				case SUBPARTITION:
				case SUBSTITUTABLE:
				case SUBTYPE:
				case SUCCESS:
				case SUSPEND:
				case TABLE:
				case THE:
				case THEN:
				case TIME:
				case TIMESTAMP:
				case TIMESTAMP_LTZ_UNCONSTRAINED:
				case TIMESTAMP_TZ_UNCONSTRAINED:
				case TIMESTAMP_UNCONSTRAINED:
				case TIMEZONE_ABBR:
				case TIMEZONE_HOUR:
				case TIMEZONE_MINUTE:
				case TIMEZONE_REGION:
				case TO:
				case TO_CHAR:
				case TRAILING:
				case TRANSACTION:
				case TRANSLATE:
				case TREAT:
				case TRIGGER:
				case TRIM:
				case TRUE:
				case TRUNCATE:
				case TYPE:
				case UNBOUNDED:
				case UNDER:
				case UNION:
				case UNIQUE:
				case UNLIMITED:
				case UNPIVOT:
				case UNTIL:
				case UPDATE:
				case UPDATED:
				case UPSERT:
				case UROWID:
				case USE:
				case USING:
				case VALIDATE:
				case VALUE:
				case VALUES:
				case VARCHAR:
				case VARCHAR2:
				case VARIABLE:
				case VARRAY:
				case VARYING:
				case VERSION:
				case VERSIONS:
				case WAIT:
				case WARNING:
				case WELLFORMED:
				case WHEN:
				case WHENEVER:
				case WHERE:
				case WHILE:
				case WITH:
				case WITHIN:
				case WORK:
				case WRITE:
				case XML:
				case XMLAGG:
				case XMLATTRIBUTES:
				case XMLCAST:
				case XMLCOLATTVAL:
				case XMLELEMENT:
				case XMLEXISTS:
				case XMLFOREST:
				case XMLNAMESPACES:
				case XMLPARSE:
				case XMLPI:
				case XMLQUERY:
				case XMLROOT:
				case XMLSERIALIZE:
				case XMLTABLE:
				case YEAR:
				case YES:
				case YMINTERVAL_UNCONSTRAINED:
				case ZONE:
				case PREDICTION:
				case PREDICTION_BOUNDS:
				case PREDICTION_COST:
				case PREDICTION_DETAILS:
				case PREDICTION_PROBABILITY:
				case PREDICTION_SET:
				case CUME_DIST:
				case DENSE_RANK:
				case LISTAGG:
				case PERCENT_RANK:
				case PERCENTILE_CONT:
				case PERCENTILE_DISC:
				case RANK:
				case AVG:
				case CORR:
				case LAG:
				case LEAD:
				case MAX:
				case MEDIAN:
				case MIN:
				case NTILE:
				case RATIO_TO_REPORT:
				case ROW_NUMBER:
				case SUM:
				case VARIANCE:
				case REGR_:
				case STDDEV:
				case VAR_:
				case COVAR_:
				case DELIMITED_ID:
				case INTRODUCER:
				case REGULAR_ID:
					{
					State = 5410; general_element_part();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 5413;
				_la = _input.La(1);
				if ( !(_la==DAY || _la==HOUR || _la==MINUTE || _la==SECOND) ) {
				_errHandler.RecoverInline(this);
				} else {
					Consume();
				}
				State = 5427;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,711,_ctx) ) {
				case 1:
					{
					State = 5414; Match(LEFT_PAREN);
					State = 5417;
					switch (_input.La(1)) {
					case UNSIGNED_INTEGER:
						{
						State = 5415; Match(UNSIGNED_INTEGER);
						}
						break;
					case BINDVAR:
					case COLON:
						{
						State = 5416; bind_variable();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 5424;
					_la = _input.La(1);
					if (_la==COMMA) {
						{
						State = 5419; Match(COMMA);
						State = 5422;
						switch (_input.La(1)) {
						case UNSIGNED_INTEGER:
							{
							State = 5420; Match(UNSIGNED_INTEGER);
							}
							break;
						case BINDVAR:
						case COLON:
							{
							State = 5421; bind_variable();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
					}

					State = 5426; Match(RIGHT_PAREN);
					}
					break;
				}
				State = 5444;
				_errHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(_input,715,_ctx) ) {
				case 1:
					{
					State = 5429; Match(TO);
					State = 5442;
					switch (_input.La(1)) {
					case DAY:
						{
						State = 5430; Match(DAY);
						}
						break;
					case HOUR:
						{
						State = 5431; Match(HOUR);
						}
						break;
					case MINUTE:
						{
						State = 5432; Match(MINUTE);
						}
						break;
					case SECOND:
						{
						State = 5433; Match(SECOND);
						State = 5440;
						_errHandler.Sync(this);
						switch ( Interpreter.AdaptivePredict(_input,713,_ctx) ) {
						case 1:
							{
							State = 5434; Match(LEFT_PAREN);
							State = 5437;
							switch (_input.La(1)) {
							case UNSIGNED_INTEGER:
								{
								State = 5435; Match(UNSIGNED_INTEGER);
								}
								break;
							case BINDVAR:
							case COLON:
								{
								State = 5436; bind_variable();
								}
								break;
							default:
								throw new NoViableAltException(this);
							}
							State = 5439; Match(RIGHT_PAREN);
							}
							break;
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				}
				}
				break;
			case UNSIGNED_INTEGER:
			case APPROXIMATE_NUM_LIT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5446; numeric();
				}
				break;
			case DATE:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5447; Match(DATE);
				State = 5448; quoted_string();
				}
				break;
			case NATIONAL_CHAR_STRING_LIT:
			case CHAR_STRING:
				EnterOuterAlt(_localctx, 5);
				{
				State = 5449; quoted_string();
				}
				break;
			case NULL:
				EnterOuterAlt(_localctx, 6);
				{
				State = 5450; Match(NULL);
				}
				break;
			case TRUE:
				EnterOuterAlt(_localctx, 7);
				{
				State = 5451; Match(TRUE);
				}
				break;
			case FALSE:
				EnterOuterAlt(_localctx, 8);
				{
				State = 5452; Match(FALSE);
				}
				break;
			case DBTIMEZONE:
				EnterOuterAlt(_localctx, 9);
				{
				State = 5453; Match(DBTIMEZONE);
				}
				break;
			case SESSIONTIMEZONE:
				EnterOuterAlt(_localctx, 10);
				{
				State = 5454; Match(SESSIONTIMEZONE);
				}
				break;
			case MINVALUE:
				EnterOuterAlt(_localctx, 11);
				{
				State = 5455; Match(MINVALUE);
				}
				break;
			case MAXVALUE:
				EnterOuterAlt(_localctx, 12);
				{
				State = 5456; Match(MAXVALUE);
				}
				break;
			case DEFAULT:
				EnterOuterAlt(_localctx, 13);
				{
				State = 5457; Match(DEFAULT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumericContext : ParserRuleContext {
		public ITerminalNode UNSIGNED_INTEGER() { return GetToken(PlSqlParser.UNSIGNED_INTEGER, 0); }
		public ITerminalNode APPROXIMATE_NUM_LIT() { return GetToken(PlSqlParser.APPROXIMATE_NUM_LIT, 0); }
		public NumericContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numeric; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterNumeric(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitNumeric(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumeric(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumericContext numeric() {
		NumericContext _localctx = new NumericContext(_ctx, State);
		EnterRule(_localctx, 758, RULE_numeric);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5460;
			_la = _input.La(1);
			if ( !(_la==UNSIGNED_INTEGER || _la==APPROXIMATE_NUM_LIT) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Quoted_stringContext : ParserRuleContext {
		public ITerminalNode CHAR_STRING() { return GetToken(PlSqlParser.CHAR_STRING, 0); }
		public ITerminalNode NATIONAL_CHAR_STRING_LIT() { return GetToken(PlSqlParser.NATIONAL_CHAR_STRING_LIT, 0); }
		public Quoted_stringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quoted_string; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterQuoted_string(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitQuoted_string(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuoted_string(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Quoted_stringContext quoted_string() {
		Quoted_stringContext _localctx = new Quoted_stringContext(_ctx, State);
		EnterRule(_localctx, 760, RULE_quoted_string);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5462;
			_la = _input.La(1);
			if ( !(_la==NATIONAL_CHAR_STRING_LIT || _la==CHAR_STRING) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdContext : ParserRuleContext {
		public Id_expressionContext id_expression() {
			return GetRuleContext<Id_expressionContext>(0);
		}
		public ITerminalNode INTRODUCER() { return GetToken(PlSqlParser.INTRODUCER, 0); }
		public Char_set_nameContext char_set_name() {
			return GetRuleContext<Char_set_nameContext>(0);
		}
		public IdContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_id; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterId(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitId(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitId(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdContext id() {
		IdContext _localctx = new IdContext(_ctx, State);
		EnterRule(_localctx, 762, RULE_id);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5466;
			_la = _input.La(1);
			if (_la==INTRODUCER) {
				{
				State = 5464; Match(INTRODUCER);
				State = 5465; char_set_name();
				}
			}

			State = 5468; id_expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Id_expressionContext : ParserRuleContext {
		public Regular_idContext regular_id() {
			return GetRuleContext<Regular_idContext>(0);
		}
		public ITerminalNode DELIMITED_ID() { return GetToken(PlSqlParser.DELIMITED_ID, 0); }
		public Id_expressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_id_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterId_expression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitId_expression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitId_expression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Id_expressionContext id_expression() {
		Id_expressionContext _localctx = new Id_expressionContext(_ctx, State);
		EnterRule(_localctx, 764, RULE_id_expression);
		try {
			State = 5472;
			switch (_input.La(1)) {
			case A_LETTER:
			case ADD:
			case AFTER:
			case AGENT:
			case AGGREGATE:
			case ALL:
			case ALTER:
			case ANALYZE:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASSOCIATE:
			case AT:
			case ATTRIBUTE:
			case AUDIT:
			case AUTHID:
			case AUTO:
			case AUTOMATIC:
			case AUTONOMOUS_TRANSACTION:
			case BATCH:
			case BEFORE:
			case BEGIN:
			case BETWEEN:
			case BFILE:
			case BINARY_DOUBLE:
			case BINARY_FLOAT:
			case BINARY_INTEGER:
			case BLOB:
			case BLOCK:
			case BODY:
			case BOOLEAN:
			case BOTH:
			case BREADTH:
			case BULK:
			case BY:
			case BYTE:
			case C_LETTER:
			case CACHE:
			case CALL:
			case CANONICAL:
			case CASCADE:
			case CASE:
			case CAST:
			case CHAR:
			case CHAR_CS:
			case CHARACTER:
			case CHECK:
			case CHR:
			case CLOB:
			case CLOSE:
			case CLUSTER:
			case COLLECT:
			case COLUMNS:
			case COMMENT:
			case COMMIT:
			case COMMITTED:
			case COMPATIBILITY:
			case COMPILE:
			case COMPOUND:
			case CONNECT:
			case CONNECT_BY_ROOT:
			case CONSTANT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONSTRUCTOR:
			case CONTENT:
			case CONTEXT:
			case CONTINUE:
			case CONVERT:
			case CORRUPT_XID:
			case CORRUPT_XID_ALL:
			case COST:
			case COUNT:
			case CREATE:
			case CROSS:
			case CUBE:
			case CURRENT:
			case CURRENT_USER:
			case CURSOR:
			case CUSTOMDATUM:
			case CYCLE:
			case DATA:
			case DATABASE:
			case DATE:
			case DAY:
			case DB_ROLE_CHANGE:
			case DBTIMEZONE:
			case DDL:
			case DEBUG:
			case DEC:
			case DECIMAL:
			case DECLARE:
			case DECOMPOSE:
			case DECREMENT:
			case DEFAULT:
			case DEFAULTS:
			case DEFERRED:
			case DEFINER:
			case DELETE:
			case DEPTH:
			case DESC:
			case DETERMINISTIC:
			case DIMENSION:
			case DISABLE:
			case DISASSOCIATE:
			case DISTINCT:
			case DOCUMENT:
			case DOUBLE:
			case DROP:
			case DSINTERVAL_UNCONSTRAINED:
			case EACH:
			case ELEMENT:
			case ELSE:
			case ELSIF:
			case EMPTY:
			case ENABLE:
			case ENCODING:
			case END:
			case ENTITYESCAPING:
			case ERRORS:
			case ESCAPE:
			case EXCEPT:
			case EVALNAME:
			case EXCEPTION:
			case EXCEPTION_INIT:
			case EXCEPTIONS:
			case EXCLUDE:
			case EXCLUSIVE:
			case EXECUTE:
			case EXISTS:
			case EXIT:
			case EXPLAIN:
			case EXTERNAL:
			case EXTRACT:
			case FAILURE:
			case FALSE:
			case FETCH:
			case FINAL:
			case FIRST:
			case FIRST_VALUE:
			case FLOAT:
			case FOLLOWING:
			case FOLLOWS:
			case FOR:
			case FORALL:
			case FORCE:
			case FROM:
			case FULL:
			case FUNCTION:
			case GOTO:
			case GRANT:
			case GROUP:
			case GROUPING:
			case HASH:
			case HAVING:
			case HIDE:
			case HOUR:
			case IF:
			case IGNORE:
			case IMMEDIATE:
			case IN:
			case INCLUDE:
			case INCLUDING:
			case INCREMENT:
			case INDENT:
			case INDEX:
			case INDEXED:
			case INDICATOR:
			case INDICES:
			case INFINITE:
			case INLINE:
			case INNER:
			case INOUT:
			case INSERT:
			case INSTANTIABLE:
			case INSTEAD:
			case INT:
			case INTEGER:
			case INTERSECT:
			case INTERVAL:
			case INTO:
			case INVALIDATE:
			case IS:
			case ISOLATION:
			case ITERATE:
			case JAVA:
			case JOIN:
			case KEEP:
			case LANGUAGE:
			case LAST:
			case LAST_VALUE:
			case LEADING:
			case LEFT:
			case LEVEL:
			case LIBRARY:
			case LIKE:
			case LIKE2:
			case LIKE4:
			case LIKEC:
			case LIMIT:
			case LOCAL:
			case LOCK:
			case LOCKED:
			case LOG:
			case LOGOFF:
			case LOGON:
			case LONG:
			case LOOP:
			case MAIN:
			case MAP:
			case MATCHED:
			case MAXVALUE:
			case MEASURES:
			case MEMBER:
			case MERGE:
			case MINUS:
			case MINUTE:
			case MINVALUE:
			case MLSLABEL:
			case MODE:
			case MODEL:
			case MODIFY:
			case MONTH:
			case MULTISET:
			case NAME:
			case NAN:
			case NATURAL:
			case NATURALN:
			case NAV:
			case NCHAR:
			case NCHAR_CS:
			case NCLOB:
			case NESTED:
			case NEW:
			case NO:
			case NOAUDIT:
			case NOCACHE:
			case NOCOPY:
			case NOCYCLE:
			case NOENTITYESCAPING:
			case NOMAXVALUE:
			case NOMINVALUE:
			case NONE:
			case NOORDER:
			case NOSCHEMACHECK:
			case NOT:
			case NOWAIT:
			case NULL:
			case NULLS:
			case NUMBER:
			case NUMERIC:
			case NVARCHAR2:
			case OBJECT:
			case OF:
			case OFF:
			case OID:
			case OLD:
			case ON:
			case ONLY:
			case OPEN:
			case OPTION:
			case OR:
			case ORADATA:
			case ORDER:
			case ORDINALITY:
			case OSERROR:
			case OUT:
			case OUTER:
			case OVER:
			case OVERRIDING:
			case PACKAGE:
			case PARALLEL_ENABLE:
			case PARAMETERS:
			case PARENT:
			case PARTITION:
			case PASSING:
			case PATH:
			case PIPELINED:
			case PIVOT:
			case PLAN:
			case PLS_INTEGER:
			case POSITIVE:
			case POSITIVEN:
			case PRAGMA:
			case PRECEDING:
			case PRECISION:
			case PRESENT:
			case PRIOR:
			case PROCEDURE:
			case RAISE:
			case RANGE:
			case RAW:
			case READ:
			case REAL:
			case RECORD:
			case REF:
			case REFERENCE:
			case REFERENCING:
			case REJECT:
			case RELIES_ON:
			case RENAME:
			case REPLACE:
			case RESPECT:
			case RESTRICT_REFERENCES:
			case RESULT:
			case RESULT_CACHE:
			case RETURN:
			case RETURNING:
			case REUSE:
			case REVERSE:
			case REVOKE:
			case RIGHT:
			case ROLLBACK:
			case ROLLUP:
			case ROW:
			case ROWID:
			case ROWS:
			case RULES:
			case SAMPLE:
			case SAVE:
			case SAVEPOINT:
			case SCHEMA:
			case SCHEMACHECK:
			case SCN:
			case SEARCH:
			case SECOND:
			case SEED:
			case SEGMENT:
			case SELECT:
			case SELF:
			case SEQUENCE:
			case SEQUENTIAL:
			case SERIALIZABLE:
			case SERIALLY_REUSABLE:
			case SERVERERROR:
			case SESSIONTIMEZONE:
			case SET:
			case SETS:
			case SETTINGS:
			case SHARE:
			case SHOW:
			case SHUTDOWN:
			case SIBLINGS:
			case SIGNTYPE:
			case SIMPLE_INTEGER:
			case SINGLE:
			case SIZE:
			case SKIP_:
			case SMALLINT:
			case SNAPSHOT:
			case SOME:
			case SPECIFICATION:
			case SQLDATA:
			case SQLERROR:
			case SQL_PERCENT_ROWCOUNT:
			case STANDALONE:
			case START:
			case STARTUP:
			case STATEMENT:
			case STATEMENT_ID:
			case STATIC:
			case STATISTICS:
			case STRING:
			case SUBMULTISET:
			case SUBPARTITION:
			case SUBSTITUTABLE:
			case SUBTYPE:
			case SUCCESS:
			case SUSPEND:
			case TABLE:
			case THE:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMESTAMP_LTZ_UNCONSTRAINED:
			case TIMESTAMP_TZ_UNCONSTRAINED:
			case TIMESTAMP_UNCONSTRAINED:
			case TIMEZONE_ABBR:
			case TIMEZONE_HOUR:
			case TIMEZONE_MINUTE:
			case TIMEZONE_REGION:
			case TO:
			case TO_CHAR:
			case TRAILING:
			case TRANSACTION:
			case TRANSLATE:
			case TREAT:
			case TRIGGER:
			case TRIM:
			case TRUE:
			case TRUNCATE:
			case TYPE:
			case UNBOUNDED:
			case UNDER:
			case UNION:
			case UNIQUE:
			case UNLIMITED:
			case UNPIVOT:
			case UNTIL:
			case UPDATE:
			case UPDATED:
			case UPSERT:
			case UROWID:
			case USE:
			case USING:
			case VALIDATE:
			case VALUE:
			case VALUES:
			case VARCHAR:
			case VARCHAR2:
			case VARIABLE:
			case VARRAY:
			case VARYING:
			case VERSION:
			case VERSIONS:
			case WAIT:
			case WARNING:
			case WELLFORMED:
			case WHEN:
			case WHENEVER:
			case WHERE:
			case WHILE:
			case WITH:
			case WITHIN:
			case WORK:
			case WRITE:
			case XML:
			case XMLAGG:
			case XMLATTRIBUTES:
			case XMLCAST:
			case XMLCOLATTVAL:
			case XMLELEMENT:
			case XMLEXISTS:
			case XMLFOREST:
			case XMLNAMESPACES:
			case XMLPARSE:
			case XMLPI:
			case XMLQUERY:
			case XMLROOT:
			case XMLSERIALIZE:
			case XMLTABLE:
			case YEAR:
			case YES:
			case YMINTERVAL_UNCONSTRAINED:
			case ZONE:
			case PREDICTION:
			case PREDICTION_BOUNDS:
			case PREDICTION_COST:
			case PREDICTION_DETAILS:
			case PREDICTION_PROBABILITY:
			case PREDICTION_SET:
			case CUME_DIST:
			case DENSE_RANK:
			case LISTAGG:
			case PERCENT_RANK:
			case PERCENTILE_CONT:
			case PERCENTILE_DISC:
			case RANK:
			case AVG:
			case CORR:
			case LAG:
			case LEAD:
			case MAX:
			case MEDIAN:
			case MIN:
			case NTILE:
			case RATIO_TO_REPORT:
			case ROW_NUMBER:
			case SUM:
			case VARIANCE:
			case REGR_:
			case STDDEV:
			case VAR_:
			case COVAR_:
			case REGULAR_ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5470; regular_id();
				}
				break;
			case DELIMITED_ID:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5471; Match(DELIMITED_ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Not_equal_opContext : ParserRuleContext {
		public ITerminalNode NOT_EQUAL_OP() { return GetToken(PlSqlParser.NOT_EQUAL_OP, 0); }
		public Not_equal_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_not_equal_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterNot_equal_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitNot_equal_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNot_equal_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Not_equal_opContext not_equal_op() {
		Not_equal_opContext _localctx = new Not_equal_opContext(_ctx, State);
		EnterRule(_localctx, 766, RULE_not_equal_op);
		try {
			State = 5481;
			switch (_input.La(1)) {
			case NOT_EQUAL_OP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5474; Match(NOT_EQUAL_OP);
				}
				break;
			case LESS_THAN_OP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5475; Match(LESS_THAN_OP);
				State = 5476; Match(GREATER_THAN_OP);
				}
				break;
			case EXCLAMATION_OPERATOR_PART:
				EnterOuterAlt(_localctx, 3);
				{
				State = 5477; Match(EXCLAMATION_OPERATOR_PART);
				State = 5478; Match(EQUALS_OP);
				}
				break;
			case CARRET_OPERATOR_PART:
				EnterOuterAlt(_localctx, 4);
				{
				State = 5479; Match(CARRET_OPERATOR_PART);
				State = 5480; Match(EQUALS_OP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Greater_than_or_equals_opContext : ParserRuleContext {
		public Greater_than_or_equals_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_greater_than_or_equals_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterGreater_than_or_equals_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitGreater_than_or_equals_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGreater_than_or_equals_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Greater_than_or_equals_opContext greater_than_or_equals_op() {
		Greater_than_or_equals_opContext _localctx = new Greater_than_or_equals_opContext(_ctx, State);
		EnterRule(_localctx, 768, RULE_greater_than_or_equals_op);
		try {
			State = 5486;
			switch (_input.La(1)) {
			case GREATER_THAN_OR_EQUALS_OP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5483; Match(GREATER_THAN_OR_EQUALS_OP);
				}
				break;
			case GREATER_THAN_OP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5484; Match(GREATER_THAN_OP);
				State = 5485; Match(EQUALS_OP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Less_than_or_equals_opContext : ParserRuleContext {
		public Less_than_or_equals_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_less_than_or_equals_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterLess_than_or_equals_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitLess_than_or_equals_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLess_than_or_equals_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Less_than_or_equals_opContext less_than_or_equals_op() {
		Less_than_or_equals_opContext _localctx = new Less_than_or_equals_opContext(_ctx, State);
		EnterRule(_localctx, 770, RULE_less_than_or_equals_op);
		try {
			State = 5491;
			switch (_input.La(1)) {
			case LESS_THAN_OR_EQUALS_OP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5488; Match(LESS_THAN_OR_EQUALS_OP);
				}
				break;
			case LESS_THAN_OP:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5489; Match(LESS_THAN_OP);
				State = 5490; Match(EQUALS_OP);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Concatenation_opContext : ParserRuleContext {
		public Concatenation_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_concatenation_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterConcatenation_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitConcatenation_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConcatenation_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Concatenation_opContext concatenation_op() {
		Concatenation_opContext _localctx = new Concatenation_opContext(_ctx, State);
		EnterRule(_localctx, 772, RULE_concatenation_op);
		try {
			State = 5496;
			switch (_input.La(1)) {
			case CONCATENATION_OP:
				EnterOuterAlt(_localctx, 1);
				{
				State = 5493; Match(CONCATENATION_OP);
				}
				break;
			case VERTICAL_BAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 5494; Match(VERTICAL_BAR);
				State = 5495; Match(VERTICAL_BAR);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Outer_join_signContext : ParserRuleContext {
		public Outer_join_signContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_outer_join_sign; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterOuter_join_sign(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitOuter_join_sign(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOuter_join_sign(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Outer_join_signContext outer_join_sign() {
		Outer_join_signContext _localctx = new Outer_join_signContext(_ctx, State);
		EnterRule(_localctx, 774, RULE_outer_join_sign);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5498; Match(LEFT_PAREN);
			State = 5499; Match(PLUS_SIGN);
			State = 5500; Match(RIGHT_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Regular_idContext : ParserRuleContext {
		public ITerminalNode REGULAR_ID() { return GetToken(PlSqlParser.REGULAR_ID, 0); }
		public ITerminalNode A_LETTER() { return GetToken(PlSqlParser.A_LETTER, 0); }
		public ITerminalNode ADD() { return GetToken(PlSqlParser.ADD, 0); }
		public ITerminalNode AFTER() { return GetToken(PlSqlParser.AFTER, 0); }
		public ITerminalNode AGENT() { return GetToken(PlSqlParser.AGENT, 0); }
		public ITerminalNode AGGREGATE() { return GetToken(PlSqlParser.AGGREGATE, 0); }
		public ITerminalNode ALL() { return GetToken(PlSqlParser.ALL, 0); }
		public ITerminalNode ALTER() { return GetToken(PlSqlParser.ALTER, 0); }
		public ITerminalNode ANALYZE() { return GetToken(PlSqlParser.ANALYZE, 0); }
		public ITerminalNode AND() { return GetToken(PlSqlParser.AND, 0); }
		public ITerminalNode ANY() { return GetToken(PlSqlParser.ANY, 0); }
		public ITerminalNode ARRAY() { return GetToken(PlSqlParser.ARRAY, 0); }
		public ITerminalNode AS() { return GetToken(PlSqlParser.AS, 0); }
		public ITerminalNode ASC() { return GetToken(PlSqlParser.ASC, 0); }
		public ITerminalNode ASSOCIATE() { return GetToken(PlSqlParser.ASSOCIATE, 0); }
		public ITerminalNode AT() { return GetToken(PlSqlParser.AT, 0); }
		public ITerminalNode ATTRIBUTE() { return GetToken(PlSqlParser.ATTRIBUTE, 0); }
		public ITerminalNode AUDIT() { return GetToken(PlSqlParser.AUDIT, 0); }
		public ITerminalNode AUTHID() { return GetToken(PlSqlParser.AUTHID, 0); }
		public ITerminalNode AUTO() { return GetToken(PlSqlParser.AUTO, 0); }
		public ITerminalNode AUTOMATIC() { return GetToken(PlSqlParser.AUTOMATIC, 0); }
		public ITerminalNode AUTONOMOUS_TRANSACTION() { return GetToken(PlSqlParser.AUTONOMOUS_TRANSACTION, 0); }
		public ITerminalNode BATCH() { return GetToken(PlSqlParser.BATCH, 0); }
		public ITerminalNode BEFORE() { return GetToken(PlSqlParser.BEFORE, 0); }
		public ITerminalNode BEGIN() { return GetToken(PlSqlParser.BEGIN, 0); }
		public ITerminalNode BETWEEN() { return GetToken(PlSqlParser.BETWEEN, 0); }
		public ITerminalNode BFILE() { return GetToken(PlSqlParser.BFILE, 0); }
		public ITerminalNode BINARY_DOUBLE() { return GetToken(PlSqlParser.BINARY_DOUBLE, 0); }
		public ITerminalNode BINARY_FLOAT() { return GetToken(PlSqlParser.BINARY_FLOAT, 0); }
		public ITerminalNode BINARY_INTEGER() { return GetToken(PlSqlParser.BINARY_INTEGER, 0); }
		public ITerminalNode BLOB() { return GetToken(PlSqlParser.BLOB, 0); }
		public ITerminalNode BLOCK() { return GetToken(PlSqlParser.BLOCK, 0); }
		public ITerminalNode BODY() { return GetToken(PlSqlParser.BODY, 0); }
		public ITerminalNode BOOLEAN() { return GetToken(PlSqlParser.BOOLEAN, 0); }
		public ITerminalNode BOTH() { return GetToken(PlSqlParser.BOTH, 0); }
		public ITerminalNode BREADTH() { return GetToken(PlSqlParser.BREADTH, 0); }
		public ITerminalNode BULK() { return GetToken(PlSqlParser.BULK, 0); }
		public ITerminalNode BY() { return GetToken(PlSqlParser.BY, 0); }
		public ITerminalNode BYTE() { return GetToken(PlSqlParser.BYTE, 0); }
		public ITerminalNode C_LETTER() { return GetToken(PlSqlParser.C_LETTER, 0); }
		public ITerminalNode CACHE() { return GetToken(PlSqlParser.CACHE, 0); }
		public ITerminalNode CALL() { return GetToken(PlSqlParser.CALL, 0); }
		public ITerminalNode CANONICAL() { return GetToken(PlSqlParser.CANONICAL, 0); }
		public ITerminalNode CASCADE() { return GetToken(PlSqlParser.CASCADE, 0); }
		public ITerminalNode CASE() { return GetToken(PlSqlParser.CASE, 0); }
		public ITerminalNode CAST() { return GetToken(PlSqlParser.CAST, 0); }
		public ITerminalNode CHAR() { return GetToken(PlSqlParser.CHAR, 0); }
		public ITerminalNode CHAR_CS() { return GetToken(PlSqlParser.CHAR_CS, 0); }
		public ITerminalNode CHARACTER() { return GetToken(PlSqlParser.CHARACTER, 0); }
		public ITerminalNode CHECK() { return GetToken(PlSqlParser.CHECK, 0); }
		public ITerminalNode CHR() { return GetToken(PlSqlParser.CHR, 0); }
		public ITerminalNode CLOB() { return GetToken(PlSqlParser.CLOB, 0); }
		public ITerminalNode CLOSE() { return GetToken(PlSqlParser.CLOSE, 0); }
		public ITerminalNode CLUSTER() { return GetToken(PlSqlParser.CLUSTER, 0); }
		public ITerminalNode COLLECT() { return GetToken(PlSqlParser.COLLECT, 0); }
		public ITerminalNode COLUMNS() { return GetToken(PlSqlParser.COLUMNS, 0); }
		public ITerminalNode COMMENT() { return GetToken(PlSqlParser.COMMENT, 0); }
		public ITerminalNode COMMIT() { return GetToken(PlSqlParser.COMMIT, 0); }
		public ITerminalNode COMMITTED() { return GetToken(PlSqlParser.COMMITTED, 0); }
		public ITerminalNode COMPATIBILITY() { return GetToken(PlSqlParser.COMPATIBILITY, 0); }
		public ITerminalNode COMPILE() { return GetToken(PlSqlParser.COMPILE, 0); }
		public ITerminalNode COMPOUND() { return GetToken(PlSqlParser.COMPOUND, 0); }
		public ITerminalNode CONNECT() { return GetToken(PlSqlParser.CONNECT, 0); }
		public ITerminalNode CONNECT_BY_ROOT() { return GetToken(PlSqlParser.CONNECT_BY_ROOT, 0); }
		public ITerminalNode CONSTANT() { return GetToken(PlSqlParser.CONSTANT, 0); }
		public ITerminalNode CONSTRAINT() { return GetToken(PlSqlParser.CONSTRAINT, 0); }
		public ITerminalNode CONSTRAINTS() { return GetToken(PlSqlParser.CONSTRAINTS, 0); }
		public ITerminalNode CONSTRUCTOR() { return GetToken(PlSqlParser.CONSTRUCTOR, 0); }
		public ITerminalNode CONTENT() { return GetToken(PlSqlParser.CONTENT, 0); }
		public ITerminalNode CONTEXT() { return GetToken(PlSqlParser.CONTEXT, 0); }
		public ITerminalNode CONTINUE() { return GetToken(PlSqlParser.CONTINUE, 0); }
		public ITerminalNode CONVERT() { return GetToken(PlSqlParser.CONVERT, 0); }
		public ITerminalNode CORRUPT_XID() { return GetToken(PlSqlParser.CORRUPT_XID, 0); }
		public ITerminalNode CORRUPT_XID_ALL() { return GetToken(PlSqlParser.CORRUPT_XID_ALL, 0); }
		public ITerminalNode COST() { return GetToken(PlSqlParser.COST, 0); }
		public ITerminalNode COUNT() { return GetToken(PlSqlParser.COUNT, 0); }
		public ITerminalNode CREATE() { return GetToken(PlSqlParser.CREATE, 0); }
		public ITerminalNode CROSS() { return GetToken(PlSqlParser.CROSS, 0); }
		public ITerminalNode CUBE() { return GetToken(PlSqlParser.CUBE, 0); }
		public ITerminalNode CURRENT() { return GetToken(PlSqlParser.CURRENT, 0); }
		public ITerminalNode CURRENT_USER() { return GetToken(PlSqlParser.CURRENT_USER, 0); }
		public ITerminalNode CURSOR() { return GetToken(PlSqlParser.CURSOR, 0); }
		public ITerminalNode CUSTOMDATUM() { return GetToken(PlSqlParser.CUSTOMDATUM, 0); }
		public ITerminalNode CYCLE() { return GetToken(PlSqlParser.CYCLE, 0); }
		public ITerminalNode DATA() { return GetToken(PlSqlParser.DATA, 0); }
		public ITerminalNode DATABASE() { return GetToken(PlSqlParser.DATABASE, 0); }
		public ITerminalNode DATE() { return GetToken(PlSqlParser.DATE, 0); }
		public ITerminalNode DAY() { return GetToken(PlSqlParser.DAY, 0); }
		public ITerminalNode DB_ROLE_CHANGE() { return GetToken(PlSqlParser.DB_ROLE_CHANGE, 0); }
		public ITerminalNode DBTIMEZONE() { return GetToken(PlSqlParser.DBTIMEZONE, 0); }
		public ITerminalNode DDL() { return GetToken(PlSqlParser.DDL, 0); }
		public ITerminalNode DEBUG() { return GetToken(PlSqlParser.DEBUG, 0); }
		public ITerminalNode DEC() { return GetToken(PlSqlParser.DEC, 0); }
		public ITerminalNode DECIMAL() { return GetToken(PlSqlParser.DECIMAL, 0); }
		public ITerminalNode DECLARE() { return GetToken(PlSqlParser.DECLARE, 0); }
		public ITerminalNode DECOMPOSE() { return GetToken(PlSqlParser.DECOMPOSE, 0); }
		public ITerminalNode DECREMENT() { return GetToken(PlSqlParser.DECREMENT, 0); }
		public ITerminalNode DEFAULT() { return GetToken(PlSqlParser.DEFAULT, 0); }
		public ITerminalNode DEFAULTS() { return GetToken(PlSqlParser.DEFAULTS, 0); }
		public ITerminalNode DEFERRED() { return GetToken(PlSqlParser.DEFERRED, 0); }
		public ITerminalNode DEFINER() { return GetToken(PlSqlParser.DEFINER, 0); }
		public ITerminalNode DELETE() { return GetToken(PlSqlParser.DELETE, 0); }
		public ITerminalNode DEPTH() { return GetToken(PlSqlParser.DEPTH, 0); }
		public ITerminalNode DESC() { return GetToken(PlSqlParser.DESC, 0); }
		public ITerminalNode DETERMINISTIC() { return GetToken(PlSqlParser.DETERMINISTIC, 0); }
		public ITerminalNode DIMENSION() { return GetToken(PlSqlParser.DIMENSION, 0); }
		public ITerminalNode DISABLE() { return GetToken(PlSqlParser.DISABLE, 0); }
		public ITerminalNode DISASSOCIATE() { return GetToken(PlSqlParser.DISASSOCIATE, 0); }
		public ITerminalNode DISTINCT() { return GetToken(PlSqlParser.DISTINCT, 0); }
		public ITerminalNode DOCUMENT() { return GetToken(PlSqlParser.DOCUMENT, 0); }
		public ITerminalNode DOUBLE() { return GetToken(PlSqlParser.DOUBLE, 0); }
		public ITerminalNode DROP() { return GetToken(PlSqlParser.DROP, 0); }
		public ITerminalNode DSINTERVAL_UNCONSTRAINED() { return GetToken(PlSqlParser.DSINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode EACH() { return GetToken(PlSqlParser.EACH, 0); }
		public ITerminalNode ELEMENT() { return GetToken(PlSqlParser.ELEMENT, 0); }
		public ITerminalNode ELSE() { return GetToken(PlSqlParser.ELSE, 0); }
		public ITerminalNode ELSIF() { return GetToken(PlSqlParser.ELSIF, 0); }
		public ITerminalNode EMPTY() { return GetToken(PlSqlParser.EMPTY, 0); }
		public ITerminalNode ENABLE() { return GetToken(PlSqlParser.ENABLE, 0); }
		public ITerminalNode ENCODING() { return GetToken(PlSqlParser.ENCODING, 0); }
		public ITerminalNode END() { return GetToken(PlSqlParser.END, 0); }
		public ITerminalNode ENTITYESCAPING() { return GetToken(PlSqlParser.ENTITYESCAPING, 0); }
		public ITerminalNode ERRORS() { return GetToken(PlSqlParser.ERRORS, 0); }
		public ITerminalNode ESCAPE() { return GetToken(PlSqlParser.ESCAPE, 0); }
		public ITerminalNode EVALNAME() { return GetToken(PlSqlParser.EVALNAME, 0); }
		public ITerminalNode EXCEPT() { return GetToken(PlSqlParser.EXCEPT, 0); }
		public ITerminalNode EXCEPTION() { return GetToken(PlSqlParser.EXCEPTION, 0); }
		public ITerminalNode EXCEPTION_INIT() { return GetToken(PlSqlParser.EXCEPTION_INIT, 0); }
		public ITerminalNode EXCEPTIONS() { return GetToken(PlSqlParser.EXCEPTIONS, 0); }
		public ITerminalNode EXCLUDE() { return GetToken(PlSqlParser.EXCLUDE, 0); }
		public ITerminalNode EXCLUSIVE() { return GetToken(PlSqlParser.EXCLUSIVE, 0); }
		public ITerminalNode EXECUTE() { return GetToken(PlSqlParser.EXECUTE, 0); }
		public ITerminalNode EXISTS() { return GetToken(PlSqlParser.EXISTS, 0); }
		public ITerminalNode EXIT() { return GetToken(PlSqlParser.EXIT, 0); }
		public ITerminalNode EXPLAIN() { return GetToken(PlSqlParser.EXPLAIN, 0); }
		public ITerminalNode EXTERNAL() { return GetToken(PlSqlParser.EXTERNAL, 0); }
		public ITerminalNode EXTRACT() { return GetToken(PlSqlParser.EXTRACT, 0); }
		public ITerminalNode FAILURE() { return GetToken(PlSqlParser.FAILURE, 0); }
		public ITerminalNode FALSE() { return GetToken(PlSqlParser.FALSE, 0); }
		public ITerminalNode FETCH() { return GetToken(PlSqlParser.FETCH, 0); }
		public ITerminalNode FINAL() { return GetToken(PlSqlParser.FINAL, 0); }
		public ITerminalNode FIRST() { return GetToken(PlSqlParser.FIRST, 0); }
		public ITerminalNode FIRST_VALUE() { return GetToken(PlSqlParser.FIRST_VALUE, 0); }
		public ITerminalNode FLOAT() { return GetToken(PlSqlParser.FLOAT, 0); }
		public ITerminalNode FOLLOWING() { return GetToken(PlSqlParser.FOLLOWING, 0); }
		public ITerminalNode FOLLOWS() { return GetToken(PlSqlParser.FOLLOWS, 0); }
		public ITerminalNode FOR() { return GetToken(PlSqlParser.FOR, 0); }
		public ITerminalNode FORALL() { return GetToken(PlSqlParser.FORALL, 0); }
		public ITerminalNode FORCE() { return GetToken(PlSqlParser.FORCE, 0); }
		public ITerminalNode FROM() { return GetToken(PlSqlParser.FROM, 0); }
		public ITerminalNode FULL() { return GetToken(PlSqlParser.FULL, 0); }
		public ITerminalNode FUNCTION() { return GetToken(PlSqlParser.FUNCTION, 0); }
		public ITerminalNode GOTO() { return GetToken(PlSqlParser.GOTO, 0); }
		public ITerminalNode GRANT() { return GetToken(PlSqlParser.GRANT, 0); }
		public ITerminalNode GROUP() { return GetToken(PlSqlParser.GROUP, 0); }
		public ITerminalNode GROUPING() { return GetToken(PlSqlParser.GROUPING, 0); }
		public ITerminalNode HASH() { return GetToken(PlSqlParser.HASH, 0); }
		public ITerminalNode HAVING() { return GetToken(PlSqlParser.HAVING, 0); }
		public ITerminalNode HIDE() { return GetToken(PlSqlParser.HIDE, 0); }
		public ITerminalNode HOUR() { return GetToken(PlSqlParser.HOUR, 0); }
		public ITerminalNode IF() { return GetToken(PlSqlParser.IF, 0); }
		public ITerminalNode IGNORE() { return GetToken(PlSqlParser.IGNORE, 0); }
		public ITerminalNode IMMEDIATE() { return GetToken(PlSqlParser.IMMEDIATE, 0); }
		public ITerminalNode IN() { return GetToken(PlSqlParser.IN, 0); }
		public ITerminalNode INCLUDE() { return GetToken(PlSqlParser.INCLUDE, 0); }
		public ITerminalNode INCLUDING() { return GetToken(PlSqlParser.INCLUDING, 0); }
		public ITerminalNode INCREMENT() { return GetToken(PlSqlParser.INCREMENT, 0); }
		public ITerminalNode INDENT() { return GetToken(PlSqlParser.INDENT, 0); }
		public ITerminalNode INDEX() { return GetToken(PlSqlParser.INDEX, 0); }
		public ITerminalNode INDEXED() { return GetToken(PlSqlParser.INDEXED, 0); }
		public ITerminalNode INDICATOR() { return GetToken(PlSqlParser.INDICATOR, 0); }
		public ITerminalNode INDICES() { return GetToken(PlSqlParser.INDICES, 0); }
		public ITerminalNode INFINITE() { return GetToken(PlSqlParser.INFINITE, 0); }
		public ITerminalNode INLINE() { return GetToken(PlSqlParser.INLINE, 0); }
		public ITerminalNode INNER() { return GetToken(PlSqlParser.INNER, 0); }
		public ITerminalNode INOUT() { return GetToken(PlSqlParser.INOUT, 0); }
		public ITerminalNode INSERT() { return GetToken(PlSqlParser.INSERT, 0); }
		public ITerminalNode INSTANTIABLE() { return GetToken(PlSqlParser.INSTANTIABLE, 0); }
		public ITerminalNode INSTEAD() { return GetToken(PlSqlParser.INSTEAD, 0); }
		public ITerminalNode INT() { return GetToken(PlSqlParser.INT, 0); }
		public ITerminalNode INTEGER() { return GetToken(PlSqlParser.INTEGER, 0); }
		public ITerminalNode INTERSECT() { return GetToken(PlSqlParser.INTERSECT, 0); }
		public ITerminalNode INTERVAL() { return GetToken(PlSqlParser.INTERVAL, 0); }
		public ITerminalNode INTO() { return GetToken(PlSqlParser.INTO, 0); }
		public ITerminalNode INVALIDATE() { return GetToken(PlSqlParser.INVALIDATE, 0); }
		public ITerminalNode IS() { return GetToken(PlSqlParser.IS, 0); }
		public ITerminalNode ISOLATION() { return GetToken(PlSqlParser.ISOLATION, 0); }
		public ITerminalNode ITERATE() { return GetToken(PlSqlParser.ITERATE, 0); }
		public ITerminalNode JAVA() { return GetToken(PlSqlParser.JAVA, 0); }
		public ITerminalNode JOIN() { return GetToken(PlSqlParser.JOIN, 0); }
		public ITerminalNode KEEP() { return GetToken(PlSqlParser.KEEP, 0); }
		public ITerminalNode LANGUAGE() { return GetToken(PlSqlParser.LANGUAGE, 0); }
		public ITerminalNode LAST() { return GetToken(PlSqlParser.LAST, 0); }
		public ITerminalNode LAST_VALUE() { return GetToken(PlSqlParser.LAST_VALUE, 0); }
		public ITerminalNode LEADING() { return GetToken(PlSqlParser.LEADING, 0); }
		public ITerminalNode LEFT() { return GetToken(PlSqlParser.LEFT, 0); }
		public ITerminalNode LEVEL() { return GetToken(PlSqlParser.LEVEL, 0); }
		public ITerminalNode LIBRARY() { return GetToken(PlSqlParser.LIBRARY, 0); }
		public ITerminalNode LIKE() { return GetToken(PlSqlParser.LIKE, 0); }
		public ITerminalNode LIKE2() { return GetToken(PlSqlParser.LIKE2, 0); }
		public ITerminalNode LIKE4() { return GetToken(PlSqlParser.LIKE4, 0); }
		public ITerminalNode LIKEC() { return GetToken(PlSqlParser.LIKEC, 0); }
		public ITerminalNode LIMIT() { return GetToken(PlSqlParser.LIMIT, 0); }
		public ITerminalNode LOCAL() { return GetToken(PlSqlParser.LOCAL, 0); }
		public ITerminalNode LOCK() { return GetToken(PlSqlParser.LOCK, 0); }
		public ITerminalNode LOCKED() { return GetToken(PlSqlParser.LOCKED, 0); }
		public ITerminalNode LOG() { return GetToken(PlSqlParser.LOG, 0); }
		public ITerminalNode LOGOFF() { return GetToken(PlSqlParser.LOGOFF, 0); }
		public ITerminalNode LOGON() { return GetToken(PlSqlParser.LOGON, 0); }
		public ITerminalNode LONG() { return GetToken(PlSqlParser.LONG, 0); }
		public ITerminalNode LOOP() { return GetToken(PlSqlParser.LOOP, 0); }
		public ITerminalNode MAIN() { return GetToken(PlSqlParser.MAIN, 0); }
		public ITerminalNode MAP() { return GetToken(PlSqlParser.MAP, 0); }
		public ITerminalNode MATCHED() { return GetToken(PlSqlParser.MATCHED, 0); }
		public ITerminalNode MAXVALUE() { return GetToken(PlSqlParser.MAXVALUE, 0); }
		public ITerminalNode MEASURES() { return GetToken(PlSqlParser.MEASURES, 0); }
		public ITerminalNode MEMBER() { return GetToken(PlSqlParser.MEMBER, 0); }
		public ITerminalNode MERGE() { return GetToken(PlSqlParser.MERGE, 0); }
		public ITerminalNode MINUS() { return GetToken(PlSqlParser.MINUS, 0); }
		public ITerminalNode MINUTE() { return GetToken(PlSqlParser.MINUTE, 0); }
		public ITerminalNode MINVALUE() { return GetToken(PlSqlParser.MINVALUE, 0); }
		public ITerminalNode MLSLABEL() { return GetToken(PlSqlParser.MLSLABEL, 0); }
		public ITerminalNode MODE() { return GetToken(PlSqlParser.MODE, 0); }
		public ITerminalNode MODEL() { return GetToken(PlSqlParser.MODEL, 0); }
		public ITerminalNode MODIFY() { return GetToken(PlSqlParser.MODIFY, 0); }
		public ITerminalNode MONTH() { return GetToken(PlSqlParser.MONTH, 0); }
		public ITerminalNode MULTISET() { return GetToken(PlSqlParser.MULTISET, 0); }
		public ITerminalNode NAME() { return GetToken(PlSqlParser.NAME, 0); }
		public ITerminalNode NAN() { return GetToken(PlSqlParser.NAN, 0); }
		public ITerminalNode NATURAL() { return GetToken(PlSqlParser.NATURAL, 0); }
		public ITerminalNode NATURALN() { return GetToken(PlSqlParser.NATURALN, 0); }
		public ITerminalNode NAV() { return GetToken(PlSqlParser.NAV, 0); }
		public ITerminalNode NCHAR() { return GetToken(PlSqlParser.NCHAR, 0); }
		public ITerminalNode NCHAR_CS() { return GetToken(PlSqlParser.NCHAR_CS, 0); }
		public ITerminalNode NCLOB() { return GetToken(PlSqlParser.NCLOB, 0); }
		public ITerminalNode NESTED() { return GetToken(PlSqlParser.NESTED, 0); }
		public ITerminalNode NEW() { return GetToken(PlSqlParser.NEW, 0); }
		public ITerminalNode NO() { return GetToken(PlSqlParser.NO, 0); }
		public ITerminalNode NOAUDIT() { return GetToken(PlSqlParser.NOAUDIT, 0); }
		public ITerminalNode NOCACHE() { return GetToken(PlSqlParser.NOCACHE, 0); }
		public ITerminalNode NOCOPY() { return GetToken(PlSqlParser.NOCOPY, 0); }
		public ITerminalNode NOCYCLE() { return GetToken(PlSqlParser.NOCYCLE, 0); }
		public ITerminalNode NOENTITYESCAPING() { return GetToken(PlSqlParser.NOENTITYESCAPING, 0); }
		public ITerminalNode NOMAXVALUE() { return GetToken(PlSqlParser.NOMAXVALUE, 0); }
		public ITerminalNode NOMINVALUE() { return GetToken(PlSqlParser.NOMINVALUE, 0); }
		public ITerminalNode NONE() { return GetToken(PlSqlParser.NONE, 0); }
		public ITerminalNode NOORDER() { return GetToken(PlSqlParser.NOORDER, 0); }
		public ITerminalNode NOSCHEMACHECK() { return GetToken(PlSqlParser.NOSCHEMACHECK, 0); }
		public ITerminalNode NOT() { return GetToken(PlSqlParser.NOT, 0); }
		public ITerminalNode NOWAIT() { return GetToken(PlSqlParser.NOWAIT, 0); }
		public ITerminalNode NULL() { return GetToken(PlSqlParser.NULL, 0); }
		public ITerminalNode NULLS() { return GetToken(PlSqlParser.NULLS, 0); }
		public ITerminalNode NUMBER() { return GetToken(PlSqlParser.NUMBER, 0); }
		public ITerminalNode NUMERIC() { return GetToken(PlSqlParser.NUMERIC, 0); }
		public ITerminalNode NVARCHAR2() { return GetToken(PlSqlParser.NVARCHAR2, 0); }
		public ITerminalNode OBJECT() { return GetToken(PlSqlParser.OBJECT, 0); }
		public ITerminalNode OF() { return GetToken(PlSqlParser.OF, 0); }
		public ITerminalNode OFF() { return GetToken(PlSqlParser.OFF, 0); }
		public ITerminalNode OID() { return GetToken(PlSqlParser.OID, 0); }
		public ITerminalNode OLD() { return GetToken(PlSqlParser.OLD, 0); }
		public ITerminalNode ON() { return GetToken(PlSqlParser.ON, 0); }
		public ITerminalNode ONLY() { return GetToken(PlSqlParser.ONLY, 0); }
		public ITerminalNode OPEN() { return GetToken(PlSqlParser.OPEN, 0); }
		public ITerminalNode OPTION() { return GetToken(PlSqlParser.OPTION, 0); }
		public ITerminalNode OR() { return GetToken(PlSqlParser.OR, 0); }
		public ITerminalNode ORADATA() { return GetToken(PlSqlParser.ORADATA, 0); }
		public ITerminalNode ORDER() { return GetToken(PlSqlParser.ORDER, 0); }
		public ITerminalNode ORDINALITY() { return GetToken(PlSqlParser.ORDINALITY, 0); }
		public ITerminalNode OSERROR() { return GetToken(PlSqlParser.OSERROR, 0); }
		public ITerminalNode OUT() { return GetToken(PlSqlParser.OUT, 0); }
		public ITerminalNode OUTER() { return GetToken(PlSqlParser.OUTER, 0); }
		public ITerminalNode OVER() { return GetToken(PlSqlParser.OVER, 0); }
		public ITerminalNode OVERRIDING() { return GetToken(PlSqlParser.OVERRIDING, 0); }
		public ITerminalNode PACKAGE() { return GetToken(PlSqlParser.PACKAGE, 0); }
		public ITerminalNode PARALLEL_ENABLE() { return GetToken(PlSqlParser.PARALLEL_ENABLE, 0); }
		public ITerminalNode PARAMETERS() { return GetToken(PlSqlParser.PARAMETERS, 0); }
		public ITerminalNode PARENT() { return GetToken(PlSqlParser.PARENT, 0); }
		public ITerminalNode PARTITION() { return GetToken(PlSqlParser.PARTITION, 0); }
		public ITerminalNode PASSING() { return GetToken(PlSqlParser.PASSING, 0); }
		public ITerminalNode PATH() { return GetToken(PlSqlParser.PATH, 0); }
		public ITerminalNode PIPELINED() { return GetToken(PlSqlParser.PIPELINED, 0); }
		public ITerminalNode PIVOT() { return GetToken(PlSqlParser.PIVOT, 0); }
		public ITerminalNode PLAN() { return GetToken(PlSqlParser.PLAN, 0); }
		public ITerminalNode PLS_INTEGER() { return GetToken(PlSqlParser.PLS_INTEGER, 0); }
		public ITerminalNode POSITIVE() { return GetToken(PlSqlParser.POSITIVE, 0); }
		public ITerminalNode POSITIVEN() { return GetToken(PlSqlParser.POSITIVEN, 0); }
		public ITerminalNode PRAGMA() { return GetToken(PlSqlParser.PRAGMA, 0); }
		public ITerminalNode PRECEDING() { return GetToken(PlSqlParser.PRECEDING, 0); }
		public ITerminalNode PRECISION() { return GetToken(PlSqlParser.PRECISION, 0); }
		public ITerminalNode PRESENT() { return GetToken(PlSqlParser.PRESENT, 0); }
		public ITerminalNode PRIOR() { return GetToken(PlSqlParser.PRIOR, 0); }
		public ITerminalNode PROCEDURE() { return GetToken(PlSqlParser.PROCEDURE, 0); }
		public ITerminalNode RAISE() { return GetToken(PlSqlParser.RAISE, 0); }
		public ITerminalNode RANGE() { return GetToken(PlSqlParser.RANGE, 0); }
		public ITerminalNode RAW() { return GetToken(PlSqlParser.RAW, 0); }
		public ITerminalNode READ() { return GetToken(PlSqlParser.READ, 0); }
		public ITerminalNode REAL() { return GetToken(PlSqlParser.REAL, 0); }
		public ITerminalNode RECORD() { return GetToken(PlSqlParser.RECORD, 0); }
		public ITerminalNode REF() { return GetToken(PlSqlParser.REF, 0); }
		public ITerminalNode REFERENCE() { return GetToken(PlSqlParser.REFERENCE, 0); }
		public ITerminalNode REFERENCING() { return GetToken(PlSqlParser.REFERENCING, 0); }
		public ITerminalNode REJECT() { return GetToken(PlSqlParser.REJECT, 0); }
		public ITerminalNode RELIES_ON() { return GetToken(PlSqlParser.RELIES_ON, 0); }
		public ITerminalNode RENAME() { return GetToken(PlSqlParser.RENAME, 0); }
		public ITerminalNode REPLACE() { return GetToken(PlSqlParser.REPLACE, 0); }
		public ITerminalNode RESPECT() { return GetToken(PlSqlParser.RESPECT, 0); }
		public ITerminalNode RESTRICT_REFERENCES() { return GetToken(PlSqlParser.RESTRICT_REFERENCES, 0); }
		public ITerminalNode RESULT() { return GetToken(PlSqlParser.RESULT, 0); }
		public ITerminalNode RESULT_CACHE() { return GetToken(PlSqlParser.RESULT_CACHE, 0); }
		public ITerminalNode RETURN() { return GetToken(PlSqlParser.RETURN, 0); }
		public ITerminalNode RETURNING() { return GetToken(PlSqlParser.RETURNING, 0); }
		public ITerminalNode REUSE() { return GetToken(PlSqlParser.REUSE, 0); }
		public ITerminalNode REVERSE() { return GetToken(PlSqlParser.REVERSE, 0); }
		public ITerminalNode REVOKE() { return GetToken(PlSqlParser.REVOKE, 0); }
		public ITerminalNode RIGHT() { return GetToken(PlSqlParser.RIGHT, 0); }
		public ITerminalNode ROLLBACK() { return GetToken(PlSqlParser.ROLLBACK, 0); }
		public ITerminalNode ROLLUP() { return GetToken(PlSqlParser.ROLLUP, 0); }
		public ITerminalNode ROW() { return GetToken(PlSqlParser.ROW, 0); }
		public ITerminalNode ROWID() { return GetToken(PlSqlParser.ROWID, 0); }
		public ITerminalNode ROWS() { return GetToken(PlSqlParser.ROWS, 0); }
		public ITerminalNode RULES() { return GetToken(PlSqlParser.RULES, 0); }
		public ITerminalNode SAMPLE() { return GetToken(PlSqlParser.SAMPLE, 0); }
		public ITerminalNode SAVE() { return GetToken(PlSqlParser.SAVE, 0); }
		public ITerminalNode SAVEPOINT() { return GetToken(PlSqlParser.SAVEPOINT, 0); }
		public ITerminalNode SCHEMA() { return GetToken(PlSqlParser.SCHEMA, 0); }
		public ITerminalNode SCHEMACHECK() { return GetToken(PlSqlParser.SCHEMACHECK, 0); }
		public ITerminalNode SCN() { return GetToken(PlSqlParser.SCN, 0); }
		public ITerminalNode SEARCH() { return GetToken(PlSqlParser.SEARCH, 0); }
		public ITerminalNode SECOND() { return GetToken(PlSqlParser.SECOND, 0); }
		public ITerminalNode SEED() { return GetToken(PlSqlParser.SEED, 0); }
		public ITerminalNode SEGMENT() { return GetToken(PlSqlParser.SEGMENT, 0); }
		public ITerminalNode SELECT() { return GetToken(PlSqlParser.SELECT, 0); }
		public ITerminalNode SELF() { return GetToken(PlSqlParser.SELF, 0); }
		public ITerminalNode SEQUENCE() { return GetToken(PlSqlParser.SEQUENCE, 0); }
		public ITerminalNode SEQUENTIAL() { return GetToken(PlSqlParser.SEQUENTIAL, 0); }
		public ITerminalNode SERIALIZABLE() { return GetToken(PlSqlParser.SERIALIZABLE, 0); }
		public ITerminalNode SERIALLY_REUSABLE() { return GetToken(PlSqlParser.SERIALLY_REUSABLE, 0); }
		public ITerminalNode SERVERERROR() { return GetToken(PlSqlParser.SERVERERROR, 0); }
		public ITerminalNode SESSIONTIMEZONE() { return GetToken(PlSqlParser.SESSIONTIMEZONE, 0); }
		public ITerminalNode SET() { return GetToken(PlSqlParser.SET, 0); }
		public ITerminalNode SETS() { return GetToken(PlSqlParser.SETS, 0); }
		public ITerminalNode SETTINGS() { return GetToken(PlSqlParser.SETTINGS, 0); }
		public ITerminalNode SHARE() { return GetToken(PlSqlParser.SHARE, 0); }
		public ITerminalNode SHOW() { return GetToken(PlSqlParser.SHOW, 0); }
		public ITerminalNode SHUTDOWN() { return GetToken(PlSqlParser.SHUTDOWN, 0); }
		public ITerminalNode SIBLINGS() { return GetToken(PlSqlParser.SIBLINGS, 0); }
		public ITerminalNode SIGNTYPE() { return GetToken(PlSqlParser.SIGNTYPE, 0); }
		public ITerminalNode SIMPLE_INTEGER() { return GetToken(PlSqlParser.SIMPLE_INTEGER, 0); }
		public ITerminalNode SINGLE() { return GetToken(PlSqlParser.SINGLE, 0); }
		public ITerminalNode SIZE() { return GetToken(PlSqlParser.SIZE, 0); }
		public ITerminalNode SKIP_() { return GetToken(PlSqlParser.SKIP_, 0); }
		public ITerminalNode SMALLINT() { return GetToken(PlSqlParser.SMALLINT, 0); }
		public ITerminalNode SNAPSHOT() { return GetToken(PlSqlParser.SNAPSHOT, 0); }
		public ITerminalNode SOME() { return GetToken(PlSqlParser.SOME, 0); }
		public ITerminalNode SPECIFICATION() { return GetToken(PlSqlParser.SPECIFICATION, 0); }
		public ITerminalNode SQLDATA() { return GetToken(PlSqlParser.SQLDATA, 0); }
		public ITerminalNode SQLERROR() { return GetToken(PlSqlParser.SQLERROR, 0); }
		public ITerminalNode SQL_PERCENT_ROWCOUNT() { return GetToken(PlSqlParser.SQL_PERCENT_ROWCOUNT, 0); }
		public ITerminalNode STANDALONE() { return GetToken(PlSqlParser.STANDALONE, 0); }
		public ITerminalNode START() { return GetToken(PlSqlParser.START, 0); }
		public ITerminalNode STARTUP() { return GetToken(PlSqlParser.STARTUP, 0); }
		public ITerminalNode STATEMENT() { return GetToken(PlSqlParser.STATEMENT, 0); }
		public ITerminalNode STATEMENT_ID() { return GetToken(PlSqlParser.STATEMENT_ID, 0); }
		public ITerminalNode STATIC() { return GetToken(PlSqlParser.STATIC, 0); }
		public ITerminalNode STATISTICS() { return GetToken(PlSqlParser.STATISTICS, 0); }
		public ITerminalNode STRING() { return GetToken(PlSqlParser.STRING, 0); }
		public ITerminalNode SUBMULTISET() { return GetToken(PlSqlParser.SUBMULTISET, 0); }
		public ITerminalNode SUBPARTITION() { return GetToken(PlSqlParser.SUBPARTITION, 0); }
		public ITerminalNode SUBSTITUTABLE() { return GetToken(PlSqlParser.SUBSTITUTABLE, 0); }
		public ITerminalNode SUBTYPE() { return GetToken(PlSqlParser.SUBTYPE, 0); }
		public ITerminalNode SUCCESS() { return GetToken(PlSqlParser.SUCCESS, 0); }
		public ITerminalNode SUSPEND() { return GetToken(PlSqlParser.SUSPEND, 0); }
		public ITerminalNode TABLE() { return GetToken(PlSqlParser.TABLE, 0); }
		public ITerminalNode THE() { return GetToken(PlSqlParser.THE, 0); }
		public ITerminalNode THEN() { return GetToken(PlSqlParser.THEN, 0); }
		public ITerminalNode TIME() { return GetToken(PlSqlParser.TIME, 0); }
		public ITerminalNode TIMESTAMP() { return GetToken(PlSqlParser.TIMESTAMP, 0); }
		public ITerminalNode TIMESTAMP_LTZ_UNCONSTRAINED() { return GetToken(PlSqlParser.TIMESTAMP_LTZ_UNCONSTRAINED, 0); }
		public ITerminalNode TIMESTAMP_TZ_UNCONSTRAINED() { return GetToken(PlSqlParser.TIMESTAMP_TZ_UNCONSTRAINED, 0); }
		public ITerminalNode TIMESTAMP_UNCONSTRAINED() { return GetToken(PlSqlParser.TIMESTAMP_UNCONSTRAINED, 0); }
		public ITerminalNode TIMEZONE_ABBR() { return GetToken(PlSqlParser.TIMEZONE_ABBR, 0); }
		public ITerminalNode TIMEZONE_HOUR() { return GetToken(PlSqlParser.TIMEZONE_HOUR, 0); }
		public ITerminalNode TIMEZONE_MINUTE() { return GetToken(PlSqlParser.TIMEZONE_MINUTE, 0); }
		public ITerminalNode TIMEZONE_REGION() { return GetToken(PlSqlParser.TIMEZONE_REGION, 0); }
		public ITerminalNode TO() { return GetToken(PlSqlParser.TO, 0); }
		public ITerminalNode TRAILING() { return GetToken(PlSqlParser.TRAILING, 0); }
		public ITerminalNode TRANSACTION() { return GetToken(PlSqlParser.TRANSACTION, 0); }
		public ITerminalNode TRANSLATE() { return GetToken(PlSqlParser.TRANSLATE, 0); }
		public ITerminalNode TREAT() { return GetToken(PlSqlParser.TREAT, 0); }
		public ITerminalNode TRIGGER() { return GetToken(PlSqlParser.TRIGGER, 0); }
		public ITerminalNode TRIM() { return GetToken(PlSqlParser.TRIM, 0); }
		public ITerminalNode TRUE() { return GetToken(PlSqlParser.TRUE, 0); }
		public ITerminalNode TRUNCATE() { return GetToken(PlSqlParser.TRUNCATE, 0); }
		public ITerminalNode TYPE() { return GetToken(PlSqlParser.TYPE, 0); }
		public ITerminalNode UNBOUNDED() { return GetToken(PlSqlParser.UNBOUNDED, 0); }
		public ITerminalNode UNDER() { return GetToken(PlSqlParser.UNDER, 0); }
		public ITerminalNode UNION() { return GetToken(PlSqlParser.UNION, 0); }
		public ITerminalNode UNIQUE() { return GetToken(PlSqlParser.UNIQUE, 0); }
		public ITerminalNode UNLIMITED() { return GetToken(PlSqlParser.UNLIMITED, 0); }
		public ITerminalNode UNPIVOT() { return GetToken(PlSqlParser.UNPIVOT, 0); }
		public ITerminalNode UNTIL() { return GetToken(PlSqlParser.UNTIL, 0); }
		public ITerminalNode UPDATE() { return GetToken(PlSqlParser.UPDATE, 0); }
		public ITerminalNode UPDATED() { return GetToken(PlSqlParser.UPDATED, 0); }
		public ITerminalNode UPSERT() { return GetToken(PlSqlParser.UPSERT, 0); }
		public ITerminalNode UROWID() { return GetToken(PlSqlParser.UROWID, 0); }
		public ITerminalNode USE() { return GetToken(PlSqlParser.USE, 0); }
		public ITerminalNode USING() { return GetToken(PlSqlParser.USING, 0); }
		public ITerminalNode VALIDATE() { return GetToken(PlSqlParser.VALIDATE, 0); }
		public ITerminalNode VALUE() { return GetToken(PlSqlParser.VALUE, 0); }
		public ITerminalNode VALUES() { return GetToken(PlSqlParser.VALUES, 0); }
		public ITerminalNode VARCHAR() { return GetToken(PlSqlParser.VARCHAR, 0); }
		public ITerminalNode VARCHAR2() { return GetToken(PlSqlParser.VARCHAR2, 0); }
		public ITerminalNode VARIABLE() { return GetToken(PlSqlParser.VARIABLE, 0); }
		public ITerminalNode VARRAY() { return GetToken(PlSqlParser.VARRAY, 0); }
		public ITerminalNode VARYING() { return GetToken(PlSqlParser.VARYING, 0); }
		public ITerminalNode VERSION() { return GetToken(PlSqlParser.VERSION, 0); }
		public ITerminalNode VERSIONS() { return GetToken(PlSqlParser.VERSIONS, 0); }
		public ITerminalNode WAIT() { return GetToken(PlSqlParser.WAIT, 0); }
		public ITerminalNode WARNING() { return GetToken(PlSqlParser.WARNING, 0); }
		public ITerminalNode WELLFORMED() { return GetToken(PlSqlParser.WELLFORMED, 0); }
		public ITerminalNode WHEN() { return GetToken(PlSqlParser.WHEN, 0); }
		public ITerminalNode WHENEVER() { return GetToken(PlSqlParser.WHENEVER, 0); }
		public ITerminalNode WHERE() { return GetToken(PlSqlParser.WHERE, 0); }
		public ITerminalNode WHILE() { return GetToken(PlSqlParser.WHILE, 0); }
		public ITerminalNode WITH() { return GetToken(PlSqlParser.WITH, 0); }
		public ITerminalNode WITHIN() { return GetToken(PlSqlParser.WITHIN, 0); }
		public ITerminalNode WORK() { return GetToken(PlSqlParser.WORK, 0); }
		public ITerminalNode WRITE() { return GetToken(PlSqlParser.WRITE, 0); }
		public ITerminalNode XML() { return GetToken(PlSqlParser.XML, 0); }
		public ITerminalNode XMLAGG() { return GetToken(PlSqlParser.XMLAGG, 0); }
		public ITerminalNode XMLATTRIBUTES() { return GetToken(PlSqlParser.XMLATTRIBUTES, 0); }
		public ITerminalNode XMLCAST() { return GetToken(PlSqlParser.XMLCAST, 0); }
		public ITerminalNode XMLCOLATTVAL() { return GetToken(PlSqlParser.XMLCOLATTVAL, 0); }
		public ITerminalNode XMLELEMENT() { return GetToken(PlSqlParser.XMLELEMENT, 0); }
		public ITerminalNode XMLEXISTS() { return GetToken(PlSqlParser.XMLEXISTS, 0); }
		public ITerminalNode XMLFOREST() { return GetToken(PlSqlParser.XMLFOREST, 0); }
		public ITerminalNode XMLNAMESPACES() { return GetToken(PlSqlParser.XMLNAMESPACES, 0); }
		public ITerminalNode XMLPARSE() { return GetToken(PlSqlParser.XMLPARSE, 0); }
		public ITerminalNode XMLPI() { return GetToken(PlSqlParser.XMLPI, 0); }
		public ITerminalNode XMLQUERY() { return GetToken(PlSqlParser.XMLQUERY, 0); }
		public ITerminalNode XMLROOT() { return GetToken(PlSqlParser.XMLROOT, 0); }
		public ITerminalNode XMLSERIALIZE() { return GetToken(PlSqlParser.XMLSERIALIZE, 0); }
		public ITerminalNode XMLTABLE() { return GetToken(PlSqlParser.XMLTABLE, 0); }
		public ITerminalNode YEAR() { return GetToken(PlSqlParser.YEAR, 0); }
		public ITerminalNode YES() { return GetToken(PlSqlParser.YES, 0); }
		public ITerminalNode YMINTERVAL_UNCONSTRAINED() { return GetToken(PlSqlParser.YMINTERVAL_UNCONSTRAINED, 0); }
		public ITerminalNode ZONE() { return GetToken(PlSqlParser.ZONE, 0); }
		public ITerminalNode PREDICTION() { return GetToken(PlSqlParser.PREDICTION, 0); }
		public ITerminalNode PREDICTION_BOUNDS() { return GetToken(PlSqlParser.PREDICTION_BOUNDS, 0); }
		public ITerminalNode PREDICTION_COST() { return GetToken(PlSqlParser.PREDICTION_COST, 0); }
		public ITerminalNode PREDICTION_DETAILS() { return GetToken(PlSqlParser.PREDICTION_DETAILS, 0); }
		public ITerminalNode PREDICTION_PROBABILITY() { return GetToken(PlSqlParser.PREDICTION_PROBABILITY, 0); }
		public ITerminalNode PREDICTION_SET() { return GetToken(PlSqlParser.PREDICTION_SET, 0); }
		public ITerminalNode CUME_DIST() { return GetToken(PlSqlParser.CUME_DIST, 0); }
		public ITerminalNode DENSE_RANK() { return GetToken(PlSqlParser.DENSE_RANK, 0); }
		public ITerminalNode LISTAGG() { return GetToken(PlSqlParser.LISTAGG, 0); }
		public ITerminalNode PERCENT_RANK() { return GetToken(PlSqlParser.PERCENT_RANK, 0); }
		public ITerminalNode PERCENTILE_CONT() { return GetToken(PlSqlParser.PERCENTILE_CONT, 0); }
		public ITerminalNode PERCENTILE_DISC() { return GetToken(PlSqlParser.PERCENTILE_DISC, 0); }
		public ITerminalNode RANK() { return GetToken(PlSqlParser.RANK, 0); }
		public ITerminalNode AVG() { return GetToken(PlSqlParser.AVG, 0); }
		public ITerminalNode CORR() { return GetToken(PlSqlParser.CORR, 0); }
		public ITerminalNode LAG() { return GetToken(PlSqlParser.LAG, 0); }
		public ITerminalNode LEAD() { return GetToken(PlSqlParser.LEAD, 0); }
		public ITerminalNode MAX() { return GetToken(PlSqlParser.MAX, 0); }
		public ITerminalNode MEDIAN() { return GetToken(PlSqlParser.MEDIAN, 0); }
		public ITerminalNode MIN() { return GetToken(PlSqlParser.MIN, 0); }
		public ITerminalNode NTILE() { return GetToken(PlSqlParser.NTILE, 0); }
		public ITerminalNode RATIO_TO_REPORT() { return GetToken(PlSqlParser.RATIO_TO_REPORT, 0); }
		public ITerminalNode ROW_NUMBER() { return GetToken(PlSqlParser.ROW_NUMBER, 0); }
		public ITerminalNode SUM() { return GetToken(PlSqlParser.SUM, 0); }
		public ITerminalNode VARIANCE() { return GetToken(PlSqlParser.VARIANCE, 0); }
		public ITerminalNode REGR_() { return GetToken(PlSqlParser.REGR_, 0); }
		public ITerminalNode STDDEV() { return GetToken(PlSqlParser.STDDEV, 0); }
		public ITerminalNode VAR_() { return GetToken(PlSqlParser.VAR_, 0); }
		public ITerminalNode COVAR_() { return GetToken(PlSqlParser.COVAR_, 0); }
		public ITerminalNode TO_CHAR() { return GetToken(PlSqlParser.TO_CHAR, 0); }
		public Regular_idContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_regular_id; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.EnterRegular_id(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlSqlListener typedListener = listener as IPlSqlListener;
			if (typedListener != null) typedListener.ExitRegular_id(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlSqlVisitor<TResult> typedVisitor = visitor as IPlSqlVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRegular_id(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Regular_idContext regular_id() {
		Regular_idContext _localctx = new Regular_idContext(_ctx, State);
		EnterRule(_localctx, 776, RULE_regular_id);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 5502;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << A_LETTER) | (1L << ADD) | (1L << AFTER) | (1L << AGENT) | (1L << AGGREGATE) | (1L << ALL) | (1L << ALTER) | (1L << ANALYZE) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASSOCIATE) | (1L << AT) | (1L << ATTRIBUTE) | (1L << AUDIT) | (1L << AUTHID) | (1L << AUTO) | (1L << AUTOMATIC) | (1L << AUTONOMOUS_TRANSACTION) | (1L << BATCH) | (1L << BEFORE) | (1L << BEGIN) | (1L << BETWEEN) | (1L << BFILE) | (1L << BINARY_DOUBLE) | (1L << BINARY_FLOAT) | (1L << BINARY_INTEGER) | (1L << BLOB) | (1L << BLOCK) | (1L << BODY) | (1L << BOOLEAN) | (1L << BOTH) | (1L << BREADTH) | (1L << BULK) | (1L << BY) | (1L << BYTE) | (1L << C_LETTER) | (1L << CACHE) | (1L << CALL) | (1L << CANONICAL) | (1L << CASCADE) | (1L << CASE) | (1L << CAST) | (1L << CHAR) | (1L << CHAR_CS) | (1L << CHARACTER) | (1L << CHECK) | (1L << CHR) | (1L << CLOB) | (1L << CLOSE) | (1L << CLUSTER) | (1L << COLLECT) | (1L << COLUMNS))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (COMMENT - 64)) | (1L << (COMMIT - 64)) | (1L << (COMMITTED - 64)) | (1L << (COMPATIBILITY - 64)) | (1L << (COMPILE - 64)) | (1L << (COMPOUND - 64)) | (1L << (CONNECT - 64)) | (1L << (CONNECT_BY_ROOT - 64)) | (1L << (CONSTANT - 64)) | (1L << (CONSTRAINT - 64)) | (1L << (CONSTRAINTS - 64)) | (1L << (CONSTRUCTOR - 64)) | (1L << (CONTENT - 64)) | (1L << (CONTEXT - 64)) | (1L << (CONTINUE - 64)) | (1L << (CONVERT - 64)) | (1L << (CORRUPT_XID - 64)) | (1L << (CORRUPT_XID_ALL - 64)) | (1L << (COST - 64)) | (1L << (COUNT - 64)) | (1L << (CREATE - 64)) | (1L << (CROSS - 64)) | (1L << (CUBE - 64)) | (1L << (CURRENT - 64)) | (1L << (CURRENT_USER - 64)) | (1L << (CURSOR - 64)) | (1L << (CUSTOMDATUM - 64)) | (1L << (CYCLE - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATE - 64)) | (1L << (DAY - 64)) | (1L << (DB_ROLE_CHANGE - 64)) | (1L << (DBTIMEZONE - 64)) | (1L << (DDL - 64)) | (1L << (DEBUG - 64)) | (1L << (DEC - 64)) | (1L << (DECIMAL - 64)) | (1L << (DECLARE - 64)) | (1L << (DECOMPOSE - 64)) | (1L << (DECREMENT - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFAULTS - 64)) | (1L << (DEFERRED - 64)) | (1L << (DEFINER - 64)) | (1L << (DELETE - 64)) | (1L << (DEPTH - 64)) | (1L << (DESC - 64)) | (1L << (DETERMINISTIC - 64)) | (1L << (DIMENSION - 64)) | (1L << (DISABLE - 64)) | (1L << (DISASSOCIATE - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOCUMENT - 64)) | (1L << (DOUBLE - 64)) | (1L << (DROP - 64)) | (1L << (DSINTERVAL_UNCONSTRAINED - 64)) | (1L << (EACH - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELSE - 64)) | (1L << (ELSIF - 64)) | (1L << (EMPTY - 64)) | (1L << (ENABLE - 64)) | (1L << (ENCODING - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (END - 128)) | (1L << (ENTITYESCAPING - 128)) | (1L << (ERRORS - 128)) | (1L << (ESCAPE - 128)) | (1L << (EXCEPT - 128)) | (1L << (EVALNAME - 128)) | (1L << (EXCEPTION - 128)) | (1L << (EXCEPTION_INIT - 128)) | (1L << (EXCEPTIONS - 128)) | (1L << (EXCLUDE - 128)) | (1L << (EXCLUSIVE - 128)) | (1L << (EXECUTE - 128)) | (1L << (EXISTS - 128)) | (1L << (EXIT - 128)) | (1L << (EXPLAIN - 128)) | (1L << (EXTERNAL - 128)) | (1L << (EXTRACT - 128)) | (1L << (FAILURE - 128)) | (1L << (FALSE - 128)) | (1L << (FETCH - 128)) | (1L << (FINAL - 128)) | (1L << (FIRST - 128)) | (1L << (FIRST_VALUE - 128)) | (1L << (FLOAT - 128)) | (1L << (FOLLOWING - 128)) | (1L << (FOLLOWS - 128)) | (1L << (FOR - 128)) | (1L << (FORALL - 128)) | (1L << (FORCE - 128)) | (1L << (FROM - 128)) | (1L << (FULL - 128)) | (1L << (FUNCTION - 128)) | (1L << (GOTO - 128)) | (1L << (GRANT - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPING - 128)) | (1L << (HASH - 128)) | (1L << (HAVING - 128)) | (1L << (HIDE - 128)) | (1L << (HOUR - 128)) | (1L << (IF - 128)) | (1L << (IGNORE - 128)) | (1L << (IMMEDIATE - 128)) | (1L << (IN - 128)) | (1L << (INCLUDE - 128)) | (1L << (INCLUDING - 128)) | (1L << (INCREMENT - 128)) | (1L << (INDENT - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXED - 128)) | (1L << (INDICATOR - 128)) | (1L << (INDICES - 128)) | (1L << (INFINITE - 128)) | (1L << (INLINE - 128)) | (1L << (INNER - 128)) | (1L << (INOUT - 128)) | (1L << (INSERT - 128)) | (1L << (INSTANTIABLE - 128)) | (1L << (INSTEAD - 128)) | (1L << (INT - 128)) | (1L << (INTEGER - 128)) | (1L << (INTERSECT - 128)) | (1L << (INTERVAL - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (INTO - 192)) | (1L << (INVALIDATE - 192)) | (1L << (IS - 192)) | (1L << (ISOLATION - 192)) | (1L << (ITERATE - 192)) | (1L << (JAVA - 192)) | (1L << (JOIN - 192)) | (1L << (KEEP - 192)) | (1L << (LANGUAGE - 192)) | (1L << (LAST - 192)) | (1L << (LAST_VALUE - 192)) | (1L << (LEADING - 192)) | (1L << (LEFT - 192)) | (1L << (LEVEL - 192)) | (1L << (LIBRARY - 192)) | (1L << (LIKE - 192)) | (1L << (LIKE2 - 192)) | (1L << (LIKE4 - 192)) | (1L << (LIKEC - 192)) | (1L << (LIMIT - 192)) | (1L << (LOCAL - 192)) | (1L << (LOCK - 192)) | (1L << (LOCKED - 192)) | (1L << (LOG - 192)) | (1L << (LOGOFF - 192)) | (1L << (LOGON - 192)) | (1L << (LONG - 192)) | (1L << (LOOP - 192)) | (1L << (MAIN - 192)) | (1L << (MAP - 192)) | (1L << (MATCHED - 192)) | (1L << (MAXVALUE - 192)) | (1L << (MEASURES - 192)) | (1L << (MEMBER - 192)) | (1L << (MERGE - 192)) | (1L << (MINUS - 192)) | (1L << (MINUTE - 192)) | (1L << (MINVALUE - 192)) | (1L << (MLSLABEL - 192)) | (1L << (MODE - 192)) | (1L << (MODEL - 192)) | (1L << (MODIFY - 192)) | (1L << (MONTH - 192)) | (1L << (MULTISET - 192)) | (1L << (NAME - 192)) | (1L << (NAN - 192)) | (1L << (NATURAL - 192)) | (1L << (NATURALN - 192)) | (1L << (NAV - 192)) | (1L << (NCHAR - 192)) | (1L << (NCHAR_CS - 192)) | (1L << (NCLOB - 192)) | (1L << (NESTED - 192)) | (1L << (NEW - 192)) | (1L << (NO - 192)) | (1L << (NOAUDIT - 192)) | (1L << (NOCACHE - 192)) | (1L << (NOCOPY - 192)) | (1L << (NOCYCLE - 192)) | (1L << (NOENTITYESCAPING - 192)) | (1L << (NOMAXVALUE - 192)) | (1L << (NOMINVALUE - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (NONE - 256)) | (1L << (NOORDER - 256)) | (1L << (NOSCHEMACHECK - 256)) | (1L << (NOT - 256)) | (1L << (NOWAIT - 256)) | (1L << (NULL - 256)) | (1L << (NULLS - 256)) | (1L << (NUMBER - 256)) | (1L << (NUMERIC - 256)) | (1L << (NVARCHAR2 - 256)) | (1L << (OBJECT - 256)) | (1L << (OF - 256)) | (1L << (OFF - 256)) | (1L << (OID - 256)) | (1L << (OLD - 256)) | (1L << (ON - 256)) | (1L << (ONLY - 256)) | (1L << (OPEN - 256)) | (1L << (OPTION - 256)) | (1L << (OR - 256)) | (1L << (ORADATA - 256)) | (1L << (ORDER - 256)) | (1L << (ORDINALITY - 256)) | (1L << (OSERROR - 256)) | (1L << (OUT - 256)) | (1L << (OUTER - 256)) | (1L << (OVER - 256)) | (1L << (OVERRIDING - 256)) | (1L << (PACKAGE - 256)) | (1L << (PARALLEL_ENABLE - 256)) | (1L << (PARAMETERS - 256)) | (1L << (PARENT - 256)) | (1L << (PARTITION - 256)) | (1L << (PASSING - 256)) | (1L << (PATH - 256)) | (1L << (PIPELINED - 256)) | (1L << (PIVOT - 256)) | (1L << (PLAN - 256)) | (1L << (PLS_INTEGER - 256)) | (1L << (POSITIVE - 256)) | (1L << (POSITIVEN - 256)) | (1L << (PRAGMA - 256)) | (1L << (PRECEDING - 256)) | (1L << (PRECISION - 256)) | (1L << (PRESENT - 256)) | (1L << (PRIOR - 256)) | (1L << (PROCEDURE - 256)) | (1L << (RAISE - 256)) | (1L << (RANGE - 256)) | (1L << (RAW - 256)) | (1L << (READ - 256)) | (1L << (REAL - 256)) | (1L << (RECORD - 256)) | (1L << (REF - 256)) | (1L << (REFERENCE - 256)) | (1L << (REFERENCING - 256)) | (1L << (REJECT - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (RELIES_ON - 320)) | (1L << (RENAME - 320)) | (1L << (REPLACE - 320)) | (1L << (RESPECT - 320)) | (1L << (RESTRICT_REFERENCES - 320)) | (1L << (RESULT - 320)) | (1L << (RESULT_CACHE - 320)) | (1L << (RETURN - 320)) | (1L << (RETURNING - 320)) | (1L << (REUSE - 320)) | (1L << (REVERSE - 320)) | (1L << (REVOKE - 320)) | (1L << (RIGHT - 320)) | (1L << (ROLLBACK - 320)) | (1L << (ROLLUP - 320)) | (1L << (ROW - 320)) | (1L << (ROWID - 320)) | (1L << (ROWS - 320)) | (1L << (RULES - 320)) | (1L << (SAMPLE - 320)) | (1L << (SAVE - 320)) | (1L << (SAVEPOINT - 320)) | (1L << (SCHEMA - 320)) | (1L << (SCHEMACHECK - 320)) | (1L << (SCN - 320)) | (1L << (SEARCH - 320)) | (1L << (SECOND - 320)) | (1L << (SEED - 320)) | (1L << (SEGMENT - 320)) | (1L << (SELECT - 320)) | (1L << (SELF - 320)) | (1L << (SEQUENCE - 320)) | (1L << (SEQUENTIAL - 320)) | (1L << (SERIALIZABLE - 320)) | (1L << (SERIALLY_REUSABLE - 320)) | (1L << (SERVERERROR - 320)) | (1L << (SESSIONTIMEZONE - 320)) | (1L << (SET - 320)) | (1L << (SETS - 320)) | (1L << (SETTINGS - 320)) | (1L << (SHARE - 320)) | (1L << (SHOW - 320)) | (1L << (SHUTDOWN - 320)) | (1L << (SIBLINGS - 320)) | (1L << (SIGNTYPE - 320)) | (1L << (SIMPLE_INTEGER - 320)) | (1L << (SINGLE - 320)) | (1L << (SIZE - 320)) | (1L << (SKIP_ - 320)) | (1L << (SMALLINT - 320)) | (1L << (SNAPSHOT - 320)) | (1L << (SOME - 320)) | (1L << (SPECIFICATION - 320)) | (1L << (SQLDATA - 320)) | (1L << (SQLERROR - 320)) | (1L << (SQL_PERCENT_ROWCOUNT - 320)) | (1L << (STANDALONE - 320)) | (1L << (START - 320)) | (1L << (STARTUP - 320)) | (1L << (STATEMENT - 320)) | (1L << (STATEMENT_ID - 320)) | (1L << (STATIC - 320)) | (1L << (STATISTICS - 320)) | (1L << (STRING - 320)))) != 0) || ((((_la - 384)) & ~0x3f) == 0 && ((1L << (_la - 384)) & ((1L << (SUBMULTISET - 384)) | (1L << (SUBPARTITION - 384)) | (1L << (SUBSTITUTABLE - 384)) | (1L << (SUBTYPE - 384)) | (1L << (SUCCESS - 384)) | (1L << (SUSPEND - 384)) | (1L << (TABLE - 384)) | (1L << (THE - 384)) | (1L << (THEN - 384)) | (1L << (TIME - 384)) | (1L << (TIMESTAMP - 384)) | (1L << (TIMESTAMP_LTZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_TZ_UNCONSTRAINED - 384)) | (1L << (TIMESTAMP_UNCONSTRAINED - 384)) | (1L << (TIMEZONE_ABBR - 384)) | (1L << (TIMEZONE_HOUR - 384)) | (1L << (TIMEZONE_MINUTE - 384)) | (1L << (TIMEZONE_REGION - 384)) | (1L << (TO - 384)) | (1L << (TO_CHAR - 384)) | (1L << (TRAILING - 384)) | (1L << (TRANSACTION - 384)) | (1L << (TRANSLATE - 384)) | (1L << (TREAT - 384)) | (1L << (TRIGGER - 384)) | (1L << (TRIM - 384)) | (1L << (TRUE - 384)) | (1L << (TRUNCATE - 384)) | (1L << (TYPE - 384)) | (1L << (UNBOUNDED - 384)) | (1L << (UNDER - 384)) | (1L << (UNION - 384)) | (1L << (UNIQUE - 384)) | (1L << (UNLIMITED - 384)) | (1L << (UNPIVOT - 384)) | (1L << (UNTIL - 384)) | (1L << (UPDATE - 384)) | (1L << (UPDATED - 384)) | (1L << (UPSERT - 384)) | (1L << (UROWID - 384)) | (1L << (USE - 384)) | (1L << (USING - 384)) | (1L << (VALIDATE - 384)) | (1L << (VALUE - 384)) | (1L << (VALUES - 384)) | (1L << (VARCHAR - 384)) | (1L << (VARCHAR2 - 384)) | (1L << (VARIABLE - 384)) | (1L << (VARRAY - 384)) | (1L << (VARYING - 384)) | (1L << (VERSION - 384)) | (1L << (VERSIONS - 384)) | (1L << (WAIT - 384)) | (1L << (WARNING - 384)) | (1L << (WELLFORMED - 384)) | (1L << (WHEN - 384)) | (1L << (WHENEVER - 384)) | (1L << (WHERE - 384)) | (1L << (WHILE - 384)) | (1L << (WITH - 384)) | (1L << (WITHIN - 384)) | (1L << (WORK - 384)) | (1L << (WRITE - 384)))) != 0) || ((((_la - 448)) & ~0x3f) == 0 && ((1L << (_la - 448)) & ((1L << (XML - 448)) | (1L << (XMLAGG - 448)) | (1L << (XMLATTRIBUTES - 448)) | (1L << (XMLCAST - 448)) | (1L << (XMLCOLATTVAL - 448)) | (1L << (XMLELEMENT - 448)) | (1L << (XMLEXISTS - 448)) | (1L << (XMLFOREST - 448)) | (1L << (XMLNAMESPACES - 448)) | (1L << (XMLPARSE - 448)) | (1L << (XMLPI - 448)) | (1L << (XMLQUERY - 448)) | (1L << (XMLROOT - 448)) | (1L << (XMLSERIALIZE - 448)) | (1L << (XMLTABLE - 448)) | (1L << (YEAR - 448)) | (1L << (YES - 448)) | (1L << (YMINTERVAL_UNCONSTRAINED - 448)) | (1L << (ZONE - 448)) | (1L << (PREDICTION - 448)) | (1L << (PREDICTION_BOUNDS - 448)) | (1L << (PREDICTION_COST - 448)) | (1L << (PREDICTION_DETAILS - 448)) | (1L << (PREDICTION_PROBABILITY - 448)) | (1L << (PREDICTION_SET - 448)) | (1L << (CUME_DIST - 448)) | (1L << (DENSE_RANK - 448)) | (1L << (LISTAGG - 448)) | (1L << (PERCENT_RANK - 448)) | (1L << (PERCENTILE_CONT - 448)) | (1L << (PERCENTILE_DISC - 448)) | (1L << (RANK - 448)) | (1L << (AVG - 448)) | (1L << (CORR - 448)) | (1L << (LAG - 448)) | (1L << (LEAD - 448)) | (1L << (MAX - 448)) | (1L << (MEDIAN - 448)) | (1L << (MIN - 448)) | (1L << (NTILE - 448)) | (1L << (RATIO_TO_REPORT - 448)) | (1L << (ROW_NUMBER - 448)) | (1L << (SUM - 448)) | (1L << (VARIANCE - 448)) | (1L << (REGR_ - 448)) | (1L << (STDDEV - 448)) | (1L << (VAR_ - 448)) | (1L << (COVAR_ - 448)))) != 0) || _la==REGULAR_ID) ) {
			_errHandler.RecoverInline(this);
			} else {
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x279\x1583\x4\x2"+
		"\t\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4"+
		"\t\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t(\x4)\t)\x4*\t"+
		"*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t\x30\x4\x31\t\x31\x4\x32"+
		"\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4\x35\t\x35\x4\x36\t\x36\x4\x37\t\x37"+
		"\x4\x38\t\x38\x4\x39\t\x39\x4:\t:\x4;\t;\x4<\t<\x4=\t=\x4>\t>\x4?\t?\x4"+
		"@\t@\x4\x41\t\x41\x4\x42\t\x42\x4\x43\t\x43\x4\x44\t\x44\x4\x45\t\x45"+
		"\x4\x46\t\x46\x4G\tG\x4H\tH\x4I\tI\x4J\tJ\x4K\tK\x4L\tL\x4M\tM\x4N\tN"+
		"\x4O\tO\x4P\tP\x4Q\tQ\x4R\tR\x4S\tS\x4T\tT\x4U\tU\x4V\tV\x4W\tW\x4X\t"+
		"X\x4Y\tY\x4Z\tZ\x4[\t[\x4\\\t\\\x4]\t]\x4^\t^\x4_\t_\x4`\t`\x4\x61\t\x61"+
		"\x4\x62\t\x62\x4\x63\t\x63\x4\x64\t\x64\x4\x65\t\x65\x4\x66\t\x66\x4g"+
		"\tg\x4h\th\x4i\ti\x4j\tj\x4k\tk\x4l\tl\x4m\tm\x4n\tn\x4o\to\x4p\tp\x4"+
		"q\tq\x4r\tr\x4s\ts\x4t\tt\x4u\tu\x4v\tv\x4w\tw\x4x\tx\x4y\ty\x4z\tz\x4"+
		"{\t{\x4|\t|\x4}\t}\x4~\t~\x4\x7F\t\x7F\x4\x80\t\x80\x4\x81\t\x81\x4\x82"+
		"\t\x82\x4\x83\t\x83\x4\x84\t\x84\x4\x85\t\x85\x4\x86\t\x86\x4\x87\t\x87"+
		"\x4\x88\t\x88\x4\x89\t\x89\x4\x8A\t\x8A\x4\x8B\t\x8B\x4\x8C\t\x8C\x4\x8D"+
		"\t\x8D\x4\x8E\t\x8E\x4\x8F\t\x8F\x4\x90\t\x90\x4\x91\t\x91\x4\x92\t\x92"+
		"\x4\x93\t\x93\x4\x94\t\x94\x4\x95\t\x95\x4\x96\t\x96\x4\x97\t\x97\x4\x98"+
		"\t\x98\x4\x99\t\x99\x4\x9A\t\x9A\x4\x9B\t\x9B\x4\x9C\t\x9C\x4\x9D\t\x9D"+
		"\x4\x9E\t\x9E\x4\x9F\t\x9F\x4\xA0\t\xA0\x4\xA1\t\xA1\x4\xA2\t\xA2\x4\xA3"+
		"\t\xA3\x4\xA4\t\xA4\x4\xA5\t\xA5\x4\xA6\t\xA6\x4\xA7\t\xA7\x4\xA8\t\xA8"+
		"\x4\xA9\t\xA9\x4\xAA\t\xAA\x4\xAB\t\xAB\x4\xAC\t\xAC\x4\xAD\t\xAD\x4\xAE"+
		"\t\xAE\x4\xAF\t\xAF\x4\xB0\t\xB0\x4\xB1\t\xB1\x4\xB2\t\xB2\x4\xB3\t\xB3"+
		"\x4\xB4\t\xB4\x4\xB5\t\xB5\x4\xB6\t\xB6\x4\xB7\t\xB7\x4\xB8\t\xB8\x4\xB9"+
		"\t\xB9\x4\xBA\t\xBA\x4\xBB\t\xBB\x4\xBC\t\xBC\x4\xBD\t\xBD\x4\xBE\t\xBE"+
		"\x4\xBF\t\xBF\x4\xC0\t\xC0\x4\xC1\t\xC1\x4\xC2\t\xC2\x4\xC3\t\xC3\x4\xC4"+
		"\t\xC4\x4\xC5\t\xC5\x4\xC6\t\xC6\x4\xC7\t\xC7\x4\xC8\t\xC8\x4\xC9\t\xC9"+
		"\x4\xCA\t\xCA\x4\xCB\t\xCB\x4\xCC\t\xCC\x4\xCD\t\xCD\x4\xCE\t\xCE\x4\xCF"+
		"\t\xCF\x4\xD0\t\xD0\x4\xD1\t\xD1\x4\xD2\t\xD2\x4\xD3\t\xD3\x4\xD4\t\xD4"+
		"\x4\xD5\t\xD5\x4\xD6\t\xD6\x4\xD7\t\xD7\x4\xD8\t\xD8\x4\xD9\t\xD9\x4\xDA"+
		"\t\xDA\x4\xDB\t\xDB\x4\xDC\t\xDC\x4\xDD\t\xDD\x4\xDE\t\xDE\x4\xDF\t\xDF"+
		"\x4\xE0\t\xE0\x4\xE1\t\xE1\x4\xE2\t\xE2\x4\xE3\t\xE3\x4\xE4\t\xE4\x4\xE5"+
		"\t\xE5\x4\xE6\t\xE6\x4\xE7\t\xE7\x4\xE8\t\xE8\x4\xE9\t\xE9\x4\xEA\t\xEA"+
		"\x4\xEB\t\xEB\x4\xEC\t\xEC\x4\xED\t\xED\x4\xEE\t\xEE\x4\xEF\t\xEF\x4\xF0"+
		"\t\xF0\x4\xF1\t\xF1\x4\xF2\t\xF2\x4\xF3\t\xF3\x4\xF4\t\xF4\x4\xF5\t\xF5"+
		"\x4\xF6\t\xF6\x4\xF7\t\xF7\x4\xF8\t\xF8\x4\xF9\t\xF9\x4\xFA\t\xFA\x4\xFB"+
		"\t\xFB\x4\xFC\t\xFC\x4\xFD\t\xFD\x4\xFE\t\xFE\x4\xFF\t\xFF\x4\x100\t\x100"+
		"\x4\x101\t\x101\x4\x102\t\x102\x4\x103\t\x103\x4\x104\t\x104\x4\x105\t"+
		"\x105\x4\x106\t\x106\x4\x107\t\x107\x4\x108\t\x108\x4\x109\t\x109\x4\x10A"+
		"\t\x10A\x4\x10B\t\x10B\x4\x10C\t\x10C\x4\x10D\t\x10D\x4\x10E\t\x10E\x4"+
		"\x10F\t\x10F\x4\x110\t\x110\x4\x111\t\x111\x4\x112\t\x112\x4\x113\t\x113"+
		"\x4\x114\t\x114\x4\x115\t\x115\x4\x116\t\x116\x4\x117\t\x117\x4\x118\t"+
		"\x118\x4\x119\t\x119\x4\x11A\t\x11A\x4\x11B\t\x11B\x4\x11C\t\x11C\x4\x11D"+
		"\t\x11D\x4\x11E\t\x11E\x4\x11F\t\x11F\x4\x120\t\x120\x4\x121\t\x121\x4"+
		"\x122\t\x122\x4\x123\t\x123\x4\x124\t\x124\x4\x125\t\x125\x4\x126\t\x126"+
		"\x4\x127\t\x127\x4\x128\t\x128\x4\x129\t\x129\x4\x12A\t\x12A\x4\x12B\t"+
		"\x12B\x4\x12C\t\x12C\x4\x12D\t\x12D\x4\x12E\t\x12E\x4\x12F\t\x12F\x4\x130"+
		"\t\x130\x4\x131\t\x131\x4\x132\t\x132\x4\x133\t\x133\x4\x134\t\x134\x4"+
		"\x135\t\x135\x4\x136\t\x136\x4\x137\t\x137\x4\x138\t\x138\x4\x139\t\x139"+
		"\x4\x13A\t\x13A\x4\x13B\t\x13B\x4\x13C\t\x13C\x4\x13D\t\x13D\x4\x13E\t"+
		"\x13E\x4\x13F\t\x13F\x4\x140\t\x140\x4\x141\t\x141\x4\x142\t\x142\x4\x143"+
		"\t\x143\x4\x144\t\x144\x4\x145\t\x145\x4\x146\t\x146\x4\x147\t\x147\x4"+
		"\x148\t\x148\x4\x149\t\x149\x4\x14A\t\x14A\x4\x14B\t\x14B\x4\x14C\t\x14C"+
		"\x4\x14D\t\x14D\x4\x14E\t\x14E\x4\x14F\t\x14F\x4\x150\t\x150\x4\x151\t"+
		"\x151\x4\x152\t\x152\x4\x153\t\x153\x4\x154\t\x154\x4\x155\t\x155\x4\x156"+
		"\t\x156\x4\x157\t\x157\x4\x158\t\x158\x4\x159\t\x159\x4\x15A\t\x15A\x4"+
		"\x15B\t\x15B\x4\x15C\t\x15C\x4\x15D\t\x15D\x4\x15E\t\x15E\x4\x15F\t\x15F"+
		"\x4\x160\t\x160\x4\x161\t\x161\x4\x162\t\x162\x4\x163\t\x163\x4\x164\t"+
		"\x164\x4\x165\t\x165\x4\x166\t\x166\x4\x167\t\x167\x4\x168\t\x168\x4\x169"+
		"\t\x169\x4\x16A\t\x16A\x4\x16B\t\x16B\x4\x16C\t\x16C\x4\x16D\t\x16D\x4"+
		"\x16E\t\x16E\x4\x16F\t\x16F\x4\x170\t\x170\x4\x171\t\x171\x4\x172\t\x172"+
		"\x4\x173\t\x173\x4\x174\t\x174\x4\x175\t\x175\x4\x176\t\x176\x4\x177\t"+
		"\x177\x4\x178\t\x178\x4\x179\t\x179\x4\x17A\t\x17A\x4\x17B\t\x17B\x4\x17C"+
		"\t\x17C\x4\x17D\t\x17D\x4\x17E\t\x17E\x4\x17F\t\x17F\x4\x180\t\x180\x4"+
		"\x181\t\x181\x4\x182\t\x182\x4\x183\t\x183\x4\x184\t\x184\x4\x185\t\x185"+
		"\x4\x186\t\x186\x3\x2\x6\x2\x30E\n\x2\r\x2\xE\x2\x30F\x3\x3\a\x3\x313"+
		"\n\x3\f\x3\xE\x3\x316\v\x3\x3\x3\x3\x3\x3\x4\x3\x4\x3\x4\a\x4\x31D\n\x4"+
		"\f\x4\xE\x4\x320\v\x4\x3\x4\x5\x4\x323\n\x4\x3\x4\a\x4\x326\n\x4\f\x4"+
		"\xE\x4\x329\v\x4\x3\x4\x5\x4\x32C\n\x4\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3"+
		"\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5"+
		"\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5\x345\n\x5\x3\x6\x3\x6\a\x6"+
		"\x349\n\x6\f\x6\xE\x6\x34C\v\x6\x3\a\x3\a\x3\b\x3\b\x3\b\x3\b\x3\b\x3"+
		"\t\x3\t\x3\t\x3\t\x3\t\x5\t\x35A\n\t\x3\t\a\t\x35D\n\t\f\t\xE\t\x360\v"+
		"\t\x3\t\x3\t\x5\t\x364\n\t\x3\t\x3\t\x3\n\x3\n\x3\n\x5\n\x36B\n\n\x5\n"+
		"\x36D\n\n\x3\n\x3\n\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\a\v\x377\n\v\f\v\xE"+
		"\v\x37A\v\v\x3\v\x3\v\x5\v\x37E\n\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v"+
		"\x3\v\x3\v\x3\v\a\v\x38A\n\v\f\v\xE\v\x38D\v\v\x3\v\x3\v\a\v\x391\n\v"+
		"\f\v\xE\v\x394\v\v\x3\v\x3\v\x5\v\x398\n\v\x5\v\x39A\n\v\x3\v\x3\v\x3"+
		"\f\x3\f\x5\f\x3A0\n\f\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3\r\x3"+
		"\r\a\r\x3AC\n\r\f\r\xE\r\x3AF\v\r\x3\r\x3\r\x5\r\x3B3\n\r\x3\r\x5\r\x3B6"+
		"\n\r\x3\r\x3\r\x3\xE\x3\xE\x5\xE\x3BC\n\xE\x3\xF\x3\xF\x3\xF\x3\xF\x3"+
		"\xF\a\xF\x3C3\n\xF\f\xF\xE\xF\x3C6\v\xF\x3\xF\x3\xF\x3\x10\x3\x10\x3\x10"+
		"\x3\x10\x3\x10\x3\x10\x3\x10\a\x10\x3D1\n\x10\f\x10\xE\x10\x3D4\v\x10"+
		"\x3\x10\x3\x10\x3\x11\x3\x11\x3\x11\x5\x11\x3DB\n\x11\x3\x11\x3\x11\x3"+
		"\x11\x3\x12\x3\x12\x3\x12\x3\x12\x3\x12\x5\x12\x3E5\n\x12\x3\x12\x5\x12"+
		"\x3E8\n\x12\x3\x12\a\x12\x3EB\n\x12\f\x12\xE\x12\x3EE\v\x12\x3\x12\x3"+
		"\x12\x5\x12\x3F2\n\x12\x3\x12\x3\x12\x3\x13\x3\x13\x3\x13\x5\x13\x3F9"+
		"\n\x13\x3\x13\x3\x13\x3\x13\x5\x13\x3FE\n\x13\x3\x13\x3\x13\x3\x13\x3"+
		"\x14\x3\x14\x3\x14\x3\x14\a\x14\x407\n\x14\f\x14\xE\x14\x40A\v\x14\x3"+
		"\x14\x3\x14\x5\x14\x40E\n\x14\x3\x14\x5\x14\x411\n\x14\x3\x14\x3\x14\x5"+
		"\x14\x415\n\x14\x3\x15\x3\x15\x5\x15\x419\n\x15\x3\x15\x3\x15\a\x15\x41D"+
		"\n\x15\f\x15\xE\x15\x420\v\x15\x3\x15\x3\x15\x5\x15\x424\n\x15\x3\x16"+
		"\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x3\x16\x5\x16"+
		"\x430\n\x16\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3"+
		"\x17\x3\x17\x5\x17\x43C\n\x17\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x19"+
		"\x3\x19\x3\x19\x3\x19\x3\x19\x5\x19\x448\n\x19\x3\x19\a\x19\x44B\n\x19"+
		"\f\x19\xE\x19\x44E\v\x19\x3\x19\x3\x19\x5\x19\x452\n\x19\x3\x19\x3\x19"+
		"\x3\x1A\x3\x1A\x3\x1A\x5\x1A\x459\n\x1A\x5\x1A\x45B\n\x1A\x3\x1A\x3\x1A"+
		"\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\a\x1B\x465\n\x1B\f\x1B\xE\x1B"+
		"\x468\v\x1B\x3\x1B\x3\x1B\x5\x1B\x46C\n\x1B\x3\x1B\x5\x1B\x46F\n\x1B\x3"+
		"\x1B\x3\x1B\a\x1B\x473\n\x1B\f\x1B\xE\x1B\x476\v\x1B\x3\x1B\x3\x1B\x3"+
		"\x1B\x5\x1B\x47B\n\x1B\x5\x1B\x47D\n\x1B\x3\x1B\x3\x1B\x3\x1C\x3\x1C\x3"+
		"\x1C\x3\x1C\x3\x1C\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3\x1D\x3"+
		"\x1D\x3\x1D\x5\x1D\x48F\n\x1D\x3\x1D\a\x1D\x492\n\x1D\f\x1D\xE\x1D\x495"+
		"\v\x1D\x3\x1D\x3\x1D\x5\x1D\x499\n\x1D\x5\x1D\x49B\n\x1D\x3\x1D\x3\x1D"+
		"\x3\x1E\x3\x1E\x3\x1E\x5\x1E\x4A2\n\x1E\x3\x1E\x3\x1E\x3\x1E\x3\x1E\x3"+
		"\x1E\x5\x1E\x4A9\n\x1E\x3\x1E\x5\x1E\x4AC\n\x1E\x3\x1E\x5\x1E\x4AF\n\x1E"+
		"\x3\x1E\x5\x1E\x4B2\n\x1E\x3\x1E\x3\x1E\x3\x1E\x3\x1F\x3\x1F\x3\x1F\x3"+
		"\x1F\a\x1F\x4BB\n\x1F\f\x1F\xE\x1F\x4BE\v\x1F\x3 \x3 \x3 \x3 \x3 \x3!"+
		"\x3!\x3!\x3!\x5!\x4C9\n!\x3!\x3!\x5!\x4CD\n!\x3!\x5!\x4D0\n!\x3\"\x3\""+
		"\x3\"\x3\"\x3#\x3#\x3#\x5#\x4D9\n#\x3$\x3$\x3$\x3$\a$\x4DF\n$\f$\xE$\x4E2"+
		"\v$\x3$\x3$\x3$\x3$\x3$\x5$\x4E9\n$\x3$\x5$\x4EC\n$\x3%\x3%\x3%\x3%\x3"+
		"%\x5%\x4F3\n%\x3&\x3&\x5&\x4F7\n&\x3\'\x3\'\x3\'\a\'\x4FC\n\'\f\'\xE\'"+
		"\x4FF\v\'\x3\'\x6\'\x502\n\'\r\'\xE\'\x503\x3\'\x3\'\x3\'\x3(\x3(\x3("+
		"\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3"+
		"(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x3(\x5(\x52D"+
		"\n(\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3"+
		")\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x3)\x5)\x549\n)\x3*\x3*\x3*\a*\x54E"+
		"\n*\f*\xE*\x551\v*\x3*\x3*\x5*\x555\n*\x3*\x3*\x3+\x3+\x3+\x3+\x3+\a+"+
		"\x55E\n+\f+\xE+\x561\v+\x5+\x563\n+\x3,\x3,\x3,\x3,\x3,\x3-\x3-\x6-\x56C"+
		"\n-\r-\xE-\x56D\x3.\x3.\x3.\x3/\x3/\x3/\x5/\x576\n/\x3/\x3/\x5/\x57A\n"+
		"/\x3/\x3/\x3\x30\x3\x30\x3\x30\x3\x30\x3\x30\x3\x30\x3\x30\x3\x30\x5\x30"+
		"\x586\n\x30\x3\x30\x5\x30\x589\n\x30\x3\x30\x3\x30\x3\x31\x3\x31\x5\x31"+
		"\x58F\n\x31\x3\x31\x5\x31\x592\n\x31\x3\x31\a\x31\x595\n\x31\f\x31\xE"+
		"\x31\x598\v\x31\x3\x31\x3\x31\x5\x31\x59C\n\x31\x3\x32\x3\x32\x5\x32\x5A0"+
		"\n\x32\x3\x32\x3\x32\x3\x32\x3\x32\x3\x32\x3\x32\a\x32\x5A8\n\x32\f\x32"+
		"\xE\x32\x5AB\v\x32\x3\x32\x3\x32\x3\x33\x3\x33\x3\x33\a\x33\x5B2\n\x33"+
		"\f\x33\xE\x33\x5B5\v\x33\x3\x34\x3\x34\x3\x34\x5\x34\x5BA\n\x34\x3\x35"+
		"\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\x3\x35\a\x35\x5C3\n\x35\f\x35\xE\x35"+
		"\x5C6\v\x35\x3\x35\x3\x35\x5\x35\x5CA\n\x35\x3\x36\x3\x36\x5\x36\x5CE"+
		"\n\x36\x3\x37\x3\x37\x3\x37\x3\x37\x3\x37\x3\x37\x5\x37\x5D6\n\x37\x3"+
		"\x38\x3\x38\x3\x38\x3\x38\x3\x38\x3\x38\x5\x38\x5DE\n\x38\x3\x38\x3\x38"+
		"\x3\x38\x5\x38\x5E3\n\x38\x3\x38\x5\x38\x5E6\n\x38\x5\x38\x5E8\n\x38\x3"+
		"\x39\x5\x39\x5EB\n\x39\x3\x39\x3\x39\x3\x39\x3\x39\x3:\x3:\x3:\x5:\x5F4"+
		"\n:\x3:\x3:\x3:\x5:\x5F9\n:\x3:\x3:\x3;\x3;\x3;\x5;\x600\n;\x3;\x5;\x603"+
		"\n;\x3<\x5<\x606\n<\x3<\x3<\x5<\x60A\n<\x3<\x5<\x60D\n<\x3<\x3<\x3<\x3"+
		"<\a<\x613\n<\f<\xE<\x616\v<\x3<\x3<\x5<\x61A\n<\x3<\a<\x61D\n<\f<\xE<"+
		"\x620\v<\x3=\x3=\x3=\x3=\x5=\x626\n=\x3>\x3>\x3>\x3?\x3?\x3?\x3?\x3?\x5"+
		"?\x630\n?\x3@\x3@\x3@\x3@\x3@\x3@\x3@\x3@\x3\x41\x3\x41\x3\x41\x3\x41"+
		"\x6\x41\x63E\n\x41\r\x41\xE\x41\x63F\x3\x41\x3\x41\x3\x42\x3\x42\x5\x42"+
		"\x646\n\x42\x3\x43\x3\x43\x3\x43\x3\x43\x3\x44\x3\x44\x3\x44\x3\x44\x5"+
		"\x44\x650\n\x44\x3\x45\x3\x45\x3\x45\x3\x45\x3\x45\x3\x45\a\x45\x658\n"+
		"\x45\f\x45\xE\x45\x65B\v\x45\x3\x45\x3\x45\x3\x45\x3\x45\a\x45\x661\n"+
		"\x45\f\x45\xE\x45\x664\v\x45\x3\x45\x3\x45\x3\x45\x5\x45\x669\n\x45\x3"+
		"\x46\x3\x46\x3\x46\x3\x46\x3\x46\x3\x46\a\x46\x671\n\x46\f\x46\xE\x46"+
		"\x674\v\x46\x3\x46\x3\x46\x5\x46\x678\n\x46\x3\x46\x3\x46\x3\x46\x3\x46"+
		"\x3\x46\a\x46\x67F\n\x46\f\x46\xE\x46\x682\v\x46\x3\x46\x3\x46\x3\x46"+
		"\x5\x46\x687\n\x46\x3G\x5G\x68A\nG\x3G\x5G\x68D\nG\x3G\x3G\x3G\x3G\x3"+
		"G\x3G\x3G\x3G\x3G\x3G\x3G\x3G\x3G\aG\x69C\nG\fG\xEG\x69F\vG\x3G\x3G\x5"+
		"G\x6A3\nG\x3G\x3G\x3G\x3G\x3G\x3G\x3G\aG\x6AC\nG\fG\xEG\x6AF\vG\x3G\x3"+
		"G\x3G\x5G\x6B4\nG\x3H\x5H\x6B7\nH\x3H\x3H\x3I\x3I\x3I\x5I\x6BE\nI\x3I"+
		"\x5I\x6C1\nI\x3J\x3J\x3J\x3J\x3K\x5K\x6C8\nK\x3K\x6K\x6CB\nK\rK\xEK\x6CC"+
		"\x3K\x3K\x5K\x6D1\nK\x3L\x3L\x3L\x5L\x6D6\nL\x3M\x3M\x3M\x5M\x6DB\nM\x3"+
		"N\x3N\x3N\x3N\x3N\x3N\aN\x6E3\nN\fN\xEN\x6E6\vN\x3N\x3N\x3N\x3N\x5N\x6EC"+
		"\nN\x3O\x3O\x3O\x3O\x3O\x3O\aO\x6F4\nO\fO\xEO\x6F7\vO\x3O\x3O\x5O\x6FB"+
		"\nO\x3O\x3O\x3O\x3O\x3O\x5O\x702\nO\x3O\x3O\x3O\x3O\x3O\x5O\x709\nO\x3"+
		"O\x3O\x5O\x70D\nO\x3P\x5P\x710\nP\x3P\x5P\x713\nP\x3P\x3P\x3P\x3P\x3P"+
		"\x3P\x3P\x3P\x3P\x3P\x3P\x3P\x3P\aP\x722\nP\fP\xEP\x725\vP\x3P\x3P\x5"+
		"P\x729\nP\x3P\x3P\x3P\x3P\x3P\x3P\x3P\x5P\x732\nP\x3Q\x3Q\x3Q\x3Q\x3R"+
		"\x3R\x3R\x3R\x3R\x3R\aR\x73E\nR\fR\xER\x741\vR\x3R\x3R\x3S\x3S\x5S\x747"+
		"\nS\x3T\x3T\x3T\x3U\x3U\x3U\x3U\x3U\x3V\x3V\x3V\x3V\x6V\x755\nV\rV\xE"+
		"V\x756\x3V\x3V\x3W\x3W\x3W\x3W\x3W\aW\x760\nW\fW\xEW\x763\vW\x3W\x3W\x3"+
		"X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x3X\x5X\x777"+
		"\nX\x3Y\x3Y\x3Y\x3Y\x3Z\x3Z\x3Z\x3[\x3[\x3[\x3[\x3\\\x3\\\x3\\\x5\\\x787"+
		"\n\\\x3]\x3]\x3]\x3]\x3^\x3^\x3^\x5^\x790\n^\x3^\x3^\x3^\x5^\x795\n^\x3"+
		"^\x3^\x5^\x799\n^\x3^\x5^\x79C\n^\x3_\x3_\x3_\x3_\x3_\x3_\a_\x7A4\n_\f"+
		"_\xE_\x7A7\v_\x3_\x3_\x3`\x3`\x3`\x3`\x3`\a`\x7B0\n`\f`\xE`\x7B3\v`\x3"+
		"`\x3`\x3`\x5`\x7B8\n`\x3`\x3`\x3\x61\x3\x61\a\x61\x7BE\n\x61\f\x61\xE"+
		"\x61\x7C1\v\x61\x3\x61\x5\x61\x7C4\n\x61\x3\x61\x5\x61\x7C7\n\x61\x3\x62"+
		"\x3\x62\x3\x62\x3\x63\x3\x63\x3\x63\x3\x63\x3\x63\x3\x63\x3\x63\x3\x63"+
		"\x3\x63\x3\x63\x5\x63\x7D6\n\x63\x3\x64\x3\x64\x5\x64\x7DA\n\x64\x3\x64"+
		"\x3\x64\x3\x64\x5\x64\x7DF\n\x64\x3\x64\x5\x64\x7E2\n\x64\x3\x64\x3\x64"+
		"\x3\x65\x3\x65\x3\x65\x3\x65\x3\x65\x3\x65\x3\x65\x3\x65\x3\x65\x5\x65"+
		"\x7EF\n\x65\x3\x65\x3\x65\x5\x65\x7F3\n\x65\x3\x65\x3\x65\x3\x66\x3\x66"+
		"\x3\x66\x3\x66\x3\x66\x3\x66\a\x66\x7FD\n\x66\f\x66\xE\x66\x800\v\x66"+
		"\x3\x66\x3\x66\x5\x66\x804\n\x66\x3\x66\x3\x66\x5\x66\x808\n\x66\x3\x66"+
		"\x3\x66\x5\x66\x80C\n\x66\x3\x66\x3\x66\x3g\x3g\x5g\x812\ng\x3g\x5g\x815"+
		"\ng\x3g\x5g\x818\ng\x3h\x3h\x3h\x3h\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x5"+
		"i\x826\ni\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x3i\x5i"+
		"\x836\ni\x3i\x3i\x6i\x83A\ni\ri\xEi\x83B\x3i\x3i\x5i\x840\ni\x3i\x3i\x3"+
		"j\x3j\x5j\x846\nj\x3k\x3k\x3k\x3k\x3k\x3k\x3k\x3k\ak\x850\nk\fk\xEk\x853"+
		"\vk\x3k\x3k\x3k\x3k\x3k\x3k\x5k\x85B\nk\x5k\x85D\nk\x3k\x3k\x3l\x3l\x5"+
		"l\x863\nl\x3l\x3l\x5l\x867\nl\x3l\x5l\x86A\nl\x3m\x3m\x3m\x3m\x5m\x870"+
		"\nm\x3m\x3m\x3m\x5m\x875\nm\x5m\x877\nm\x3m\x3m\x3n\x3n\x5n\x87D\nn\x3"+
		"n\x3n\x3o\x3o\x3o\x3o\x3o\x3o\x3o\x5o\x888\no\x3o\x3o\x5o\x88C\no\x3o"+
		"\x5o\x88F\no\x3p\x3p\x5p\x893\np\x3p\x3p\x3p\x3q\x3q\x3q\x5q\x89B\nq\x3"+
		"q\x3q\x3q\x3q\x3q\x3q\x3q\x5q\x8A4\nq\x3r\x3r\x3r\x3s\x3s\x3s\x3s\x3s"+
		"\x6s\x8AE\ns\rs\xEs\x8AF\x3t\x3t\x3t\x3t\x3t\x3t\x3u\x3u\x3u\x3u\x3u\x3"+
		"u\x3u\x3u\x3u\x3u\x3u\x3u\x3u\x3u\x3u\x3u\x3u\x3u\x3u\x3u\x3u\x3u\x3u"+
		"\x3u\x3u\x3u\x3u\x5u\x8D3\nu\x3v\x3v\x3v\x5v\x8D8\nv\x3v\x3v\x3v\x3w\x3"+
		"w\x5w\x8DF\nw\x3w\x3w\x5w\x8E3\nw\x3x\x3x\x5x\x8E7\nx\x3x\x3x\x5x\x8EB"+
		"\nx\x3y\x3y\x3y\x3z\x3z\x3z\x3z\x3z\az\x8F5\nz\fz\xEz\x8F8\vz\x3z\x5z"+
		"\x8FB\nz\x3z\x3z\x3z\x3{\x3{\x3{\x3{\x3{\x3|\x3|\x3|\x3}\x5}\x909\n}\x3"+
		"}\x3}\x3}\x3}\x5}\x90F\n}\x3}\x3}\x3}\x3}\x3}\x5}\x916\n}\x3~\x3~\x3~"+
		"\x5~\x91B\n~\x3~\x3~\x3~\x3~\x3~\x3~\x3~\x3~\x5~\x925\n~\x3~\x3~\x3~\x3"+
		"~\x5~\x92B\n~\x5~\x92D\n~\x3\x7F\x3\x7F\x3\x7F\x3\x7F\x3\x7F\x3\x7F\x3"+
		"\x7F\x5\x7F\x936\n\x7F\x3\x80\x3\x80\x3\x80\x3\x80\x3\x80\x3\x80\x3\x80"+
		"\x3\x80\x5\x80\x940\n\x80\x3\x80\x3\x80\x3\x80\x5\x80\x945\n\x80\x3\x81"+
		"\x3\x81\x3\x81\x3\x81\x3\x81\x3\x82\x3\x82\x3\x83\x3\x83\x3\x84\x3\x84"+
		"\x3\x85\x3\x85\x5\x85\x954\n\x85\x3\x86\x3\x86\x5\x86\x958\n\x86\x3\x87"+
		"\x5\x87\x95B\n\x87\x3\x87\x3\x87\x5\x87\x95F\n\x87\x3\x88\x3\x88\x3\x88"+
		"\x5\x88\x964\n\x88\x3\x88\x3\x88\x5\x88\x968\n\x88\x3\x89\x3\x89\x3\x89"+
		"\x3\x89\x3\x89\x3\x89\x3\x89\x5\x89\x971\n\x89\x5\x89\x973\n\x89\x3\x89"+
		"\x5\x89\x976\n\x89\x3\x89\x3\x89\x3\x89\x3\x89\x3\x89\x3\x89\x3\x89\x5"+
		"\x89\x97F\n\x89\x5\x89\x981\n\x89\x3\x89\x5\x89\x984\n\x89\x3\x89\x3\x89"+
		"\x3\x89\x3\x89\x3\x89\x5\x89\x98B\n\x89\x3\x89\x5\x89\x98E\n\x89\x5\x89"+
		"\x990\n\x89\x3\x8A\x3\x8A\x3\x8A\x3\x8A\x3\x8A\x3\x8A\x3\x8B\x3\x8B\x6"+
		"\x8B\x99A\n\x8B\r\x8B\xE\x8B\x99B\x3\x8C\x3\x8C\x3\x8C\x3\x8C\a\x8C\x9A2"+
		"\n\x8C\f\x8C\xE\x8C\x9A5\v\x8C\x3\x8C\x3\x8C\x3\x8C\x3\x8D\x5\x8D\x9AB"+
		"\n\x8D\x3\x8D\x3\x8D\x3\x8E\x5\x8E\x9B0\n\x8E\x3\x8E\x3\x8E\x3\x8F\x3"+
		"\x8F\x3\x8F\x3\x8F\x5\x8F\x9B8\n\x8F\x3\x90\x3\x90\x3\x90\x3\x90\x3\x90"+
		"\x5\x90\x9BF\n\x90\x3\x90\x3\x90\x5\x90\x9C3\n\x90\x3\x90\x5\x90\x9C6"+
		"\n\x90\x3\x91\x3\x91\x3\x91\x3\x92\x3\x92\x3\x92\x3\x92\x3\x92\x3\x92"+
		"\x3\x92\x5\x92\x9D2\n\x92\x3\x93\x3\x93\x3\x93\x3\x93\x5\x93\x9D8\n\x93"+
		"\x3\x94\x3\x94\x3\x94\x3\x95\x3\x95\x3\x95\x5\x95\x9E0\n\x95\x3\x96\x3"+
		"\x96\x3\x96\x3\x96\x3\x96\x3\x96\a\x96\x9E8\n\x96\f\x96\xE\x96\x9EB\v"+
		"\x96\x3\x96\x3\x96\x3\x96\x3\x96\x3\x96\x3\x96\a\x96\x9F3\n\x96\f\x96"+
		"\xE\x96\x9F6\v\x96\x3\x96\x3\x96\x3\x96\x5\x96\x9FB\n\x96\x5\x96\x9FD"+
		"\n\x96\x5\x96\x9FF\n\x96\x3\x97\x3\x97\x3\x97\x3\x97\x3\x97\x5\x97\xA06"+
		"\n\x97\x3\x97\x5\x97\xA09\n\x97\x3\x98\x3\x98\x3\x98\x3\x98\x3\x98\x5"+
		"\x98\xA10\n\x98\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99\x3\x99"+
		"\x3\x99\x5\x99\xA1B\n\x99\x3\x99\x3\x99\x3\x99\x3\x99\x5\x99\xA21\n\x99"+
		"\x3\x99\x3\x99\x5\x99\xA25\n\x99\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3\x9A\x3"+
		"\x9A\a\x9A\xA2D\n\x9A\f\x9A\xE\x9A\xA30\v\x9A\x5\x9A\xA32\n\x9A\x3\x9A"+
		"\x3\x9A\x3\x9B\x3\x9B\x5\x9B\xA38\n\x9B\x3\x9B\x3\x9B\x3\x9B\x3\x9B\x3"+
		"\x9B\x3\x9B\x3\x9B\x3\x9B\x3\x9B\x5\x9B\xA43\n\x9B\x5\x9B\xA45\n\x9B\x5"+
		"\x9B\xA47\n\x9B\x3\x9B\x5\x9B\xA4A\n\x9B\x3\x9C\x3\x9C\x5\x9C\xA4E\n\x9C"+
		"\x3\x9C\x5\x9C\xA51\n\x9C\x3\x9D\x3\x9D\x5\x9D\xA55\n\x9D\x3\x9D\x3\x9D"+
		"\x5\x9D\xA59\n\x9D\x3\x9D\x3\x9D\x3\x9D\x5\x9D\xA5E\n\x9D\x3\x9E\x3\x9E"+
		"\x3\x9E\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x5\x9F\xA69\n\x9F\x3"+
		"\x9F\x3\x9F\x5\x9F\xA6D\n\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F\x3\x9F"+
		"\x5\x9F\xA75\n\x9F\x3\xA0\x3\xA0\x3\xA0\a\xA0\xA7A\n\xA0\f\xA0\xE\xA0"+
		"\xA7D\v\xA0\x3\xA1\x3\xA1\x3\xA1\x3\xA1\a\xA1\xA83\n\xA1\f\xA1\xE\xA1"+
		"\xA86\v\xA1\x3\xA2\x3\xA2\x3\xA2\x3\xA2\x3\xA2\a\xA2\xA8D\n\xA2\f\xA2"+
		"\xE\xA2\xA90\v\xA2\x3\xA2\x3\xA2\x5\xA2\xA94\n\xA2\x3\xA2\x3\xA2\x3\xA2"+
		"\x3\xA2\x5\xA2\xA9A\n\xA2\x3\xA2\x3\xA2\x5\xA2\xA9E\n\xA2\x3\xA2\x5\xA2"+
		"\xAA1\n\xA2\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x3\xA3\x5\xA3\xAA9\n\xA3"+
		"\x3\xA3\x5\xA3\xAAC\n\xA3\x3\xA3\x3\xA3\x5\xA3\xAB0\n\xA3\x3\xA3\x3\xA3"+
		"\x5\xA3\xAB4\n\xA3\x3\xA3\x3\xA3\x3\xA3\x5\xA3\xAB9\n\xA3\x3\xA3\x5\xA3"+
		"\xABC\n\xA3\x3\xA3\x3\xA3\x5\xA3\xAC0\n\xA3\x3\xA3\x3\xA3\x5\xA3\xAC4"+
		"\n\xA3\a\xA3\xAC6\n\xA3\f\xA3\xE\xA3\xAC9\v\xA3\x3\xA3\x3\xA3\x3\xA3\x3"+
		"\xA4\x3\xA4\x3\xA4\x3\xA4\a\xA4\xAD2\n\xA4\f\xA4\xE\xA4\xAD5\v\xA4\x3"+
		"\xA4\x3\xA4\x3\xA4\x3\xA4\x3\xA4\x3\xA4\x3\xA4\x3\xA5\x3\xA5\a\xA5\xAE0"+
		"\n\xA5\f\xA5\xE\xA5\xAE3\v\xA5\x3\xA6\x3\xA6\x5\xA6\xAE7\n\xA6\x3\xA6"+
		"\x3\xA6\x5\xA6\xAEB\n\xA6\x3\xA6\x3\xA6\x3\xA7\x3\xA7\x3\xA7\x3\xA7\x3"+
		"\xA7\x5\xA7\xAF4\n\xA7\x3\xA8\x5\xA8\xAF7\n\xA8\x3\xA8\x3\xA8\x5\xA8\xAFB"+
		"\n\xA8\x3\xA8\x3\xA8\x3\xA8\x3\xA8\a\xA8\xB01\n\xA8\f\xA8\xE\xA8\xB04"+
		"\v\xA8\x5\xA8\xB06\n\xA8\x3\xA8\x5\xA8\xB09\n\xA8\x3\xA8\x3\xA8\x5\xA8"+
		"\xB0D\n\xA8\x3\xA8\x5\xA8\xB10\n\xA8\x3\xA8\x5\xA8\xB13\n\xA8\x3\xA8\x5"+
		"\xA8\xB16\n\xA8\x3\xA8\x5\xA8\xB19\n\xA8\x3\xA8\x5\xA8\xB1C\n\xA8\x3\xA9"+
		"\x3\xA9\x5\xA9\xB20\n\xA9\x3\xAA\x3\xAA\x3\xAA\x3\xAB\x3\xAB\x3\xAB\x3"+
		"\xAB\x3\xAB\x5\xAB\xB2A\n\xAB\x3\xAC\x3\xAC\x3\xAC\a\xAC\xB2F\n\xAC\f"+
		"\xAC\xE\xAC\xB32\v\xAC\x3\xAD\x3\xAD\a\xAD\xB36\n\xAD\f\xAD\xE\xAD\xB39"+
		"\v\xAD\x3\xAD\x3\xAD\x5\xAD\xB3D\n\xAD\x3\xAE\x3\xAE\x3\xAE\x5\xAE\xB42"+
		"\n\xAE\x3\xAE\x3\xAE\x3\xAE\a\xAE\xB47\n\xAE\f\xAE\xE\xAE\xB4A\v\xAE\x3"+
		"\xAE\x3\xAE\x3\xAE\x5\xAE\xB4F\n\xAE\x3\xAE\x3\xAE\x3\xAE\x3\xAE\x3\xAE"+
		"\x3\xAE\x3\xAE\x3\xAE\x5\xAE\xB59\n\xAE\x3\xAE\x5\xAE\xB5C\n\xAE\x3\xAE"+
		"\a\xAE\xB5F\n\xAE\f\xAE\xE\xAE\xB62\v\xAE\x3\xAE\x5\xAE\xB65\n\xAE\x3"+
		"\xAF\x5\xAF\xB68\n\xAF\x3\xAF\x5\xAF\xB6B\n\xAF\x3\xAF\x3\xAF\x5\xAF\xB6F"+
		"\n\xAF\x3\xAF\x3\xAF\x3\xAF\x5\xAF\xB74\n\xAF\x3\xAF\x3\xAF\a\xAF\xB78"+
		"\n\xAF\f\xAF\xE\xAF\xB7B\v\xAF\x3\xB0\x3\xB0\x3\xB0\x3\xB1\x3\xB1\x3\xB1"+
		"\x3\xB1\x3\xB1\a\xB1\xB85\n\xB1\f\xB1\xE\xB1\xB88\v\xB1\x3\xB1\x3\xB1"+
		"\x3\xB2\x3\xB2\x5\xB2\xB8E\n\xB2\x3\xB3\x3\xB3\x3\xB3\x3\xB3\x3\xB3\x3"+
		"\xB3\x3\xB3\x3\xB3\x3\xB3\x3\xB3\a\xB3\xB9A\n\xB3\f\xB3\xE\xB3\xB9D\v"+
		"\xB3\x5\xB3\xB9F\n\xB3\x3\xB4\x3\xB4\x3\xB4\x3\xB4\x3\xB4\x3\xB4\x3\xB4"+
		"\x3\xB4\x5\xB4\xBA9\n\xB4\x3\xB5\x3\xB5\x5\xB5\xBAD\n\xB5\x3\xB5\x3\xB5"+
		"\x3\xB5\x3\xB5\a\xB5\xBB3\n\xB5\f\xB5\xE\xB5\xBB6\v\xB5\x3\xB5\x3\xB5"+
		"\x3\xB5\x3\xB5\x3\xB6\x3\xB6\x3\xB6\x3\xB6\x3\xB6\x5\xB6\xBC1\n\xB6\x3"+
		"\xB7\x3\xB7\x3\xB7\x3\xB7\x3\xB7\x3\xB7\a\xB7\xBC9\n\xB7\f\xB7\xE\xB7"+
		"\xBCC\v\xB7\x3\xB7\x3\xB7\x5\xB7\xBD0\n\xB7\x3\xB8\x3\xB8\x3\xB8\x3\xB8"+
		"\x3\xB8\x3\xB8\a\xB8\xBD8\n\xB8\f\xB8\xE\xB8\xBDB\v\xB8\x3\xB8\x3\xB8"+
		"\x3\xB8\a\xB8\xBE0\n\xB8\f\xB8\xE\xB8\xBE3\v\xB8\x5\xB8\xBE5\n\xB8\x3"+
		"\xB8\x3\xB8\x3\xB9\x3\xB9\x5\xB9\xBEB\n\xB9\x3\xBA\x3\xBA\x5\xBA\xBEF"+
		"\n\xBA\x3\xBB\x3\xBB\x3\xBB\x5\xBB\xBF4\n\xBB\x3\xBB\x3\xBB\x3\xBB\x3"+
		"\xBB\x3\xBB\x3\xBB\a\xBB\xBFC\n\xBB\f\xBB\xE\xBB\xBFF\v\xBB\x3\xBB\x3"+
		"\xBB\x5\xBB\xC03\n\xBB\x3\xBB\x3\xBB\x3\xBB\x3\xBB\x3\xBC\x3\xBC\x3\xBC"+
		"\x3\xBC\x3\xBC\a\xBC\xC0E\n\xBC\f\xBC\xE\xBC\xC11\v\xBC\x3\xBC\x3\xBC"+
		"\x3\xBD\x3\xBD\x3\xBD\x3\xBD\x3\xBD\a\xBD\xC1A\n\xBD\f\xBD\xE\xBD\xC1D"+
		"\v\xBD\x3\xBD\x3\xBD\x5\xBD\xC21\n\xBD\x3\xBD\x3\xBD\x3\xBD\x3\xBD\x3"+
		"\xBD\x3\xBD\a\xBD\xC29\n\xBD\f\xBD\xE\xBD\xC2C\v\xBD\x3\xBD\x3\xBD\x5"+
		"\xBD\xC30\n\xBD\x5\xBD\xC32\n\xBD\x3\xBE\x3\xBE\x3\xBE\x5\xBE\xC37\n\xBE"+
		"\x3\xBE\x3\xBE\x5\xBE\xC3B\n\xBE\x3\xBE\x3\xBE\x3\xBE\x3\xBE\x5\xBE\xC41"+
		"\n\xBE\x3\xBE\x3\xBE\x5\xBE\xC45\n\xBE\x3\xBF\x3\xBF\x3\xBF\x3\xBF\x3"+
		"\xC0\x3\xC0\x3\xC0\x3\xC0\x3\xC0\a\xC0\xC50\n\xC0\f\xC0\xE\xC0\xC53\v"+
		"\xC0\x3\xC0\x5\xC0\xC56\n\xC0\x3\xC0\x3\xC0\x3\xC0\x3\xC0\x3\xC0\x3\xC0"+
		"\a\xC0\xC5E\n\xC0\f\xC0\xE\xC0\xC61\v\xC0\x5\xC0\xC63\n\xC0\x5\xC0\xC65"+
		"\n\xC0\x3\xC1\x3\xC1\x3\xC1\x5\xC1\xC6A\n\xC1\x3\xC2\x3\xC2\x3\xC2\x3"+
		"\xC2\x3\xC2\a\xC2\xC71\n\xC2\f\xC2\xE\xC2\xC74\v\xC2\x3\xC2\x3\xC2\x3"+
		"\xC3\x3\xC3\x3\xC3\x3\xC3\x3\xC3\x3\xC3\a\xC3\xC7E\n\xC3\f\xC3\xE\xC3"+
		"\xC81\v\xC3\x3\xC3\x3\xC3\x3\xC4\x3\xC4\x3\xC4\x5\xC4\xC88\n\xC4\x3\xC5"+
		"\x3\xC5\x3\xC5\x3\xC6\x3\xC6\a\xC6\xC8F\n\xC6\f\xC6\xE\xC6\xC92\v\xC6"+
		"\x3\xC6\x5\xC6\xC95\n\xC6\x3\xC6\a\xC6\xC98\n\xC6\f\xC6\xE\xC6\xC9B\v"+
		"\xC6\x3\xC6\x3\xC6\x3\xC7\x3\xC7\x3\xC7\x3\xC7\x3\xC7\x3\xC7\x5\xC7\xCA5"+
		"\n\xC7\x5\xC7\xCA7\n\xC7\x3\xC8\x3\xC8\x3\xC8\x3\xC8\x3\xC9\x3\xC9\x3"+
		"\xC9\x3\xC9\x3\xC9\x3\xC9\x3\xC9\x3\xC9\a\xC9\xCB5\n\xC9\f\xC9\xE\xC9"+
		"\xCB8\v\xC9\x3\xCA\x3\xCA\x5\xCA\xCBC\n\xCA\x3\xCA\x3\xCA\a\xCA\xCC0\n"+
		"\xCA\f\xCA\xE\xCA\xCC3\v\xCA\x3\xCA\x3\xCA\x3\xCB\x5\xCB\xCC8\n\xCB\x3"+
		"\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCB\x3\xCC\x3\xCC\x3\xCC\x3\xCC\x3"+
		"\xCD\x3\xCD\x3\xCD\x3\xCD\a\xCD\xCD8\n\xCD\f\xCD\xE\xCD\xCDB\v\xCD\x3"+
		"\xCD\x3\xCD\x3\xCE\x3\xCE\x5\xCE\xCE1\n\xCE\x3\xCF\x5\xCF\xCE4\n\xCF\x3"+
		"\xCF\x3\xCF\x3\xCF\x3\xCF\a\xCF\xCEA\n\xCF\f\xCF\xE\xCF\xCED\v\xCF\x3"+
		"\xCF\x3\xCF\x3\xD0\x3\xD0\x3\xD0\x3\xD0\x5\xD0\xCF5\n\xD0\x5\xD0\xCF7"+
		"\n\xD0\x3\xD0\x3\xD0\x5\xD0\xCFB\n\xD0\x3\xD0\x5\xD0\xCFE\n\xD0\x3\xD1"+
		"\x3\xD1\x3\xD1\x5\xD1\xD03\n\xD1\x5\xD1\xD05\n\xD1\x3\xD1\x3\xD1\x5\xD1"+
		"\xD09\n\xD1\x3\xD1\x3\xD1\x3\xD1\x3\xD2\x3\xD2\x3\xD3\x3\xD3\x3\xD3\x3"+
		"\xD3\x3\xD3\x5\xD3\xD15\n\xD3\x3\xD4\x3\xD4\x3\xD4\x3\xD4\x3\xD4\x3\xD5"+
		"\x3\xD5\x5\xD5\xD1E\n\xD5\x3\xD5\x3\xD5\x3\xD5\x3\xD5\a\xD5\xD24\n\xD5"+
		"\f\xD5\xE\xD5\xD27\v\xD5\x3\xD6\x3\xD6\x5\xD6\xD2B\n\xD6\x3\xD6\x3\xD6"+
		"\x5\xD6\xD2F\n\xD6\x3\xD7\x3\xD7\x3\xD7\x5\xD7\xD34\n\xD7\x3\xD7\x5\xD7"+
		"\xD37\n\xD7\x3\xD8\x3\xD8\x3\xD8\x3\xD8\a\xD8\xD3D\n\xD8\f\xD8\xE\xD8"+
		"\xD40\v\xD8\x3\xD9\x3\xD9\x3\xD9\x3\xD9\x3\xD9\x5\xD9\xD47\n\xD9\x3\xDA"+
		"\x3\xDA\x3\xDA\x3\xDA\x5\xDA\xD4D\n\xDA\x3\xDA\x5\xDA\xD50\n\xDA\x3\xDA"+
		"\x5\xDA\xD53\n\xDA\x3\xDB\x3\xDB\x3\xDB\x3\xDB\a\xDB\xD59\n\xDB\f\xDB"+
		"\xE\xDB\xD5C\v\xDB\x3\xDB\x3\xDB\x3\xDB\x3\xDB\x3\xDB\x3\xDB\x3\xDB\x5"+
		"\xDB\xD65\n\xDB\x3\xDC\x3\xDC\x3\xDC\x3\xDC\x3\xDC\x3\xDC\x3\xDC\x3\xDC"+
		"\a\xDC\xD6F\n\xDC\f\xDC\xE\xDC\xD72\v\xDC\x3\xDC\x3\xDC\x3\xDC\x3\xDC"+
		"\x5\xDC\xD78\n\xDC\x3\xDD\x3\xDD\x5\xDD\xD7C\n\xDD\x3\xDD\x3\xDD\x5\xDD"+
		"\xD80\n\xDD\x3\xDD\x5\xDD\xD83\n\xDD\x3\xDD\x5\xDD\xD86\n\xDD\x3\xDE\x3"+
		"\xDE\x3\xDE\x5\xDE\xD8B\n\xDE\x3\xDF\x3\xDF\x3\xDF\x5\xDF\xD90\n\xDF\x3"+
		"\xDF\x5\xDF\xD93\n\xDF\x3\xDF\x5\xDF\xD96\n\xDF\x3\xE0\x3\xE0\x6\xE0\xD9A"+
		"\n\xE0\r\xE0\xE\xE0\xD9B\x3\xE0\x5\xE0\xD9F\n\xE0\x3\xE0\x3\xE0\x3\xE1"+
		"\x3\xE1\x5\xE1\xDA5\n\xE1\x3\xE1\x5\xE1\xDA8\n\xE1\x3\xE2\x5\xE2\xDAB"+
		"\n\xE2\x3\xE2\x6\xE2\xDAE\n\xE2\r\xE2\xE\xE2\xDAF\x3\xE2\x5\xE2\xDB3\n"+
		"\xE2\x3\xE3\x3\xE3\x3\xE3\x3\xE3\x6\xE3\xDB9\n\xE3\r\xE3\xE\xE3\xDBA\x3"+
		"\xE4\x3\xE4\x6\xE4\xDBF\n\xE4\r\xE4\xE\xE4\xDC0\x3\xE5\x3\xE5\x3\xE5\x3"+
		"\xE5\x3\xE5\x3\xE5\a\xE5\xDC9\n\xE5\f\xE5\xE\xE5\xDCC\v\xE5\x3\xE5\x3"+
		"\xE5\x5\xE5\xDD0\n\xE5\x3\xE6\x3\xE6\x3\xE6\x3\xE6\x5\xE6\xDD6\n\xE6\x3"+
		"\xE7\x3\xE7\x3\xE7\x3\xE7\x5\xE7\xDDC\n\xE7\x3\xE7\x3\xE7\x3\xE7\x3\xE7"+
		"\x3\xE7\x3\xE7\x3\xE7\x3\xE7\x5\xE7\xDE6\n\xE7\x3\xE7\x3\xE7\x5\xE7\xDEA"+
		"\n\xE7\x5\xE7\xDEC\n\xE7\x3\xE7\x5\xE7\xDEF\n\xE7\x3\xE8\x3\xE8\x3\xE8"+
		"\x3\xE8\x3\xE8\x3\xE8\x3\xE8\x3\xE8\a\xE8\xDF9\n\xE8\f\xE8\xE\xE8\xDFC"+
		"\v\xE8\x3\xE8\x5\xE8\xDFF\n\xE8\x3\xE8\x5\xE8\xE02\n\xE8\x3\xE9\x3\xE9"+
		"\x3\xE9\x3\xE9\x3\xEA\x3\xEA\x3\xEA\x3\xEB\x3\xEB\x3\xEB\x3\xEB\x3\xEB"+
		"\x3\xEB\x3\xEB\x3\xEB\x3\xEB\a\xEB\xE14\n\xEB\f\xEB\xE\xEB\xE17\v\xEB"+
		"\x3\xEB\x3\xEB\x5\xEB\xE1B\n\xEB\x3\xEB\x3\xEB\x3\xEB\x5\xEB\xE20\n\xEB"+
		"\x3\xEC\x3\xEC\x3\xEC\x3\xEC\x3\xEC\x5\xEC\xE27\n\xEC\x3\xEC\x5\xEC\xE2A"+
		"\n\xEC\x3\xED\x3\xED\x3\xED\x3\xED\x3\xED\a\xED\xE31\n\xED\f\xED\xE\xED"+
		"\xE34\v\xED\x3\xED\x3\xED\x3\xED\x3\xED\x5\xED\xE3A\n\xED\x3\xEE\x3\xEE"+
		"\x3\xEE\x5\xEE\xE3F\n\xEE\x3\xEF\x3\xEF\x5\xEF\xE43\n\xEF\x3\xF0\x3\xF0"+
		"\x3\xF0\x3\xF0\x3\xF0\x3\xF0\x5\xF0\xE4B\n\xF0\x3\xF0\x3\xF0\x3\xF0\x3"+
		"\xF0\x5\xF0\xE51\n\xF0\x3\xF1\x3\xF1\x3\xF1\x3\xF1\x3\xF1\x3\xF1\x5\xF1"+
		"\xE59\n\xF1\x3\xF1\x5\xF1\xE5C\n\xF1\x3\xF2\x3\xF2\x3\xF2\x3\xF2\a\xF2"+
		"\xE62\n\xF2\f\xF2\xE\xF2\xE65\v\xF2\x3\xF2\x3\xF2\x3\xF3\x3\xF3\x3\xF3"+
		"\x5\xF3\xE6C\n\xF3\x3\xF3\x5\xF3\xE6F\n\xF3\x3\xF3\x5\xF3\xE72\n\xF3\x3"+
		"\xF4\x3\xF4\x3\xF4\x3\xF5\x3\xF5\x3\xF5\x3\xF5\x5\xF5\xE7B\n\xF5\x3\xF6"+
		"\x3\xF6\x3\xF6\x3\xF6\x5\xF6\xE81\n\xF6\x3\xF6\x3\xF6\x3\xF6\x3\xF6\x5"+
		"\xF6\xE87\n\xF6\x5\xF6\xE89\n\xF6\x3\xF7\x3\xF7\x3\xF7\x3\xF7\x3\xF7\x3"+
		"\xF7\x3\xF7\x3\xF7\x3\xF7\x3\xF7\x3\xF7\x5\xF7\xE96\n\xF7\x5\xF7\xE98"+
		"\n\xF7\x3\xF8\x3\xF8\x3\xF8\x3\xF8\x3\xF8\x3\xF8\x3\xF8\x5\xF8\xEA1\n"+
		"\xF8\x5\xF8\xEA3\n\xF8\x3\xF9\x3\xF9\x5\xF9\xEA7\n\xF9\x3\xF9\x3\xF9\x3"+
		"\xF9\x3\xF9\x5\xF9\xEAD\n\xF9\x3\xF9\x3\xF9\x5\xF9\xEB1\n\xF9\x3\xFA\x3"+
		"\xFA\x3\xFA\x3\xFA\x3\xFA\x3\xFB\x3\xFB\x3\xFB\x3\xFB\x3\xFB\x3\xFB\x3"+
		"\xFB\x3\xFB\x3\xFB\x3\xFB\x3\xFB\x3\xFB\x3\xFB\x3\xFB\x3\xFB\x3\xFB\x3"+
		"\xFB\x3\xFB\x5\xFB\xECA\n\xFB\x3\xFC\x3\xFC\x3\xFD\x3\xFD\x3\xFD\x3\xFD"+
		"\x3\xFD\a\xFD\xED3\n\xFD\f\xFD\xE\xFD\xED6\v\xFD\x3\xFD\x3\xFD\x5\xFD"+
		"\xEDA\n\xFD\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3"+
		"\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3"+
		"\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3"+
		"\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x3\xFE\x5"+
		"\xFE\xF02\n\xFE\x3\xFF\x3\xFF\x5\xFF\xF06\n\xFF\x3\xFF\x3\xFF\a\xFF\xF0A"+
		"\n\xFF\f\xFF\xE\xFF\xF0D\v\xFF\x3\xFF\x3\xFF\x3\x100\x3\x100\x3\x101\x3"+
		"\x101\x3\x102\x3\x102\x3\x102\a\x102\xF18\n\x102\f\x102\xE\x102\xF1B\v"+
		"\x102\x3\x103\x3\x103\x3\x104\x3\x104\x3\x104\a\x104\xF22\n\x104\f\x104"+
		"\xE\x104\xF25\v\x104\x3\x105\x3\x105\x3\x105\x5\x105\xF2A\n\x105\x3\x106"+
		"\x3\x106\x3\x106\x3\x106\x5\x106\xF30\n\x106\x3\x106\x3\x106\x3\x106\x3"+
		"\x106\x3\x106\x3\x106\x3\x106\x3\x106\x3\x106\x5\x106\xF3B\n\x106\x3\x106"+
		"\x3\x106\x5\x106\xF3F\n\x106\x3\x106\x3\x106\x3\x106\a\x106\xF44\n\x106"+
		"\f\x106\xE\x106\xF47\v\x106\x3\x106\x3\x106\x5\x106\xF4B\n\x106\a\x106"+
		"\xF4D\n\x106\f\x106\xE\x106\xF50\v\x106\x3\x106\x5\x106\xF53\n\x106\x3"+
		"\x107\x3\x107\x3\x107\x5\x107\xF58\n\x107\x3\x108\x3\x108\x3\x108\x3\x108"+
		"\x5\x108\xF5E\n\x108\x3\x108\x6\x108\xF61\n\x108\r\x108\xE\x108\xF62\x3"+
		"\x108\x3\x108\x5\x108\xF67\n\x108\x3\x108\x3\x108\x5\x108\xF6B\n\x108"+
		"\x3\x108\x3\x108\x5\x108\xF6F\n\x108\x5\x108\xF71\n\x108\x3\x109\x3\x109"+
		"\x3\x10A\x3\x10A\x3\x10A\x3\x10A\x3\x10A\x3\x10A\x3\x10A\x5\x10A\xF7C"+
		"\n\x10A\x3\x10A\a\x10A\xF7F\n\x10A\f\x10A\xE\x10A\xF82\v\x10A\x3\x10B"+
		"\x3\x10B\x5\x10B\xF86\n\x10B\x3\x10B\x3\x10B\x3\x10B\x3\x10B\x3\x10B\x3"+
		"\x10B\x3\x10B\x5\x10B\xF8F\n\x10B\x5\x10B\xF91\n\x10B\x5\x10B\xF93\n\x10B"+
		"\x3\x10B\x5\x10B\xF96\n\x10B\x3\x10C\x3\x10C\x3\x10D\x3\x10D\x3\x10D\x3"+
		"\x10E\x3\x10E\x3\x10E\x3\x10E\x3\x10E\x3\x10E\x3\x10E\x3\x10E\a\x10E\xFA5"+
		"\n\x10E\f\x10E\xE\x10E\xFA8\v\x10E\x3\x10E\x3\x10E\x3\x10E\x3\x10E\x3"+
		"\x10E\x5\x10E\xFAF\n\x10E\x3\x10F\x3\x10F\x3\x10F\x3\x10F\x3\x110\x3\x110"+
		"\x3\x110\x3\x110\a\x110\xFB9\n\x110\f\x110\xE\x110\xFBC\v\x110\x3\x111"+
		"\x3\x111\x3\x112\x3\x112\x3\x112\a\x112\xFC3\n\x112\f\x112\xE\x112\xFC6"+
		"\v\x112\x3\x113\x3\x113\x3\x113\a\x113\xFCB\n\x113\f\x113\xE\x113\xFCE"+
		"\v\x113\x3\x114\x3\x114\x3\x114\x3\x114\x3\x114\x3\x114\x5\x114\xFD6\n"+
		"\x114\x3\x114\x5\x114\xFD9\n\x114\x3\x115\x3\x115\x3\x115\x3\x115\x3\x115"+
		"\x5\x115\xFE0\n\x115\x3\x115\x3\x115\x3\x115\x3\x115\x3\x115\x3\x115\x5"+
		"\x115\xFE8\n\x115\x3\x115\x3\x115\x3\x115\x3\x115\x3\x115\x5\x115\xFEF"+
		"\n\x115\x3\x115\x3\x115\x5\x115\xFF3\n\x115\x3\x116\x3\x116\x3\x116\x3"+
		"\x116\x3\x116\x5\x116\xFFA\n\x116\x3\x117\x3\x117\x5\x117\xFFE\n\x117"+
		"\x3\x117\x3\x117\x3\x117\x5\x117\x1003\n\x117\a\x117\x1005\n\x117\f\x117"+
		"\xE\x117\x1008\v\x117\x3\x117\x3\x117\x3\x117\a\x117\x100D\n\x117\f\x117"+
		"\xE\x117\x1010\v\x117\x3\x117\x5\x117\x1013\n\x117\x3\x118\x3\x118\x3"+
		"\x118\x3\x118\x3\x118\x5\x118\x101A\n\x118\x3\x118\x3\x118\x3\x118\x3"+
		"\x118\x3\x118\x3\x118\x3\x118\x5\x118\x1023\n\x118\x3\x119\x3\x119\x3"+
		"\x119\x3\x11A\x3\x11A\x3\x11B\x3\x11B\x3\x11B\x3\x11B\x3\x11B\a\x11B\x102F"+
		"\n\x11B\f\x11B\xE\x11B\x1032\v\x11B\x3\x11B\x3\x11B\x3\x11B\x3\x11B\x3"+
		"\x11B\x3\x11B\x3\x11B\x3\x11B\a\x11B\x103C\n\x11B\f\x11B\xE\x11B\x103F"+
		"\v\x11B\x3\x11B\x3\x11B\x5\x11B\x1043\n\x11B\x3\x11B\x3\x11B\x3\x11C\x3"+
		"\x11C\x3\x11C\x3\x11C\x3\x11C\x3\x11C\x3\x11C\x3\x11C\x3\x11C\x3\x11C"+
		"\x3\x11C\x3\x11C\x3\x11C\x3\x11C\x3\x11C\x3\x11C\x3\x11C\x3\x11C\x5\x11C"+
		"\x1059\n\x11C\x3\x11D\x3\x11D\x5\x11D\x105D\n\x11D\x3\x11E\x5\x11E\x1060"+
		"\n\x11E\x3\x11E\x3\x11E\x3\x11E\x6\x11E\x1065\n\x11E\r\x11E\xE\x11E\x1066"+
		"\x3\x11E\x5\x11E\x106A\n\x11E\x3\x11E\x3\x11E\x5\x11E\x106E\n\x11E\x3"+
		"\x11E\x5\x11E\x1071\n\x11E\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x3\x11F\x5"+
		"\x11F\x1078\n\x11F\x3\x120\x5\x120\x107B\n\x120\x3\x120\x3\x120\x6\x120"+
		"\x107F\n\x120\r\x120\xE\x120\x1080\x3\x120\x5\x120\x1084\n\x120\x3\x120"+
		"\x3\x120\x5\x120\x1088\n\x120\x3\x120\x5\x120\x108B\n\x120\x3\x121\x3"+
		"\x121\x3\x121\x3\x121\x3\x121\x5\x121\x1092\n\x121\x3\x122\x3\x122\x3"+
		"\x122\x5\x122\x1097\n\x122\x3\x123\x3\x123\x3\x123\x3\x123\x3\x123\x3"+
		"\x123\x3\x123\x3\x123\x3\x123\x3\x123\a\x123\x10A3\n\x123\f\x123\xE\x123"+
		"\x10A6\v\x123\x3\x123\x3\x123\x3\x123\x5\x123\x10AB\n\x123\x3\x123\x5"+
		"\x123\x10AE\n\x123\x3\x124\x3\x124\x5\x124\x10B2\n\x124\x3\x125\x3\x125"+
		"\x3\x125\x3\x125\a\x125\x10B8\n\x125\f\x125\xE\x125\x10BB\v\x125\x3\x126"+
		"\x3\x126\x3\x126\x3\x126\x3\x126\x3\x126\x3\x126\x3\x126\x3\x126\a\x126"+
		"\x10C6\n\x126\f\x126\xE\x126\x10C9\v\x126\x3\x126\x3\x126\x5\x126\x10CD"+
		"\n\x126\x3\x127\x3\x127\x3\x127\x3\x127\x3\x127\a\x127\x10D4\n\x127\f"+
		"\x127\xE\x127\x10D7\v\x127\x3\x127\x3\x127\x3\x127\x3\x127\x3\x127\x3"+
		"\x127\x3\x127\a\x127\x10E0\n\x127\f\x127\xE\x127\x10E3\v\x127\x3\x127"+
		"\x3\x127\x5\x127\x10E7\n\x127\x3\x128\x3\x128\x3\x128\x3\x128\x3\x128"+
		"\x3\x128\x3\x128\x3\x128\x5\x128\x10F1\n\x128\x3\x128\x3\x128\x3\x128"+
		"\x3\x128\x3\x128\x5\x128\x10F8\n\x128\x3\x129\x3\x129\x3\x129\x3\x129"+
		"\a\x129\x10FE\n\x129\f\x129\xE\x129\x1101\v\x129\x3\x12A\x3\x12A\x3\x12A"+
		"\x3\x12A\x3\x12A\x5\x12A\x1108\n\x12A\x3\x12A\x3\x12A\x5\x12A\x110C\n"+
		"\x12A\x3\x12A\x5\x12A\x110F\n\x12A\x3\x12A\x3\x12A\x3\x12A\x5\x12A\x1114"+
		"\n\x12A\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x1119\n\x12B\x3\x12B\x3\x12B\x3"+
		"\x12B\x5\x12B\x111E\n\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x1124"+
		"\n\x12B\x3\x12B\x5\x12B\x1127\n\x12B\x3\x12B\x3\x12B\x5\x12B\x112B\n\x12B"+
		"\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B"+
		"\x3\x12B\x3\x12B\x5\x12B\x1138\n\x12B\x3\x12B\x3\x12B\x5\x12B\x113C\n"+
		"\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x6\x12B\x1143\n\x12B\r\x12B"+
		"\xE\x12B\x1144\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x114B\n\x12B\x3"+
		"\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B"+
		"\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x1159\n\x12B\x3\x12B\x3\x12B\x3\x12B"+
		"\x3\x12B\x3\x12B\x3\x12B\x3\x12B\a\x12B\x1162\n\x12B\f\x12B\xE\x12B\x1165"+
		"\v\x12B\x3\x12B\x5\x12B\x1168\n\x12B\x3\x12B\x5\x12B\x116B\n\x12B\x3\x12B"+
		"\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B"+
		"\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x117B\n\x12B\x3\x12B\x3\x12B"+
		"\a\x12B\x117F\n\x12B\f\x12B\xE\x12B\x1182\v\x12B\x3\x12B\x3\x12B\x3\x12B"+
		"\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x118B\n\x12B\x3\x12B\x3\x12B"+
		"\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x1193\n\x12B\x3\x12B\x5\x12B"+
		"\x1196\n\x12B\x3\x12B\x5\x12B\x1199\n\x12B\x3\x12B\x3\x12B\x3\x12B\x3"+
		"\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x11A2\n\x12B\x3\x12B\x3\x12B\x3"+
		"\x12B\x5\x12B\x11A7\n\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\a\x12B"+
		"\x11AE\n\x12B\f\x12B\xE\x12B\x11B1\v\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B"+
		"\x11B6\n\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x11BB\n\x12B\x3\x12B\x5"+
		"\x12B\x11BE\n\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x11C3\n\x12B\x3\x12B"+
		"\x3\x12B\x3\x12B\x5\x12B\x11C8\n\x12B\a\x12B\x11CA\n\x12B\f\x12B\xE\x12B"+
		"\x11CD\v\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x11D2\n\x12B\x3\x12B\x3"+
		"\x12B\x3\x12B\x3\x12B\x5\x12B\x11D8\n\x12B\x3\x12B\x3\x12B\x3\x12B\x3"+
		"\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x11E1\n\x12B\x3\x12B\x3\x12B\x3"+
		"\x12B\x5\x12B\x11E6\n\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3"+
		"\x12B\x5\x12B\x11EE\n\x12B\x3\x12B\x3\x12B\x5\x12B\x11F2\n\x12B\x3\x12B"+
		"\x3\x12B\x3\x12B\x5\x12B\x11F7\n\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B"+
		"\x5\x12B\x11FD\n\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B"+
		"\x1204\n\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x1209\n\x12B\x3\x12B\x3"+
		"\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x1210\n\x12B\x3\x12B\x3\x12B\x5"+
		"\x12B\x1214\n\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x1219\n\x12B\x3\x12B"+
		"\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x3\x12B\x5\x12B\x1221\n\x12B\x3\x12B"+
		"\x5\x12B\x1224\n\x12B\x3\x12B\x5\x12B\x1227\n\x12B\x3\x12B\x5\x12B\x122A"+
		"\n\x12B\x3\x12B\x3\x12B\x5\x12B\x122E\n\x12B\x3\x12B\x3\x12B\x3\x12B\x5"+
		"\x12B\x1233\n\x12B\x3\x12B\x5\x12B\x1236\n\x12B\x3\x12C\x3\x12C\x3\x12D"+
		"\x3\x12D\x3\x12E\x3\x12E\x3\x12F\x3\x12F\x3\x12F\x5\x12F\x1241\n\x12F"+
		"\x3\x12F\x3\x12F\x5\x12F\x1245\n\x12F\x5\x12F\x1247\n\x12F\x3\x12F\x3"+
		"\x12F\x3\x130\x3\x130\x3\x130\x3\x130\x3\x130\x3\x130\x3\x130\x5\x130"+
		"\x1252\n\x130\x3\x131\x3\x131\x3\x132\x3\x132\x3\x132\x3\x132\x3\x132"+
		"\x3\x132\x3\x132\x5\x132\x125D\n\x132\x3\x133\x3\x133\x3\x133\x3\x133"+
		"\x3\x133\a\x133\x1264\n\x133\f\x133\xE\x133\x1267\v\x133\x5\x133\x1269"+
		"\n\x133\x3\x134\x3\x134\x5\x134\x126D\n\x134\x3\x134\x5\x134\x1270\n\x134"+
		"\x3\x134\x3\x134\x5\x134\x1274\n\x134\x3\x135\x3\x135\x3\x135\x3\x135"+
		"\x3\x136\x3\x136\x3\x136\x3\x136\x3\x136\x3\x136\x3\x136\x5\x136\x1281"+
		"\n\x136\x3\x137\x3\x137\x3\x137\x5\x137\x1286\n\x137\x3\x137\x3\x137\x3"+
		"\x137\x3\x137\a\x137\x128C\n\x137\f\x137\xE\x137\x128F\v\x137\x3\x137"+
		"\x3\x137\x3\x137\x3\x137\x5\x137\x1295\n\x137\x3\x138\x3\x138\x3\x138"+
		"\x5\x138\x129A\n\x138\x3\x138\x3\x138\x5\x138\x129E\n\x138\x3\x138\x3"+
		"\x138\x3\x138\x5\x138\x12A3\n\x138\a\x138\x12A5\n\x138\f\x138\xE\x138"+
		"\x12A8\v\x138\x3\x139\x3\x139\x3\x139\x5\x139\x12AD\n\x139\x3\x139\x5"+
		"\x139\x12B0\n\x139\x3\x139\x3\x139\x3\x139\a\x139\x12B5\n\x139\f\x139"+
		"\xE\x139\x12B8\v\x139\x3\x139\x3\x139\x3\x13A\x3\x13A\x3\x13A\x3\x13A"+
		"\x3\x13A\x3\x13A\x3\x13A\x3\x13A\a\x13A\x12C4\n\x13A\f\x13A\xE\x13A\x12C7"+
		"\v\x13A\x5\x13A\x12C9\n\x13A\x3\x13A\x5\x13A\x12CC\n\x13A\x3\x13A\x3\x13A"+
		"\x3\x13B\x3\x13B\x3\x13B\x3\x13B\x3\x13B\x3\x13B\x5\x13B\x12D6\n\x13B"+
		"\x3\x13B\x5\x13B\x12D9\n\x13B\x5\x13B\x12DB\n\x13B\x3\x13C\x3\x13C\x3"+
		"\x13C\x3\x13D\x3\x13D\x5\x13D\x12E2\n\x13D\x3\x13D\x3\x13D\x3\x13D\x5"+
		"\x13D\x12E7\n\x13D\x5\x13D\x12E9\n\x13D\x3\x13E\x3\x13E\x3\x13E\x3\x13E"+
		"\x5\x13E\x12EF\n\x13E\x3\x13F\x3\x13F\x3\x13F\x3\x13F\x5\x13F\x12F5\n"+
		"\x13F\x5\x13F\x12F7\n\x13F\x3\x140\x3\x140\x3\x140\x3\x141\x3\x141\x3"+
		"\x141\x3\x142\x3\x142\x3\x142\x3\x142\x3\x142\x3\x142\x5\x142\x1305\n"+
		"\x142\x5\x142\x1307\n\x142\x3\x143\x3\x143\x3\x144\x6\x144\x130C\n\x144"+
		"\r\x144\xE\x144\x130D\x3\x144\x3\x144\x5\x144\x1312\n\x144\x3\x145\x3"+
		"\x145\x3\x145\x3\x145\x3\x145\x3\x145\x3\x145\x3\x145\x3\x145\a\x145\x131D"+
		"\n\x145\f\x145\xE\x145\x1320\v\x145\x3\x145\x3\x145\x5\x145\x1324\n\x145"+
		"\x3\x145\x3\x145\x3\x146\x3\x146\x5\x146\x132A\n\x146\x3\x146\x3\x146"+
		"\x3\x147\x5\x147\x132F\n\x147\x3\x147\x3\x147\x5\x147\x1333\n\x147\x3"+
		"\x148\x3\x148\x5\x148\x1337\n\x148\x3\x149\x3\x149\x3\x14A\x3\x14A\x3"+
		"\x14A\x5\x14A\x133E\n\x14A\x3\x14B\x3\x14B\x3\x14B\x3\x14B\x3\x14C\x3"+
		"\x14C\x5\x14C\x1346\n\x14C\x3\x14D\x3\x14D\x3\x14D\x3\x14D\a\x14D\x134C"+
		"\n\x14D\f\x14D\xE\x14D\x134F\v\x14D\x3\x14D\x3\x14D\x3\x14D\x3\x14D\x3"+
		"\x14D\x3\x14D\a\x14D\x1357\n\x14D\f\x14D\xE\x14D\x135A\v\x14D\x5\x14D"+
		"\x135C\n\x14D\x3\x14E\x3\x14E\x5\x14E\x1360\n\x14E\x3\x14F\x3\x14F\x3"+
		"\x150\x3\x150\x3\x151\x3\x151\x3\x152\x3\x152\x3\x153\x3\x153\x3\x154"+
		"\x3\x154\x3\x155\x3\x155\x3\x155\a\x155\x1371\n\x155\f\x155\xE\x155\x1374"+
		"\v\x155\x3\x155\x3\x155\x5\x155\x1378\n\x155\x3\x156\x3\x156\x3\x156\x5"+
		"\x156\x137D\n\x156\x3\x156\x3\x156\x3\x157\x3\x157\x3\x157\x5\x157\x1384"+
		"\n\x157\x3\x158\x3\x158\x3\x159\x3\x159\x3\x15A\x3\x15A\x3\x15B\x3\x15B"+
		"\x3\x15B\a\x15B\x138F\n\x15B\f\x15B\xE\x15B\x1392\v\x15B\x3\x15C\x3\x15C"+
		"\x3\x15D\x3\x15D\x3\x15D\a\x15D\x1399\n\x15D\f\x15D\xE\x15D\x139C\v\x15D"+
		"\x3\x15D\x3\x15D\x5\x15D\x13A0\n\x15D\x3\x15E\x3\x15E\x3\x15F\x3\x15F"+
		"\x3\x15F\a\x15F\x13A7\n\x15F\f\x15F\xE\x15F\x13AA\v\x15F\x3\x160\x3\x160"+
		"\x3\x160\a\x160\x13AF\n\x160\f\x160\xE\x160\x13B2\v\x160\x3\x161\x3\x161"+
		"\x3\x161\a\x161\x13B7\n\x161\f\x161\xE\x161\x13BA\v\x161\x3\x162\x3\x162"+
		"\x3\x162\x5\x162\x13BF\n\x162\x3\x163\x3\x163\x3\x163\x5\x163\x13C4\n"+
		"\x163\x3\x164\x3\x164\x3\x164\x5\x164\x13C9\n\x164\x3\x165\x3\x165\x5"+
		"\x165\x13CD\n\x165\x3\x165\x3\x165\x3\x165\x5\x165\x13D2\n\x165\x3\x165"+
		"\x5\x165\x13D5\n\x165\x3\x166\x3\x166\x3\x167\x3\x167\x5\x167\x13DB\n"+
		"\x167\x3\x168\x3\x168\x5\x168\x13DF\n\x168\x3\x169\x3\x169\x3\x169\x5"+
		"\x169\x13E4\n\x169\x3\x16A\x3\x16A\x3\x16A\a\x16A\x13E9\n\x16A\f\x16A"+
		"\xE\x16A\x13EC\v\x16A\x3\x16B\x3\x16B\x3\x16B\a\x16B\x13F1\n\x16B\f\x16B"+
		"\xE\x16B\x13F4\v\x16B\x3\x16C\x3\x16C\x3\x16C\x5\x16C\x13F9\n\x16C\x3"+
		"\x16C\x3\x16C\x3\x16C\x5\x16C\x13FE\n\x16C\x3\x16D\x3\x16D\x3\x16D\a\x16D"+
		"\x1403\n\x16D\f\x16D\xE\x16D\x1406\v\x16D\x3\x16E\x3\x16E\x3\x16E\x3\x16E"+
		"\x3\x16E\x3\x16E\x3\x16E\x5\x16E\x140F\n\x16E\x3\x16F\x3\x16F\x5\x16F"+
		"\x1413\n\x16F\x3\x16F\x3\x16F\a\x16F\x1417\n\x16F\f\x16F\xE\x16F\x141A"+
		"\v\x16F\x3\x16F\x3\x16F\x5\x16F\x141E\n\x16F\x3\x170\x3\x170\x3\x170\x5"+
		"\x170\x1423\n\x170\x5\x170\x1425\n\x170\x3\x170\x3\x170\x3\x170\x5\x170"+
		"\x142A\n\x170\a\x170\x142C\n\x170\f\x170\xE\x170\x142F\v\x170\x3\x170"+
		"\x3\x170\x5\x170\x1433\n\x170\x3\x171\x3\x171\x3\x171\x3\x171\x3\x171"+
		"\x5\x171\x143A\n\x171\x3\x171\x3\x171\x3\x171\x5\x171\x143F\n\x171\x5"+
		"\x171\x1441\n\x171\x5\x171\x1443\n\x171\x3\x171\x3\x171\x3\x171\x3\x171"+
		"\x3\x171\x3\x171\x3\x171\x3\x171\x5\x171\x144D\n\x171\x3\x171\x3\x171"+
		"\x3\x171\x5\x171\x1452\n\x171\a\x171\x1454\n\x171\f\x171\xE\x171\x1457"+
		"\v\x171\x5\x171\x1459\n\x171\x3\x171\x3\x171\x5\x171\x145D\n\x171\x3\x172"+
		"\x3\x172\x3\x172\x3\x173\x3\x173\x3\x173\x5\x173\x1465\n\x173\x3\x173"+
		"\x3\x173\x3\x174\x3\x174\x5\x174\x146B\n\x174\x3\x174\x3\x174\x3\x174"+
		"\x5\x174\x1470\n\x174\x3\x174\x5\x174\x1473\n\x174\x5\x174\x1475\n\x174"+
		"\x3\x175\x3\x175\x5\x175\x1479\n\x175\x3\x175\x3\x175\x5\x175\x147D\n"+
		"\x175\x3\x175\x3\x175\x5\x175\x1481\n\x175\x3\x175\x3\x175\x3\x175\x3"+
		"\x175\x3\x175\x3\x175\x5\x175\x1489\n\x175\x3\x175\x3\x175\x3\x175\x3"+
		"\x175\x3\x175\x3\x175\x5\x175\x1491\n\x175\x5\x175\x1493\n\x175\x3\x176"+
		"\x3\x176\x3\x176\x3\x176\x5\x176\x1499\n\x176\x3\x176\x5\x176\x149C\n"+
		"\x176\x3\x176\x3\x176\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177"+
		"\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177"+
		"\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x5\x177\x14B4\n\x177\x3\x177"+
		"\x3\x177\x3\x177\x3\x177\x3\x177\x5\x177\x14BB\n\x177\x3\x177\x3\x177"+
		"\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177"+
		"\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177"+
		"\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177\x3\x177"+
		"\x3\x177\x3\x177\x5\x177\x14DC\n\x177\x3\x178\x3\x178\x3\x178\x5\x178"+
		"\x14E1\n\x178\x3\x178\x5\x178\x14E4\n\x178\x3\x178\x3\x178\x3\x178\x5"+
		"\x178\x14E9\n\x178\x5\x178\x14EB\n\x178\x3\x178\x3\x178\a\x178\x14EF\n"+
		"\x178\f\x178\xE\x178\x14F2\v\x178\x3\x179\x3\x179\x3\x179\a\x179\x14F7"+
		"\n\x179\f\x179\xE\x179\x14FA\v\x179\x3\x17A\x3\x17A\x5\x17A\x14FE\n\x17A"+
		"\x3\x17A\x3\x17A\x3\x17A\a\x17A\x1503\n\x17A\f\x17A\xE\x17A\x1506\v\x17A"+
		"\x3\x17A\x5\x17A\x1509\n\x17A\x3\x17B\x3\x17B\x5\x17B\x150D\n\x17B\x3"+
		"\x17B\x3\x17B\x3\x17B\a\x17B\x1512\n\x17B\f\x17B\xE\x17B\x1515\v\x17B"+
		"\x3\x17C\x3\x17C\x3\x17C\x5\x17C\x151A\n\x17C\x3\x17C\x3\x17C\x3\x17C"+
		"\x3\x17C\x5\x17C\x1520\n\x17C\x3\x17C\x3\x17C\x3\x17C\x3\x17C\x5\x17C"+
		"\x1526\n\x17C\x3\x17C\x3\x17C\x3\x17C\x3\x17C\x5\x17C\x152C\n\x17C\x3"+
		"\x17C\x3\x17C\x3\x17C\x5\x17C\x1531\n\x17C\x5\x17C\x1533\n\x17C\x3\x17C"+
		"\x5\x17C\x1536\n\x17C\x3\x17C\x3\x17C\x3\x17C\x3\x17C\x3\x17C\x3\x17C"+
		"\x3\x17C\x3\x17C\x5\x17C\x1540\n\x17C\x3\x17C\x5\x17C\x1543\n\x17C\x5"+
		"\x17C\x1545\n\x17C\x5\x17C\x1547\n\x17C\x3\x17C\x3\x17C\x3\x17C\x3\x17C"+
		"\x3\x17C\x3\x17C\x3\x17C\x3\x17C\x3\x17C\x3\x17C\x3\x17C\x3\x17C\x5\x17C"+
		"\x1555\n\x17C\x3\x17D\x3\x17D\x3\x17E\x3\x17E\x3\x17F\x3\x17F\x5\x17F"+
		"\x155D\n\x17F\x3\x17F\x3\x17F\x3\x180\x3\x180\x5\x180\x1563\n\x180\x3"+
		"\x181\x3\x181\x3\x181\x3\x181\x3\x181\x3\x181\x3\x181\x5\x181\x156C\n"+
		"\x181\x3\x182\x3\x182\x3\x182\x5\x182\x1571\n\x182\x3\x183\x3\x183\x3"+
		"\x183\x5\x183\x1576\n\x183\x3\x184\x3\x184\x3\x184\x5\x184\x157B\n\x184"+
		"\x3\x185\x3\x185\x3\x185\x3\x185\x3\x186\x3\x186\x3\x186\x2\x2\x2\x187"+
		"\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18"+
		"\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2&\x2(\x2*\x2,\x2.\x2\x30\x2\x32\x2"+
		"\x34\x2\x36\x2\x38\x2:\x2<\x2>\x2@\x2\x42\x2\x44\x2\x46\x2H\x2J\x2L\x2"+
		"N\x2P\x2R\x2T\x2V\x2X\x2Z\x2\\\x2^\x2`\x2\x62\x2\x64\x2\x66\x2h\x2j\x2"+
		"l\x2n\x2p\x2r\x2t\x2v\x2x\x2z\x2|\x2~\x2\x80\x2\x82\x2\x84\x2\x86\x2\x88"+
		"\x2\x8A\x2\x8C\x2\x8E\x2\x90\x2\x92\x2\x94\x2\x96\x2\x98\x2\x9A\x2\x9C"+
		"\x2\x9E\x2\xA0\x2\xA2\x2\xA4\x2\xA6\x2\xA8\x2\xAA\x2\xAC\x2\xAE\x2\xB0"+
		"\x2\xB2\x2\xB4\x2\xB6\x2\xB8\x2\xBA\x2\xBC\x2\xBE\x2\xC0\x2\xC2\x2\xC4"+
		"\x2\xC6\x2\xC8\x2\xCA\x2\xCC\x2\xCE\x2\xD0\x2\xD2\x2\xD4\x2\xD6\x2\xD8"+
		"\x2\xDA\x2\xDC\x2\xDE\x2\xE0\x2\xE2\x2\xE4\x2\xE6\x2\xE8\x2\xEA\x2\xEC"+
		"\x2\xEE\x2\xF0\x2\xF2\x2\xF4\x2\xF6\x2\xF8\x2\xFA\x2\xFC\x2\xFE\x2\x100"+
		"\x2\x102\x2\x104\x2\x106\x2\x108\x2\x10A\x2\x10C\x2\x10E\x2\x110\x2\x112"+
		"\x2\x114\x2\x116\x2\x118\x2\x11A\x2\x11C\x2\x11E\x2\x120\x2\x122\x2\x124"+
		"\x2\x126\x2\x128\x2\x12A\x2\x12C\x2\x12E\x2\x130\x2\x132\x2\x134\x2\x136"+
		"\x2\x138\x2\x13A\x2\x13C\x2\x13E\x2\x140\x2\x142\x2\x144\x2\x146\x2\x148"+
		"\x2\x14A\x2\x14C\x2\x14E\x2\x150\x2\x152\x2\x154\x2\x156\x2\x158\x2\x15A"+
		"\x2\x15C\x2\x15E\x2\x160\x2\x162\x2\x164\x2\x166\x2\x168\x2\x16A\x2\x16C"+
		"\x2\x16E\x2\x170\x2\x172\x2\x174\x2\x176\x2\x178\x2\x17A\x2\x17C\x2\x17E"+
		"\x2\x180\x2\x182\x2\x184\x2\x186\x2\x188\x2\x18A\x2\x18C\x2\x18E\x2\x190"+
		"\x2\x192\x2\x194\x2\x196\x2\x198\x2\x19A\x2\x19C\x2\x19E\x2\x1A0\x2\x1A2"+
		"\x2\x1A4\x2\x1A6\x2\x1A8\x2\x1AA\x2\x1AC\x2\x1AE\x2\x1B0\x2\x1B2\x2\x1B4"+
		"\x2\x1B6\x2\x1B8\x2\x1BA\x2\x1BC\x2\x1BE\x2\x1C0\x2\x1C2\x2\x1C4\x2\x1C6"+
		"\x2\x1C8\x2\x1CA\x2\x1CC\x2\x1CE\x2\x1D0\x2\x1D2\x2\x1D4\x2\x1D6\x2\x1D8"+
		"\x2\x1DA\x2\x1DC\x2\x1DE\x2\x1E0\x2\x1E2\x2\x1E4\x2\x1E6\x2\x1E8\x2\x1EA"+
		"\x2\x1EC\x2\x1EE\x2\x1F0\x2\x1F2\x2\x1F4\x2\x1F6\x2\x1F8\x2\x1FA\x2\x1FC"+
		"\x2\x1FE\x2\x200\x2\x202\x2\x204\x2\x206\x2\x208\x2\x20A\x2\x20C\x2\x20E"+
		"\x2\x210\x2\x212\x2\x214\x2\x216\x2\x218\x2\x21A\x2\x21C\x2\x21E\x2\x220"+
		"\x2\x222\x2\x224\x2\x226\x2\x228\x2\x22A\x2\x22C\x2\x22E\x2\x230\x2\x232"+
		"\x2\x234\x2\x236\x2\x238\x2\x23A\x2\x23C\x2\x23E\x2\x240\x2\x242\x2\x244"+
		"\x2\x246\x2\x248\x2\x24A\x2\x24C\x2\x24E\x2\x250\x2\x252\x2\x254\x2\x256"+
		"\x2\x258\x2\x25A\x2\x25C\x2\x25E\x2\x260\x2\x262\x2\x264\x2\x266\x2\x268"+
		"\x2\x26A\x2\x26C\x2\x26E\x2\x270\x2\x272\x2\x274\x2\x276\x2\x278\x2\x27A"+
		"\x2\x27C\x2\x27E\x2\x280\x2\x282\x2\x284\x2\x286\x2\x288\x2\x28A\x2\x28C"+
		"\x2\x28E\x2\x290\x2\x292\x2\x294\x2\x296\x2\x298\x2\x29A\x2\x29C\x2\x29E"+
		"\x2\x2A0\x2\x2A2\x2\x2A4\x2\x2A6\x2\x2A8\x2\x2AA\x2\x2AC\x2\x2AE\x2\x2B0"+
		"\x2\x2B2\x2\x2B4\x2\x2B6\x2\x2B8\x2\x2BA\x2\x2BC\x2\x2BE\x2\x2C0\x2\x2C2"+
		"\x2\x2C4\x2\x2C6\x2\x2C8\x2\x2CA\x2\x2CC\x2\x2CE\x2\x2D0\x2\x2D2\x2\x2D4"+
		"\x2\x2D6\x2\x2D8\x2\x2DA\x2\x2DC\x2\x2DE\x2\x2E0\x2\x2E2\x2\x2E4\x2\x2E6"+
		"\x2\x2E8\x2\x2EA\x2\x2EC\x2\x2EE\x2\x2F0\x2\x2F2\x2\x2F4\x2\x2F6\x2\x2F8"+
		"\x2\x2FA\x2\x2FC\x2\x2FE\x2\x300\x2\x302\x2\x304\x2\x306\x2\x308\x2\x30A"+
		"\x2\x2O\x3\x2\x20A\x20A\x4\x3\x20A\x20A\x219\x219\x4\x2\x15\x15\xC4\xC4"+
		"\x4\x2\xA7\xA7\x139\x139\x4\x2??\x117\x117\x5\x2**\x11E\x11E\x176\x176"+
		"\x4\x2tt\x80\x80\x4\x2\f\f!!\x5\x2oo\xBB\xBB\x1A7\x1A7\x5\x2\xF8\xF8\x110"+
		"\x110\x121\x121\x4\x2\x9F\x9F\x1AD\x1AD\x4\x2**\x176\x176\x4\x2\v\vyy"+
		"\x5\x2\v\vyy\xEC\xEC\x5\x2\\\\\x116\x116\x177\x177\x4\x2\xDF\xDF\x117"+
		"\x117\x4\x2\xE3\xE3\x17F\x17F\x5\x2\x97\x97\xBC\xBC\x11D\x11D\x4\x2ZZ"+
		"nn\x6\x2\xAE\xAE\xBA\xBA\xFD\xFD\x11A\x11A\x4\x2kk\x207\x207\x3\x2\x149"+
		"\x14A\x4\x2\x112\x112\x1C1\x1C1\x3\x2KL\x4\x2mm\xAD\xAD\x4\x2\x106\x106"+
		"\x1B7\x1B7\x4\x2  \xAD\xAD\x4\x2--pp\x5\x2\xF\xFvv\x1A3\x1A3\x4\x2WW\xF1"+
		"\xF1\x5\x2\xA1\xA1\xCE\xCE\x14E\x14E\x4\x2\x15A\x15A\x18C\x18C\x5\x2\x15A"+
		"\x15A\x174\x174\x18C\x18C\x4\x2\x8B\x8B\xAF\xAF\x4\x2XX\x150\x150\x4\x2"+
		"\xAC\xAC\xC9\xC9\x4\x2\xF\xF\x1A8\x1A8\x4\x2\x1E\x1E\x162\x162\x4\x2\x16"+
		"\x16qq\x4\x2\x98\x98\xCB\xCB\x4\x2\xF\xF\x98\x98\x3\x2\x188\x189\x5\x2"+
		"\x86\x86\xC0\xC0\x1A2\x1A2\x4\x2\xF\xFvv\x4\x2\xE3\xE3\x182\x182\x3\x2"+
		"\xD1\xD4\x3\x2\x202\x203\x5\x2\xE9\xE9\x201\x201\x205\x205\x4\x2jj\xB1"+
		"\xB1\x6\x2\xF\xF\x13\x13\x8E\x8E\x175\x175\x4\x2\x37\x37\x1C5\x1C5\x4"+
		"\x2vv\x1A3\x1A3\x4\x2\x34\x34\x45\x45\x4\x2\x99\x99\xCC\xCC\x4\x2\x39"+
		"\x39\xF5\xF5\x5\x2,,\xCD\xCD\x197\x197\x4\x2\x1C6\x1C6\x1C9\x1C9\x4\x2"+
		"\x83\x83\xFF\xFF\x4\x2\x87\x87\xEF\xEF\x4\x2NNww\x4\x2\xA9\xA9\x16B\x16B"+
		"\x3\x2\x1E2\x1F1\x3\x2\x1DB\x1E1\x3\x2\x1D5\x1DA\x4\x2\x139\x139\x153"+
		"\x153\x4\x2\x9B\x9B\x133\x133\x4\x2\x104\x104\x159\x159\x4\x2\x122\x122"+
		"\x183\x183\x4\x2\xAC\xAC\x145\x145\x3\x2\x126\x127\x4\x2\x61\x61\x1D1"+
		"\x1D1\x4\x2\xED\xED\x15C\x15C\x4\x2\x30\x30\x38\x38\x6\x2\x61\x61\xAA"+
		"\xAA\xE6\xE6\x15C\x15C\x3\x2\x1F8\x1F9\x4\x2\x1F3\x1F3\x1FA\x1FA\v\x2"+
		"\n\x17\x19\x91\x93\xE8\xEA\xF8\xFA\x124\x12B\x12B\x12D\x195\x197\x1F1"+
		"\x278\x278\x17FD\x2\x30D\x3\x2\x2\x2\x4\x314\x3\x2\x2\x2\x6\x327\x3\x2"+
		"\x2\x2\b\x344\x3\x2\x2\x2\n\x346\x3\x2\x2\x2\f\x34D\x3\x2\x2\x2\xE\x34F"+
		"\x3\x2\x2\x2\x10\x354\x3\x2\x2\x2\x12\x36C\x3\x2\x2\x2\x14\x370\x3\x2"+
		"\x2\x2\x16\x39D\x3\x2\x2\x2\x18\x3A1\x3\x2\x2\x2\x1A\x3B9\x3\x2\x2\x2"+
		"\x1C\x3BD\x3\x2\x2\x2\x1E\x3C9\x3\x2\x2\x2 \x3D7\x3\x2\x2\x2\"\x3DF\x3"+
		"\x2\x2\x2$\x3F5\x3\x2\x2\x2&\x402\x3\x2\x2\x2(\x416\x3\x2\x2\x2*\x42F"+
		"\x3\x2\x2\x2,\x43B\x3\x2\x2\x2.\x43D\x3\x2\x2\x2\x30\x442\x3\x2\x2\x2"+
		"\x32\x45A\x3\x2\x2\x2\x34\x45E\x3\x2\x2\x2\x36\x480\x3\x2\x2\x2\x38\x485"+
		"\x3\x2\x2\x2:\x49E\x3\x2\x2\x2<\x4B6\x3\x2\x2\x2>\x4BF\x3\x2\x2\x2@\x4C8"+
		"\x3\x2\x2\x2\x42\x4D1\x3\x2\x2\x2\x44\x4D5\x3\x2\x2\x2\x46\x4DA\x3\x2"+
		"\x2\x2H\x4F2\x3\x2\x2\x2J\x4F4\x3\x2\x2\x2L\x4F8\x3\x2\x2\x2N\x52C\x3"+
		"\x2\x2\x2P\x548\x3\x2\x2\x2R\x54A\x3\x2\x2\x2T\x558\x3\x2\x2\x2V\x564"+
		"\x3\x2\x2\x2X\x569\x3\x2\x2\x2Z\x56F\x3\x2\x2\x2\\\x572\x3\x2\x2\x2^\x57D"+
		"\x3\x2\x2\x2`\x58C\x3\x2\x2\x2\x62\x59D\x3\x2\x2\x2\x64\x5AE\x3\x2\x2"+
		"\x2\x66\x5B6\x3\x2\x2\x2h\x5BB\x3\x2\x2\x2j\x5CB\x3\x2\x2\x2l\x5CF\x3"+
		"\x2\x2\x2n\x5E7\x3\x2\x2\x2p\x5EA\x3\x2\x2\x2r\x5F0\x3\x2\x2\x2t\x5FC"+
		"\x3\x2\x2\x2v\x605\x3\x2\x2\x2x\x621\x3\x2\x2\x2z\x627\x3\x2\x2\x2|\x62A"+
		"\x3\x2\x2\x2~\x631\x3\x2\x2\x2\x80\x639\x3\x2\x2\x2\x82\x645\x3\x2\x2"+
		"\x2\x84\x647\x3\x2\x2\x2\x86\x64B\x3\x2\x2\x2\x88\x651\x3\x2\x2\x2\x8A"+
		"\x66A\x3\x2\x2\x2\x8C\x689\x3\x2\x2\x2\x8E\x6B6\x3\x2\x2\x2\x90\x6C0\x3"+
		"\x2\x2\x2\x92\x6C2\x3\x2\x2\x2\x94\x6C7\x3\x2\x2\x2\x96\x6D5\x3\x2\x2"+
		"\x2\x98\x6D7\x3\x2\x2\x2\x9A\x6DC\x3\x2\x2\x2\x9C\x6ED\x3\x2\x2\x2\x9E"+
		"\x70F\x3\x2\x2\x2\xA0\x733\x3\x2\x2\x2\xA2\x737\x3\x2\x2\x2\xA4\x746\x3"+
		"\x2\x2\x2\xA6\x748\x3\x2\x2\x2\xA8\x74B\x3\x2\x2\x2\xAA\x750\x3\x2\x2"+
		"\x2\xAC\x75A\x3\x2\x2\x2\xAE\x776\x3\x2\x2\x2\xB0\x778\x3\x2\x2\x2\xB2"+
		"\x77C\x3\x2\x2\x2\xB4\x77F\x3\x2\x2\x2\xB6\x783\x3\x2\x2\x2\xB8\x788\x3"+
		"\x2\x2\x2\xBA\x78C\x3\x2\x2\x2\xBC\x79D\x3\x2\x2\x2\xBE\x7AA\x3\x2\x2"+
		"\x2\xC0\x7BB\x3\x2\x2\x2\xC2\x7C8\x3\x2\x2\x2\xC4\x7D5\x3\x2\x2\x2\xC6"+
		"\x7D7\x3\x2\x2\x2\xC8\x7E5\x3\x2\x2\x2\xCA\x7F6\x3\x2\x2\x2\xCC\x80F\x3"+
		"\x2\x2\x2\xCE\x819\x3\x2\x2\x2\xD0\x81D\x3\x2\x2\x2\xD2\x845\x3\x2\x2"+
		"\x2\xD4\x847\x3\x2\x2\x2\xD6\x860\x3\x2\x2\x2\xD8\x86B\x3\x2\x2\x2\xDA"+
		"\x87C\x3\x2\x2\x2\xDC\x880\x3\x2\x2\x2\xDE\x892\x3\x2\x2\x2\xE0\x89A\x3"+
		"\x2\x2\x2\xE2\x8A5\x3\x2\x2\x2\xE4\x8AD\x3\x2\x2\x2\xE6\x8B1\x3\x2\x2"+
		"\x2\xE8\x8D2\x3\x2\x2\x2\xEA\x8D7\x3\x2\x2\x2\xEC\x8DC\x3\x2\x2\x2\xEE"+
		"\x8E4\x3\x2\x2\x2\xF0\x8EC\x3\x2\x2\x2\xF2\x8EF\x3\x2\x2\x2\xF4\x8FF\x3"+
		"\x2\x2\x2\xF6\x904\x3\x2\x2\x2\xF8\x908\x3\x2\x2\x2\xFA\x92C\x3\x2\x2"+
		"\x2\xFC\x92E\x3\x2\x2\x2\xFE\x944\x3\x2\x2\x2\x100\x946\x3\x2\x2\x2\x102"+
		"\x94B\x3\x2\x2\x2\x104\x94D\x3\x2\x2\x2\x106\x94F\x3\x2\x2\x2\x108\x951"+
		"\x3\x2\x2\x2\x10A\x955\x3\x2\x2\x2\x10C\x95A\x3\x2\x2\x2\x10E\x960\x3"+
		"\x2\x2\x2\x110\x98F\x3\x2\x2\x2\x112\x991\x3\x2\x2\x2\x114\x997\x3\x2"+
		"\x2\x2\x116\x99D\x3\x2\x2\x2\x118\x9AA\x3\x2\x2\x2\x11A\x9AF\x3\x2\x2"+
		"\x2\x11C\x9B7\x3\x2\x2\x2\x11E\x9B9\x3\x2\x2\x2\x120\x9C7\x3\x2\x2\x2"+
		"\x122\x9D1\x3\x2\x2\x2\x124\x9D7\x3\x2\x2\x2\x126\x9D9\x3\x2\x2\x2\x128"+
		"\x9DC\x3\x2\x2\x2\x12A\x9E1\x3\x2\x2\x2\x12C\xA00\x3\x2\x2\x2\x12E\xA0F"+
		"\x3\x2\x2\x2\x130\xA11\x3\x2\x2\x2\x132\xA26\x3\x2\x2\x2\x134\xA35\x3"+
		"\x2\x2\x2\x136\xA4B\x3\x2\x2\x2\x138\xA52\x3\x2\x2\x2\x13A\xA5F\x3\x2"+
		"\x2\x2\x13C\xA62\x3\x2\x2\x2\x13E\xA76\x3\x2\x2\x2\x140\xA7E\x3\x2\x2"+
		"\x2\x142\xA87\x3\x2\x2\x2\x144\xAA2\x3\x2\x2\x2\x146\xACD\x3\x2\x2\x2"+
		"\x148\xADD\x3\x2\x2\x2\x14A\xAEA\x3\x2\x2\x2\x14C\xAF3\x3\x2\x2\x2\x14E"+
		"\xAF6\x3\x2\x2\x2\x150\xB1D\x3\x2\x2\x2\x152\xB21\x3\x2\x2\x2\x154\xB29"+
		"\x3\x2\x2\x2\x156\xB2B\x3\x2\x2\x2\x158\xB33\x3\x2\x2\x2\x15A\xB5B\x3"+
		"\x2\x2\x2\x15C\xB67\x3\x2\x2\x2\x15E\xB7C\x3\x2\x2\x2\x160\xB7F\x3\x2"+
		"\x2\x2\x162\xB8B\x3\x2\x2\x2\x164\xB8F\x3\x2\x2\x2\x166\xBA8\x3\x2\x2"+
		"\x2\x168\xBAA\x3\x2\x2\x2\x16A\xBBB\x3\x2\x2\x2\x16C\xBC2\x3\x2\x2\x2"+
		"\x16E\xBD1\x3\x2\x2\x2\x170\xBE8\x3\x2\x2\x2\x172\xBEE\x3\x2\x2\x2\x174"+
		"\xBF0\x3\x2\x2\x2\x176\xC08\x3\x2\x2\x2\x178\xC20\x3\x2\x2\x2\x17A\xC44"+
		"\x3\x2\x2\x2\x17C\xC46\x3\x2\x2\x2\x17E\xC64\x3\x2\x2\x2\x180\xC69\x3"+
		"\x2\x2\x2\x182\xC6B\x3\x2\x2\x2\x184\xC77\x3\x2\x2\x2\x186\xC87\x3\x2"+
		"\x2\x2\x188\xC89\x3\x2\x2\x2\x18A\xC8C\x3\x2\x2\x2\x18C\xCA6\x3\x2\x2"+
		"\x2\x18E\xCA8\x3\x2\x2\x2\x190\xCAC\x3\x2\x2\x2\x192\xCBB\x3\x2\x2\x2"+
		"\x194\xCC7\x3\x2\x2\x2\x196\xCCF\x3\x2\x2\x2\x198\xCD3\x3\x2\x2\x2\x19A"+
		"\xCDE\x3\x2\x2\x2\x19C\xCE3\x3\x2\x2\x2\x19E\xCF0\x3\x2\x2\x2\x1A0\xD04"+
		"\x3\x2\x2\x2\x1A2\xD0D\x3\x2\x2\x2\x1A4\xD0F\x3\x2\x2\x2\x1A6\xD16\x3"+
		"\x2\x2\x2\x1A8\xD1B\x3\x2\x2\x2\x1AA\xD28\x3\x2\x2\x2\x1AC\xD30\x3\x2"+
		"\x2\x2\x1AE\xD38\x3\x2\x2\x2\x1B0\xD46\x3\x2\x2\x2\x1B2\xD48\x3\x2\x2"+
		"\x2\x1B4\xD54\x3\x2\x2\x2\x1B6\xD77\x3\x2\x2\x2\x1B8\xD79\x3\x2\x2\x2"+
		"\x1BA\xD87\x3\x2\x2\x2\x1BC\xD8C\x3\x2\x2\x2\x1BE\xD9E\x3\x2\x2\x2\x1C0"+
		"\xDA2\x3\x2\x2\x2\x1C2\xDAA\x3\x2\x2\x2\x1C4\xDB4\x3\x2\x2\x2\x1C6\xDBC"+
		"\x3\x2\x2\x2\x1C8\xDC2\x3\x2\x2\x2\x1CA\xDD1\x3\x2\x2\x2\x1CC\xDD7\x3"+
		"\x2\x2\x2\x1CE\xDF0\x3\x2\x2\x2\x1D0\xE03\x3\x2\x2\x2\x1D2\xE07\x3\x2"+
		"\x2\x2\x1D4\xE0A\x3\x2\x2\x2\x1D6\xE26\x3\x2\x2\x2\x1D8\xE2B\x3\x2\x2"+
		"\x2\x1DA\xE3E\x3\x2\x2\x2\x1DC\xE40\x3\x2\x2\x2\x1DE\xE50\x3\x2\x2\x2"+
		"\x1E0\xE58\x3\x2\x2\x2\x1E2\xE5D\x3\x2\x2\x2\x1E4\xE68\x3\x2\x2\x2\x1E6"+
		"\xE73\x3\x2\x2\x2\x1E8\xE76\x3\x2\x2\x2\x1EA\xE88\x3\x2\x2\x2\x1EC\xE8A"+
		"\x3\x2\x2\x2\x1EE\xE99\x3\x2\x2\x2\x1F0\xEA4\x3\x2\x2\x2\x1F2\xEB2\x3"+
		"\x2\x2\x2\x1F4\xEC9\x3\x2\x2\x2\x1F6\xECB\x3\x2\x2\x2\x1F8\xECD\x3\x2"+
		"\x2\x2\x1FA\xF01\x3\x2\x2\x2\x1FC\xF03\x3\x2\x2\x2\x1FE\xF10\x3\x2\x2"+
		"\x2\x200\xF12\x3\x2\x2\x2\x202\xF14\x3\x2\x2\x2\x204\xF1C\x3\x2\x2\x2"+
		"\x206\xF1E\x3\x2\x2\x2\x208\xF29\x3\x2\x2\x2\x20A\xF52\x3\x2\x2\x2\x20C"+
		"\xF57\x3\x2\x2\x2\x20E\xF70\x3\x2\x2\x2\x210\xF72\x3\x2\x2\x2\x212\xF74"+
		"\x3\x2\x2\x2\x214\xF95\x3\x2\x2\x2\x216\xF97\x3\x2\x2\x2\x218\xF99\x3"+
		"\x2\x2\x2\x21A\xFAE\x3\x2\x2\x2\x21C\xFB0\x3\x2\x2\x2\x21E\xFB4\x3\x2"+
		"\x2\x2\x220\xFBD\x3\x2\x2\x2\x222\xFBF\x3\x2\x2\x2\x224\xFC7\x3\x2\x2"+
		"\x2\x226\xFCF\x3\x2\x2\x2\x228\xFF2\x3\x2\x2\x2\x22A\xFF4\x3\x2\x2\x2"+
		"\x22C\x1012\x3\x2\x2\x2\x22E\x1014\x3\x2\x2\x2\x230\x1024\x3\x2\x2\x2"+
		"\x232\x1027\x3\x2\x2\x2\x234\x1029\x3\x2\x2\x2\x236\x1058\x3\x2\x2\x2"+
		"\x238\x105C\x3\x2\x2\x2\x23A\x105F\x3\x2\x2\x2\x23C\x1072\x3\x2\x2\x2"+
		"\x23E\x107A\x3\x2\x2\x2\x240\x108C\x3\x2\x2\x2\x242\x1093\x3\x2\x2\x2"+
		"\x244\x10AD\x3\x2\x2\x2\x246\x10AF\x3\x2\x2\x2\x248\x10B3\x3\x2\x2\x2"+
		"\x24A\x10BC\x3\x2\x2\x2\x24C\x10E6\x3\x2\x2\x2\x24E\x10F7\x3\x2\x2\x2"+
		"\x250\x10F9\x3\x2\x2\x2\x252\x1102\x3\x2\x2\x2\x254\x1235\x3\x2\x2\x2"+
		"\x256\x1237\x3\x2\x2\x2\x258\x1239\x3\x2\x2\x2\x25A\x123B\x3\x2\x2\x2"+
		"\x25C\x123D\x3\x2\x2\x2\x25E\x124A\x3\x2\x2\x2\x260\x1253\x3\x2\x2\x2"+
		"\x262\x125C\x3\x2\x2\x2\x264\x125E\x3\x2\x2\x2\x266\x126F\x3\x2\x2\x2"+
		"\x268\x1275\x3\x2\x2\x2\x26A\x1280\x3\x2\x2\x2\x26C\x1282\x3\x2\x2\x2"+
		"\x26E\x1296\x3\x2\x2\x2\x270\x12A9\x3\x2\x2\x2\x272\x12BB\x3\x2\x2\x2"+
		"\x274\x12CF\x3\x2\x2\x2\x276\x12DC\x3\x2\x2\x2\x278\x12DF\x3\x2\x2\x2"+
		"\x27A\x12EA\x3\x2\x2\x2\x27C\x12F0\x3\x2\x2\x2\x27E\x12F8\x3\x2\x2\x2"+
		"\x280\x12FB\x3\x2\x2\x2\x282\x1306\x3\x2\x2\x2\x284\x1308\x3\x2\x2\x2"+
		"\x286\x1311\x3\x2\x2\x2\x288\x1313\x3\x2\x2\x2\x28A\x1327\x3\x2\x2\x2"+
		"\x28C\x132E\x3\x2\x2\x2\x28E\x1336\x3\x2\x2\x2\x290\x1338\x3\x2\x2\x2"+
		"\x292\x133A\x3\x2\x2\x2\x294\x133F\x3\x2\x2\x2\x296\x1345\x3\x2\x2\x2"+
		"\x298\x135B\x3\x2\x2\x2\x29A\x135F\x3\x2\x2\x2\x29C\x1361\x3\x2\x2\x2"+
		"\x29E\x1363\x3\x2\x2\x2\x2A0\x1365\x3\x2\x2\x2\x2A2\x1367\x3\x2\x2\x2"+
		"\x2A4\x1369\x3\x2\x2\x2\x2A6\x136B\x3\x2\x2\x2\x2A8\x136D\x3\x2\x2\x2"+
		"\x2AA\x137C\x3\x2\x2\x2\x2AC\x1380\x3\x2\x2\x2\x2AE\x1385\x3\x2\x2\x2"+
		"\x2B0\x1387\x3\x2\x2\x2\x2B2\x1389\x3\x2\x2\x2\x2B4\x138B\x3\x2\x2\x2"+
		"\x2B6\x1393\x3\x2\x2\x2\x2B8\x1395\x3\x2\x2\x2\x2BA\x13A1\x3\x2\x2\x2"+
		"\x2BC\x13A3\x3\x2\x2\x2\x2BE\x13AB\x3\x2\x2\x2\x2C0\x13B3\x3\x2\x2\x2"+
		"\x2C2\x13BB\x3\x2\x2\x2\x2C4\x13C0\x3\x2\x2\x2\x2C6\x13C5\x3\x2\x2\x2"+
		"\x2C8\x13D4\x3\x2\x2\x2\x2CA\x13D6\x3\x2\x2\x2\x2CC\x13DA\x3\x2\x2\x2"+
		"\x2CE\x13DE\x3\x2\x2\x2\x2D0\x13E0\x3\x2\x2\x2\x2D2\x13E5\x3\x2\x2\x2"+
		"\x2D4\x13ED\x3\x2\x2\x2\x2D6\x13F5\x3\x2\x2\x2\x2D8\x13FF\x3\x2\x2\x2"+
		"\x2DA\x1407\x3\x2\x2\x2\x2DC\x1410\x3\x2\x2\x2\x2DE\x141F\x3\x2\x2\x2"+
		"\x2E0\x1434\x3\x2\x2\x2\x2E2\x145E\x3\x2\x2\x2\x2E4\x1464\x3\x2\x2\x2"+
		"\x2E6\x1474\x3\x2\x2\x2\x2E8\x1492\x3\x2\x2\x2\x2EA\x1494\x3\x2\x2\x2"+
		"\x2EC\x14DB\x3\x2\x2\x2\x2EE\x14E0\x3\x2\x2\x2\x2F0\x14F3\x3\x2\x2\x2"+
		"\x2F2\x14FD\x3\x2\x2\x2\x2F4\x150C\x3\x2\x2\x2\x2F6\x1554\x3\x2\x2\x2"+
		"\x2F8\x1556\x3\x2\x2\x2\x2FA\x1558\x3\x2\x2\x2\x2FC\x155C\x3\x2\x2\x2"+
		"\x2FE\x1562\x3\x2\x2\x2\x300\x156B\x3\x2\x2\x2\x302\x1570\x3\x2\x2\x2"+
		"\x304\x1575\x3\x2\x2\x2\x306\x157A\x3\x2\x2\x2\x308\x157C\x3\x2\x2\x2"+
		"\x30A\x1580\x3\x2\x2\x2\x30C\x30E\n\x2\x2\x2\x30D\x30C\x3\x2\x2\x2\x30E"+
		"\x30F\x3\x2\x2\x2\x30F\x30D\x3\x2\x2\x2\x30F\x310\x3\x2\x2\x2\x310\x3"+
		"\x3\x2\x2\x2\x311\x313\x5\b\x5\x2\x312\x311\x3\x2\x2\x2\x313\x316\x3\x2"+
		"\x2\x2\x314\x312\x3\x2\x2\x2\x314\x315\x3\x2\x2\x2\x315\x317\x3\x2\x2"+
		"\x2\x316\x314\x3\x2\x2\x2\x317\x318\a\x2\x2\x3\x318\x5\x3\x2\x2\x2\x319"+
		"\x31E\x5\b\x5\x2\x31A\x31B\a\x20A\x2\x2\x31B\x31D\x5\b\x5\x2\x31C\x31A"+
		"\x3\x2\x2\x2\x31D\x320\x3\x2\x2\x2\x31E\x31C\x3\x2\x2\x2\x31E\x31F\x3"+
		"\x2\x2\x2\x31F\x322\x3\x2\x2\x2\x320\x31E\x3\x2\x2\x2\x321\x323\a\x20A"+
		"\x2\x2\x322\x321\x3\x2\x2\x2\x322\x323\x3\x2\x2\x2\x323\x326\x3\x2\x2"+
		"\x2\x324\x326\x5\x288\x145\x2\x325\x319\x3\x2\x2\x2\x325\x324\x3\x2\x2"+
		"\x2\x326\x329\x3\x2\x2\x2\x327\x325\x3\x2\x2\x2\x327\x328\x3\x2\x2\x2"+
		"\x328\x32B\x3\x2\x2\x2\x329\x327\x3\x2\x2\x2\x32A\x32C\t\x3\x2\x2\x32B"+
		"\x32A\x3\x2\x2\x2\x32B\x32C\x3\x2\x2\x2\x32C\a\x3\x2\x2\x2\x32D\x345\x5"+
		"\x10\t\x2\x32E\x345\x5\"\x12\x2\x32F\x345\x5\x30\x19\x2\x330\x345\x5\xAA"+
		"V\x2\x331\x345\x5\x38\x1D\x2\x332\x345\x5^\x30\x2\x333\x345\x5\x12\n\x2"+
		"\x334\x345\x5\x32\x1A\x2\x335\x345\x5$\x13\x2\x336\x345\x5\xACW\x2\x337"+
		"\x345\x5:\x1E\x2\x338\x345\x5r:\x2\x339\x345\x5\xE\b\x2\x33A\x345\x5 "+
		"\x11\x2\x33B\x345\x5.\x18\x2\x33C\x345\x5\xA8U\x2\x33D\x345\x5\x36\x1C"+
		"\x2\x33E\x345\x5\\/\x2\x33F\x345\x5\x122\x92\x2\x340\x341\x5\x11A\x8E"+
		"\x2\x341\x342\a\x20A\x2\x2\x342\x343\a\x205\x2\x2\x343\x345\x3\x2\x2\x2"+
		"\x344\x32D\x3\x2\x2\x2\x344\x32E\x3\x2\x2\x2\x344\x32F\x3\x2\x2\x2\x344"+
		"\x330\x3\x2\x2\x2\x344\x331\x3\x2\x2\x2\x344\x332\x3\x2\x2\x2\x344\x333"+
		"\x3\x2\x2\x2\x344\x334\x3\x2\x2\x2\x344\x335\x3\x2\x2\x2\x344\x336\x3"+
		"\x2\x2\x2\x344\x337\x3\x2\x2\x2\x344\x338\x3\x2\x2\x2\x344\x339\x3\x2"+
		"\x2\x2\x344\x33A\x3\x2\x2\x2\x344\x33B\x3\x2\x2\x2\x344\x33C\x3\x2\x2"+
		"\x2\x344\x33D\x3\x2\x2\x2\x344\x33E\x3\x2\x2\x2\x344\x33F\x3\x2\x2\x2"+
		"\x344\x340\x3\x2\x2\x2\x345\t\x3\x2\x2\x2\x346\x34A\ah\x2\x2\x347\x349"+
		"\x5\xC4\x63\x2\x348\x347\x3\x2\x2\x2\x349\x34C\x3\x2\x2\x2\x34A\x348\x3"+
		"\x2\x2\x2\x34A\x34B\x3\x2\x2\x2\x34B\v\x3\x2\x2\x2\x34C\x34A\x3\x2\x2"+
		"\x2\x34D\x34E\t\x4\x2\x2\x34E\r\x3\x2\x2\x2\x34F\x350\ay\x2\x2\x350\x351"+
		"\a\xA2\x2\x2\x351\x352\x5\x2C2\x162\x2\x352\x353\a\x20A\x2\x2\x353\xF"+
		"\x3\x2\x2\x2\x354\x355\a\x10\x2\x2\x355\x356\a\xA2\x2\x2\x356\x357\x5"+
		"\x2C2\x162\x2\x357\x359\a\x46\x2\x2\x358\x35A\a\x65\x2\x2\x359\x358\x3"+
		"\x2\x2\x2\x359\x35A\x3\x2\x2\x2\x35A\x35E\x3\x2\x2\x2\x35B\x35D\x5\xB4"+
		"[\x2\x35C\x35B\x3\x2\x2\x2\x35D\x360\x3\x2\x2\x2\x35E\x35C\x3\x2\x2\x2"+
		"\x35E\x35F\x3\x2\x2\x2\x35F\x363\x3\x2\x2\x2\x360\x35E\x3\x2\x2\x2\x361"+
		"\x362\a\x14B\x2\x2\x362\x364\a\x169\x2\x2\x363\x361\x3\x2\x2\x2\x363\x364"+
		"\x3\x2\x2\x2\x364\x365\x3\x2\x2\x2\x365\x366\a\x20A\x2\x2\x366\x11\x3"+
		"\x2\x2\x2\x367\x36A\aV\x2\x2\x368\x369\a\x115\x2\x2\x369\x36B\a\x144\x2"+
		"\x2\x36A\x368\x3\x2\x2\x2\x36A\x36B\x3\x2\x2\x2\x36B\x36D\x3\x2\x2\x2"+
		"\x36C\x367\x3\x2\x2\x2\x36C\x36D\x3\x2\x2\x2\x36D\x36E\x3\x2\x2\x2\x36E"+
		"\x36F\x5\x14\v\x2\x36F\x13\x3\x2\x2\x2\x370\x371\a\xA2\x2\x2\x371\x37D"+
		"\x5\x2C2\x162\x2\x372\x373\a\x1FE\x2\x2\x373\x378\x5\xC0\x61\x2\x374\x375"+
		"\a\x204\x2\x2\x375\x377\x5\xC0\x61\x2\x376\x374\x3\x2\x2\x2\x377\x37A"+
		"\x3\x2\x2\x2\x378\x376\x3\x2\x2\x2\x378\x379\x3\x2\x2\x2\x379\x37B\x3"+
		"\x2\x2\x2\x37A\x378\x3\x2\x2\x2\x37B\x37C\a\x1FF\x2\x2\x37C\x37E\x3\x2"+
		"\x2\x2\x37D\x372\x3\x2\x2\x2\x37D\x37E\x3\x2\x2\x2\x37E\x37F\x3\x2\x2"+
		"\x2\x37F\x380\a\x149\x2\x2\x380\x38B\x5\x2E6\x174\x2\x381\x38A\x5\xB2"+
		"Z\x2\x382\x38A\x5\x16\f\x2\x383\x38A\x5\x1A\xE\x2\x384\x38A\ar\x2\x2\x385"+
		"\x38A\a\x12B\x2\x2\x386\x387\a\xE\x2\x2\x387\x388\a\x1AC\x2\x2\x388\x38A"+
		"\x5\x2AC\x157\x2\x389\x381\x3\x2\x2\x2\x389\x382\x3\x2\x2\x2\x389\x383"+
		"\x3\x2\x2\x2\x389\x384\x3\x2\x2\x2\x389\x385\x3\x2\x2\x2\x389\x386\x3"+
		"\x2\x2\x2\x38A\x38D\x3\x2\x2\x2\x38B\x389\x3\x2\x2\x2\x38B\x38C\x3\x2"+
		"\x2\x2\x38C\x399\x3\x2\x2\x2\x38D\x38B\x3\x2\x2\x2\x38E\x397\x5\f\a\x2"+
		"\x38F\x391\x5\xC4\x63\x2\x390\x38F\x3\x2\x2\x2\x391\x394\x3\x2\x2\x2\x392"+
		"\x390\x3\x2\x2\x2\x392\x393\x3\x2\x2\x2\x393\x395\x3\x2\x2\x2\x394\x392"+
		"\x3\x2\x2\x2\x395\x398\x5\x10E\x88\x2\x396\x398\x5\xB6\\\x2\x397\x392"+
		"\x3\x2\x2\x2\x397\x396\x3\x2\x2\x2\x398\x39A\x3\x2\x2\x2\x399\x38E\x3"+
		"\x2\x2\x2\x399\x39A\x3\x2\x2\x2\x39A\x39B\x3\x2\x2\x2\x39B\x39C\a\x20A"+
		"\x2\x2\x39C\x15\x3\x2\x2\x2\x39D\x39F\a\x11F\x2\x2\x39E\x3A0\x5\x18\r"+
		"\x2\x39F\x39E\x3\x2\x2\x2\x39F\x3A0\x3\x2\x2\x2\x3A0\x17\x3\x2\x2\x2\x3A1"+
		"\x3A2\a\x1FE\x2\x2\x3A2\x3A3\a\x122\x2\x2\x3A3\x3A4\x5\x202\x102\x2\x3A4"+
		"\x3B2\a/\x2\x2\x3A5\x3B3\a\x13\x2\x2\x3A6\x3A7\t\x5\x2\x2\x3A7\x3A8\a"+
		"\x1FE\x2\x2\x3A8\x3AD\x5\x2D4\x16B\x2\x3A9\x3AA\a\x204\x2\x2\x3AA\x3AC"+
		"\x5\x2D4\x16B\x2\x3AB\x3A9\x3\x2\x2\x2\x3AC\x3AF\x3\x2\x2\x2\x3AD\x3AB"+
		"\x3\x2\x2\x2\x3AD\x3AE\x3\x2\x2\x2\x3AE\x3B0\x3\x2\x2\x2\x3AF\x3AD\x3"+
		"\x2\x2\x2\x3B0\x3B1\a\x1FF\x2\x2\x3B1\x3B3\x3\x2\x2\x2\x3B2\x3A5\x3\x2"+
		"\x2\x2\x3B2\x3A6\x3\x2\x2\x2\x3B3\x3B5\x3\x2\x2\x2\x3B4\x3B6\x5\x1E\x10"+
		"\x2\x3B5\x3B4\x3\x2\x2\x2\x3B5\x3B6\x3\x2\x2\x2\x3B6\x3B7\x3\x2\x2\x2"+
		"\x3B7\x3B8\a\x1FF\x2\x2\x3B8\x19\x3\x2\x2\x2\x3B9\x3BB\a\x148\x2\x2\x3BA"+
		"\x3BC\x5\x1C\xF\x2\x3BB\x3BA\x3\x2\x2\x2\x3BB\x3BC\x3\x2\x2\x2\x3BC\x1B"+
		"\x3\x2\x2\x2\x3BD\x3BE\a\x142\x2\x2\x3BE\x3BF\a\x1FE\x2\x2\x3BF\x3C4\x5"+
		"\x2D6\x16C\x2\x3C0\x3C1\a\x204\x2\x2\x3C1\x3C3\x5\x2D6\x16C\x2\x3C2\x3C0"+
		"\x3\x2\x2\x2\x3C3\x3C6\x3\x2\x2\x2\x3C4\x3C2\x3\x2\x2\x2\x3C4\x3C5\x3"+
		"\x2\x2\x2\x3C5\x3C7\x3\x2\x2\x2\x3C6\x3C4\x3\x2\x2\x2\x3C7\x3C8\a\x1FF"+
		"\x2\x2\x3C8\x1D\x3\x2\x2\x2\x3C9\x3CA\t\x6\x2\x2\x3CA\x3CB\x5\x202\x102"+
		"\x2\x3CB\x3CC\a/\x2\x2\x3CC\x3CD\a\x1FE\x2\x2\x3CD\x3D2\x5\x2D4\x16B\x2"+
		"\x3CE\x3CF\a\x204\x2\x2\x3CF\x3D1\x5\x2D4\x16B\x2\x3D0\x3CE\x3\x2\x2\x2"+
		"\x3D1\x3D4\x3\x2\x2\x2\x3D2\x3D0\x3\x2\x2\x2\x3D2\x3D3\x3\x2\x2\x2\x3D3"+
		"\x3D5\x3\x2\x2\x2\x3D4\x3D2\x3\x2\x2\x2\x3D5\x3D6\a\x1FF\x2\x2\x3D6\x1F"+
		"\x3\x2\x2\x2\x3D7\x3D8\ay\x2\x2\x3D8\x3DA\a\x11E\x2\x2\x3D9\x3DB\a*\x2"+
		"\x2\x3DA\x3D9\x3\x2\x2\x2\x3DA\x3DB\x3\x2\x2\x2\x3DB\x3DC\x3\x2\x2\x2"+
		"\x3DC\x3DD\x5\x2AA\x156\x2\x3DD\x3DE\a\x20A\x2\x2\x3DE!\x3\x2\x2\x2\x3DF"+
		"\x3E0\a\x10\x2\x2\x3E0\x3E1\a\x11E\x2\x2\x3E1\x3E2\x5\x2AA\x156\x2\x3E2"+
		"\x3E4\a\x46\x2\x2\x3E3\x3E5\a\x65\x2\x2\x3E4\x3E3\x3\x2\x2\x2\x3E4\x3E5"+
		"\x3\x2\x2\x2\x3E5\x3E7\x3\x2\x2\x2\x3E6\x3E8\t\a\x2\x2\x3E7\x3E6\x3\x2"+
		"\x2\x2\x3E7\x3E8\x3\x2\x2\x2\x3E8\x3EC\x3\x2\x2\x2\x3E9\x3EB\x5\xB4[\x2"+
		"\x3EA\x3E9\x3\x2\x2\x2\x3EB\x3EE\x3\x2\x2\x2\x3EC\x3EA\x3\x2\x2\x2\x3EC"+
		"\x3ED\x3\x2\x2\x2\x3ED\x3F1\x3\x2\x2\x2\x3EE\x3EC\x3\x2\x2\x2\x3EF\x3F0"+
		"\a\x14B\x2\x2\x3F0\x3F2\a\x169\x2\x2\x3F1\x3EF\x3\x2\x2\x2\x3F1\x3F2\x3"+
		"\x2\x2\x2\x3F2\x3F3\x3\x2\x2\x2\x3F3\x3F4\a\x20A\x2\x2\x3F4#\x3\x2\x2"+
		"\x2\x3F5\x3F8\aV\x2\x2\x3F6\x3F7\a\x115\x2\x2\x3F7\x3F9\a\x144\x2\x2\x3F8"+
		"\x3F6\x3\x2\x2\x2\x3F8\x3F9\x3\x2\x2\x2\x3F9\x3FA\x3\x2\x2\x2\x3FA\x3FD"+
		"\a\x11E\x2\x2\x3FB\x3FE\x5(\x15\x2\x3FC\x3FE\x5&\x14\x2\x3FD\x3FB\x3\x2"+
		"\x2\x2\x3FD\x3FC\x3\x2\x2\x2\x3FD\x3FE\x3\x2\x2\x2\x3FE\x3FF\x3\x2\x2"+
		"\x2\x3FF\x400\a\x20A\x2\x2\x400\x401\a\x205\x2\x2\x401%\x3\x2\x2\x2\x402"+
		"\x403\a*\x2\x2\x403\x404\x5\x2AA\x156\x2\x404\x408\x5\f\a\x2\x405\x407"+
		"\x5,\x17\x2\x406\x405\x3\x2\x2\x2\x407\x40A\x3\x2\x2\x2\x408\x406\x3\x2"+
		"\x2\x2\x408\x409\x3\x2\x2\x2\x409\x40D\x3\x2\x2\x2\x40A\x408\x3\x2\x2"+
		"\x2\x40B\x40C\a\"\x2\x2\x40C\x40E\x5\xE4s\x2\x40D\x40B\x3\x2\x2\x2\x40D"+
		"\x40E\x3\x2\x2\x2\x40E\x410\x3\x2\x2\x2\x40F\x411\x5\x114\x8B\x2\x410"+
		"\x40F\x3\x2\x2\x2\x410\x411\x3\x2\x2\x2\x411\x412\x3\x2\x2\x2\x412\x414"+
		"\a\x82\x2\x2\x413\x415\x5\x2AA\x156\x2\x414\x413\x3\x2\x2\x2\x414\x415"+
		"\x3\x2\x2\x2\x415\'\x3\x2\x2\x2\x416\x418\x5\x2AA\x156\x2\x417\x419\x5"+
		"\xB2Z\x2\x418\x417\x3\x2\x2\x2\x418\x419\x3\x2\x2\x2\x419\x41A\x3\x2\x2"+
		"\x2\x41A\x41E\x5\f\a\x2\x41B\x41D\x5*\x16\x2\x41C\x41B\x3\x2\x2\x2\x41D"+
		"\x420\x3\x2\x2\x2\x41E\x41C\x3\x2\x2\x2\x41E\x41F\x3\x2\x2\x2\x41F\x421"+
		"\x3\x2\x2\x2\x420\x41E\x3\x2\x2\x2\x421\x423\a\x82\x2\x2\x422\x424\x5"+
		"\x2AA\x156\x2\x423\x422\x3\x2\x2\x2\x423\x424\x3\x2\x2\x2\x424)\x3\x2"+
		"\x2\x2\x425\x430\x5\xC6\x64\x2\x426\x430\x5\xC8\x65\x2\x427\x430\x5\xCA"+
		"\x66\x2\x428\x430\x5\xCEh\x2\x429\x430\x5\xD0i\x2\x42A\x430\x5\xD2j\x2"+
		"\x42B\x430\x5\xDAn\x2\x42C\x430\x5\x34\x1B\x2\x42D\x430\x5\x14\v\x2\x42E"+
		"\x430\x5\x288\x145\x2\x42F\x425\x3\x2\x2\x2\x42F\x426\x3\x2\x2\x2\x42F"+
		"\x427\x3\x2\x2\x2\x42F\x428\x3\x2\x2\x2\x42F\x429\x3\x2\x2\x2\x42F\x42A"+
		"\x3\x2\x2\x2\x42F\x42B\x3\x2\x2\x2\x42F\x42C\x3\x2\x2\x2\x42F\x42D\x3"+
		"\x2\x2\x2\x42F\x42E\x3\x2\x2\x2\x430+\x3\x2\x2\x2\x431\x43C\x5\xC6\x64"+
		"\x2\x432\x43C\x5\xC8\x65\x2\x433\x43C\x5\xCA\x66\x2\x434\x43C\x5\xCEh"+
		"\x2\x435\x43C\x5\xD0i\x2\x436\x43C\x5\xD2j\x2\x437\x43C\x5\xDAn\x2\x438"+
		"\x43C\x5\x32\x1A\x2\x439\x43C\x5\x12\n\x2\x43A\x43C\x5\x288\x145\x2\x43B"+
		"\x431\x3\x2\x2\x2\x43B\x432\x3\x2\x2\x2\x43B\x433\x3\x2\x2\x2\x43B\x434"+
		"\x3\x2\x2\x2\x43B\x435\x3\x2\x2\x2\x43B\x436\x3\x2\x2\x2\x43B\x437\x3"+
		"\x2\x2\x2\x43B\x438\x3\x2\x2\x2\x43B\x439\x3\x2\x2\x2\x43B\x43A\x3\x2"+
		"\x2\x2\x43C-\x3\x2\x2\x2\x43D\x43E\ay\x2\x2\x43E\x43F\a\x137\x2\x2\x43F"+
		"\x440\x5\x2C4\x163\x2\x440\x441\a\x20A\x2\x2\x441/\x3\x2\x2\x2\x442\x443"+
		"\a\x10\x2\x2\x443\x444\a\x137\x2\x2\x444\x445\x5\x2C4\x163\x2\x445\x447"+
		"\a\x46\x2\x2\x446\x448\a\x65\x2\x2\x447\x446\x3\x2\x2\x2\x447\x448\x3"+
		"\x2\x2\x2\x448\x44C\x3\x2\x2\x2\x449\x44B\x5\xB4[\x2\x44A\x449\x3\x2\x2"+
		"\x2\x44B\x44E\x3\x2\x2\x2\x44C\x44A\x3\x2\x2\x2\x44C\x44D\x3\x2\x2\x2"+
		"\x44D\x451\x3\x2\x2\x2\x44E\x44C\x3\x2\x2\x2\x44F\x450\a\x14B\x2\x2\x450"+
		"\x452\a\x169\x2\x2\x451\x44F\x3\x2\x2\x2\x451\x452\x3\x2\x2\x2\x452\x453"+
		"\x3\x2\x2\x2\x453\x454\a\x20A\x2\x2\x454\x31\x3\x2\x2\x2\x455\x458\aV"+
		"\x2\x2\x456\x457\a\x115\x2\x2\x457\x459\a\x144\x2\x2\x458\x456\x3\x2\x2"+
		"\x2\x458\x459\x3\x2\x2\x2\x459\x45B\x3\x2\x2\x2\x45A\x455\x3\x2\x2\x2"+
		"\x45A\x45B\x3\x2\x2\x2\x45B\x45C\x3\x2\x2\x2\x45C\x45D\x5\x34\x1B\x2\x45D"+
		"\x33\x3\x2\x2\x2\x45E\x45F\a\x137\x2\x2\x45F\x46B\x5\x2C4\x163\x2\x460"+
		"\x461\a\x1FE\x2\x2\x461\x466\x5\xC0\x61\x2\x462\x463\a\x204\x2\x2\x463"+
		"\x465\x5\xC0\x61\x2\x464\x462\x3\x2\x2\x2\x465\x468\x3\x2\x2\x2\x466\x464"+
		"\x3\x2\x2\x2\x466\x467\x3\x2\x2\x2\x467\x469\x3\x2\x2\x2\x468\x466\x3"+
		"\x2\x2\x2\x469\x46A\a\x1FF\x2\x2\x46A\x46C\x3\x2\x2\x2\x46B\x460\x3\x2"+
		"\x2\x2\x46B\x46C\x3\x2\x2\x2\x46C\x47C\x3\x2\x2\x2\x46D\x46F\x5\xB2Z\x2"+
		"\x46E\x46D\x3\x2\x2\x2\x46E\x46F\x3\x2\x2\x2\x46F\x470\x3\x2\x2\x2\x470"+
		"\x47A\x5\f\a\x2\x471\x473\x5\xC4\x63\x2\x472\x471\x3\x2\x2\x2\x473\x476"+
		"\x3\x2\x2\x2\x474\x472\x3\x2\x2\x2\x474\x475\x3\x2\x2\x2\x475\x477\x3"+
		"\x2\x2\x2\x476\x474\x3\x2\x2\x2\x477\x47B\x5\x10E\x88\x2\x478\x47B\x5"+
		"\xB6\\\x2\x479\x47B\a\x91\x2\x2\x47A\x474\x3\x2\x2\x2\x47A\x478\x3\x2"+
		"\x2\x2\x47A\x479\x3\x2\x2\x2\x47B\x47D\x3\x2\x2\x2\x47C\x46E\x3\x2\x2"+
		"\x2\x47C\x47D\x3\x2\x2\x2\x47D\x47E\x3\x2\x2\x2\x47E\x47F\a\x20A\x2\x2"+
		"\x47F\x35\x3\x2\x2\x2\x480\x481\ay\x2\x2\x481\x482\a\x19B\x2\x2\x482\x483"+
		"\x5\x2C6\x164\x2\x483\x484\a\x20A\x2\x2\x484\x37\x3\x2\x2\x2\x485\x486"+
		"\a\x10\x2\x2\x486\x487\a\x19B\x2\x2\x487\x49A\x5\x2C6\x164\x2\x488\x49B"+
		"\t\b\x2\x2\x489\x48A\a\x143\x2\x2\x48A\x48B\a\x194\x2\x2\x48B\x49B\x5"+
		"\x2C6\x164\x2\x48C\x48E\a\x46\x2\x2\x48D\x48F\a\x65\x2\x2\x48E\x48D\x3"+
		"\x2\x2\x2\x48E\x48F\x3\x2\x2\x2\x48F\x493\x3\x2\x2\x2\x490\x492\x5\xB4"+
		"[\x2\x491\x490\x3\x2\x2\x2\x492\x495\x3\x2\x2\x2\x493\x491\x3\x2\x2\x2"+
		"\x493\x494\x3\x2\x2\x2\x494\x498\x3\x2\x2\x2\x495\x493\x3\x2\x2\x2\x496"+
		"\x497\a\x14B\x2\x2\x497\x499\a\x169\x2\x2\x498\x496\x3\x2\x2\x2\x498\x499"+
		"\x3\x2\x2\x2\x499\x49B\x3\x2\x2\x2\x49A\x488\x3\x2\x2\x2\x49A\x489\x3"+
		"\x2\x2\x2\x49A\x48C\x3\x2\x2\x2\x49B\x49C\x3\x2\x2\x2\x49C\x49D\a\x20A"+
		"\x2\x2\x49D\x39\x3\x2\x2\x2\x49E\x4A1\aV\x2\x2\x49F\x4A0\a\x115\x2\x2"+
		"\x4A0\x4A2\a\x144\x2\x2\x4A1\x49F\x3\x2\x2\x2\x4A1\x4A2\x3\x2\x2\x2\x4A2"+
		"\x4A3\x3\x2\x2\x2\x4A3\x4A4\a\x19B\x2\x2\x4A4\x4A8\x5\x2C6\x164\x2\x4A5"+
		"\x4A9\x5@!\x2\x4A6\x4A9\x5\x44#\x2\x4A7\x4A9\x5\x46$\x2\x4A8\x4A5\x3\x2"+
		"\x2\x2\x4A8\x4A6\x3\x2\x2\x2\x4A8\x4A7\x3\x2\x2\x2\x4A9\x4AB\x3\x2\x2"+
		"\x2\x4AA\x4AC\x5<\x1F\x2\x4AB\x4AA\x3\x2\x2\x2\x4AB\x4AC\x3\x2\x2\x2\x4AC"+
		"\x4AE\x3\x2\x2\x2\x4AD\x4AF\t\b\x2\x2\x4AE\x4AD\x3\x2\x2\x2\x4AE\x4AF"+
		"\x3\x2\x2\x2\x4AF\x4B1\x3\x2\x2\x2\x4B0\x4B2\x5> \x2\x4B1\x4B0\x3\x2\x2"+
		"\x2\x4B1\x4B2\x3\x2\x2\x2\x4B2\x4B3\x3\x2\x2\x2\x4B3\x4B4\x5H%\x2\x4B4"+
		"\x4B5\a\x20A\x2\x2\x4B5;\x3\x2\x2\x2\x4B6\x4B7\a\x9C\x2\x2\x4B7\x4BC\x5"+
		"\x2C6\x164\x2\x4B8\x4B9\a\x204\x2\x2\x4B9\x4BB\x5\x2C6\x164\x2\x4BA\x4B8"+
		"\x3\x2\x2\x2\x4BB\x4BE\x3\x2\x2\x2\x4BC\x4BA\x3\x2\x2\x2\x4BC\x4BD\x3"+
		"\x2\x2\x2\x4BD=\x3\x2\x2\x2\x4BE\x4BC\x3\x2\x2\x2\x4BF\x4C0\a\x1BA\x2"+
		"\x2\x4C0\x4C1\a\x1FE\x2\x2\x4C1\x4C2\x5\x1FE\x100\x2\x4C2\x4C3\a\x1FF"+
		"\x2\x2\x4C3?\x3\x2\x2\x2\x4C4\x4C9\a!\x2\x2\x4C5\x4C9\a\f\x2\x2\x4C6\x4C7"+
		"\a\xBD\x2\x2\x4C7\x4C9\a\x10D\x2\x2\x4C8\x4C4\x3\x2\x2\x2\x4C8\x4C5\x3"+
		"\x2\x2\x2\x4C8\x4C6\x3\x2\x2\x2\x4C9\x4CA\x3\x2\x2\x2\x4CA\x4CC\x5R*\x2"+
		"\x4CB\x4CD\x5X-\x2\x4CC\x4CB\x3\x2\x2\x2\x4CC\x4CD\x3\x2\x2\x2\x4CD\x4CF"+
		"\x3\x2\x2\x2\x4CE\x4D0\x5\x42\"\x2\x4CF\x4CE\x3\x2\x2\x2\x4CF\x4D0\x3"+
		"\x2\x2\x2\x4D0\x41\x3\x2\x2\x2\x4D1\x4D2\a\x9D\x2\x2\x4D2\x4D3\a{\x2\x2"+
		"\x4D3\x4D4\a\x151\x2\x2\x4D4\x43\x3\x2\x2\x2\x4D5\x4D6\a\x9D\x2\x2\x4D6"+
		"\x4D8\x5R*\x2\x4D7\x4D9\x5X-\x2\x4D8\x4D7\x3\x2\x2\x2\x4D8\x4D9\x3\x2"+
		"\x2\x2\x4D9\x45\x3\x2\x2\x2\x4DA\x4DB\t\t\x2\x2\x4DB\x4E0\x5P)\x2\x4DC"+
		"\x4DD\a\x115\x2\x2\x4DD\x4DF\x5P)\x2\x4DE\x4DC\x3\x2\x2\x2\x4DF\x4E2\x3"+
		"\x2\x2\x2\x4E0\x4DE\x3\x2\x2\x2\x4E0\x4E1\x3\x2\x2\x2\x4E1\x4E3\x3\x2"+
		"\x2\x2\x4E2\x4E0\x3\x2\x2\x2\x4E3\x4EB\a\x111\x2\x2\x4E4\x4EC\a_\x2\x2"+
		"\x4E5\x4E6\x5\x2A6\x154\x2\x4E6\x4E7\a\x1F7\x2\x2\x4E7\x4E9\x3\x2\x2\x2"+
		"\x4E8\x4E5\x3\x2\x2\x2\x4E8\x4E9\x3\x2\x2\x2\x4E9\x4EA\x3\x2\x2\x2\x4EA"+
		"\x4EC\a\x158\x2\x2\x4EB\x4E4\x3\x2\x2\x2\x4EB\x4E8\x3\x2\x2\x2\x4ECG\x3"+
		"\x2\x2\x2\x4ED\x4EE\aG\x2\x2\x4EE\x4F3\a\x19B\x2\x2\x4EF\x4F0\a\x33\x2"+
		"\x2\x4F0\x4F3\x5\x2FC\x17F\x2\x4F1\x4F3\x5\x118\x8D\x2\x4F2\x4ED\x3\x2"+
		"\x2\x2\x4F2\x4EF\x3\x2\x2\x2\x4F2\x4F1\x3\x2\x2\x2\x4F3I\x3\x2\x2\x2\x4F4"+
		"\x4F6\x5\x2A8\x155\x2\x4F5\x4F7\x5\x2DC\x16F\x2\x4F6\x4F5\x3\x2\x2\x2"+
		"\x4F6\x4F7\x3\x2\x2\x2\x4F7K\x3\x2\x2\x2\x4F8\x4F9\aG\x2\x2\x4F9\x4FD"+
		"\a\x19B\x2\x2\x4FA\x4FC\x5\xC4\x63\x2\x4FB\x4FA\x3\x2\x2\x2\x4FC\x4FF"+
		"\x3\x2\x2\x2\x4FD\x4FB\x3\x2\x2\x2\x4FD\x4FE\x3\x2\x2\x2\x4FE\x501\x3"+
		"\x2\x2\x2\x4FF\x4FD\x3\x2\x2\x2\x500\x502\x5N(\x2\x501\x500\x3\x2\x2\x2"+
		"\x502\x503\x3\x2\x2\x2\x503\x501\x3\x2\x2\x2\x503\x504\x3\x2\x2\x2\x504"+
		"\x505\x3\x2\x2\x2\x505\x506\a\x82\x2\x2\x506\x507\x5\x2C6\x164\x2\x507"+
		"M\x3\x2\x2\x2\x508\x509\a!\x2\x2\x509\x50A\a\x17D\x2\x2\x50A\x50B\a\xC4"+
		"\x2\x2\x50B\x50C\x5\x118\x8D\x2\x50C\x50D\a!\x2\x2\x50D\x50E\a\x17D\x2"+
		"\x2\x50E\x50F\a\x20A\x2\x2\x50F\x52D\x3\x2\x2\x2\x510\x511\a!\x2\x2\x511"+
		"\x512\a{\x2\x2\x512\x513\a\x151\x2\x2\x513\x514\a\xC4\x2\x2\x514\x515"+
		"\x5\x118\x8D\x2\x515\x516\a!\x2\x2\x516\x517\a{\x2\x2\x517\x518\a\x151"+
		"\x2\x2\x518\x519\a\x20A\x2\x2\x519\x52D\x3\x2\x2\x2\x51A\x51B\a\f\x2\x2"+
		"\x51B\x51C\a\x17D\x2\x2\x51C\x51D\a\xC4\x2\x2\x51D\x51E\x5\x118\x8D\x2"+
		"\x51E\x51F\a\f\x2\x2\x51F\x520\a\x17D\x2\x2\x520\x521\a\x20A\x2\x2\x521"+
		"\x52D\x3\x2\x2\x2\x522\x523\a\f\x2\x2\x523\x524\a{\x2\x2\x524\x525\a\x151"+
		"\x2\x2\x525\x526\a\xC4\x2\x2\x526\x527\x5\x118\x8D\x2\x527\x528\a\f\x2"+
		"\x2\x528\x529\a{\x2\x2\x529\x52A\a\x151\x2\x2\x52A\x52B\a\x20A\x2\x2\x52B"+
		"\x52D\x3\x2\x2\x2\x52C\x508\x3\x2\x2\x2\x52C\x510\x3\x2\x2\x2\x52C\x51A"+
		"\x3\x2\x2\x2\x52C\x522\x3\x2\x2\x2\x52DO\x3\x2\x2\x2\x52E\x549\a\x10\x2"+
		"\x2\x52F\x549\a\x11\x2\x2\x530\x531\a\x17\x2\x2\x531\x549\a\x180\x2\x2"+
		"\x532\x549\a\x1B\x2\x2\x533\x549\a\x42\x2\x2\x534\x549\aV\x2\x2\x535\x536"+
		"\au\x2\x2\x536\x549\a\x180\x2\x2\x537\x549\ay\x2\x2\x538\x549\a\xA4\x2"+
		"\x2\x539\x549\a\xFB\x2\x2\x53A\x549\a\x143\x2\x2\x53B\x549\a\x14D\x2\x2"+
		"\x53C\x549\a\x19E\x2\x2\x53D\x549\a\x64\x2\x2\x53E\x549\a\x17C\x2\x2\x53F"+
		"\x549\a\x16C\x2\x2\x540\x549\a\x62\x2\x2\x541\x549\a\xDB\x2\x2\x542\x549"+
		"\a\xDA\x2\x2\x543\x549\a\x165\x2\x2\x544\x549\a\x187\x2\x2\x545\x549\a"+
		"_\x2\x2\x546\x549\a\x158\x2\x2\x547\x549\a\x9C\x2\x2\x548\x52E\x3\x2\x2"+
		"\x2\x548\x52F\x3\x2\x2\x2\x548\x530\x3\x2\x2\x2\x548\x532\x3\x2\x2\x2"+
		"\x548\x533\x3\x2\x2\x2\x548\x534\x3\x2\x2\x2\x548\x535\x3\x2\x2\x2\x548"+
		"\x537\x3\x2\x2\x2\x548\x538\x3\x2\x2\x2\x548\x539\x3\x2\x2\x2\x548\x53A"+
		"\x3\x2\x2\x2\x548\x53B\x3\x2\x2\x2\x548\x53C\x3\x2\x2\x2\x548\x53D\x3"+
		"\x2\x2\x2\x548\x53E\x3\x2\x2\x2\x548\x53F\x3\x2\x2\x2\x548\x540\x3\x2"+
		"\x2\x2\x548\x541\x3\x2\x2\x2\x548\x542\x3\x2\x2\x2\x548\x543\x3\x2\x2"+
		"\x2\x548\x544\x3\x2\x2\x2\x548\x545\x3\x2\x2\x2\x548\x546\x3\x2\x2\x2"+
		"\x548\x547\x3\x2\x2\x2\x549Q\x3\x2\x2\x2\x54A\x54F\x5T+\x2\x54B\x54C\a"+
		"\x115\x2\x2\x54C\x54E\x5T+\x2\x54D\x54B\x3\x2\x2\x2\x54E\x551\x3\x2\x2"+
		"\x2\x54F\x54D\x3\x2\x2\x2\x54F\x550\x3\x2\x2\x2\x550\x552\x3\x2\x2\x2"+
		"\x551\x54F\x3\x2\x2\x2\x552\x554\a\x111\x2\x2\x553\x555\x5V,\x2\x554\x553"+
		"\x3\x2\x2\x2\x554\x555\x3\x2\x2\x2\x555\x556\x3\x2\x2\x2\x556\x557\x5"+
		"\x2D6\x16C\x2\x557S\x3\x2\x2\x2\x558\x562\t\n\x2\x2\x559\x55A\a\x10D\x2"+
		"\x2\x55A\x55F\x5\x2D4\x16B\x2\x55B\x55C\a\x204\x2\x2\x55C\x55E\x5\x2D4"+
		"\x16B\x2\x55D\x55B\x3\x2\x2\x2\x55E\x561\x3\x2\x2\x2\x55F\x55D\x3\x2\x2"+
		"\x2\x55F\x560\x3\x2\x2\x2\x560\x563\x3\x2\x2\x2\x561\x55F\x3\x2\x2\x2"+
		"\x562\x559\x3\x2\x2\x2\x562\x563\x3\x2\x2\x2\x563U\x3\x2\x2\x2\x564\x565"+
		"\a\xF7\x2\x2\x565\x566\a\x188\x2\x2\x566\x567\x5\x2D6\x16C\x2\x567\x568"+
		"\a\x10D\x2\x2\x568W\x3\x2\x2\x2\x569\x56B\a\x140\x2\x2\x56A\x56C\x5Z."+
		"\x2\x56B\x56A\x3\x2\x2\x2\x56C\x56D\x3\x2\x2\x2\x56D\x56B\x3\x2\x2\x2"+
		"\x56D\x56E\x3\x2\x2\x2\x56EY\x3\x2\x2\x2\x56F\x570\t\v\x2\x2\x570\x571"+
		"\x5\x28C\x147\x2\x571[\x3\x2\x2\x2\x572\x573\ay\x2\x2\x573\x575\a\x19F"+
		"\x2\x2\x574\x576\a*\x2\x2\x575\x574\x3\x2\x2\x2\x575\x576\x3\x2\x2\x2"+
		"\x576\x577\x3\x2\x2\x2\x577\x579\x5\x2BC\x15F\x2\x578\x57A\t\f\x2\x2\x579"+
		"\x578\x3\x2\x2\x2\x579\x57A\x3\x2\x2\x2\x57A\x57B\x3\x2\x2\x2\x57B\x57C"+
		"\a\x20A\x2\x2\x57C]\x3\x2\x2\x2\x57D\x57E\a\x10\x2\x2\x57E\x57F\a\x19F"+
		"\x2\x2\x57F\x585\x5\x2BC\x15F\x2\x580\x586\x5`\x31\x2\x581\x586\x5\x62"+
		"\x32\x2\x582\x586\x5\x64\x33\x2\x583\x586\x5l\x37\x2\x584\x586\x5\x8E"+
		"H\x2\x585\x580\x3\x2\x2\x2\x585\x581\x3\x2\x2\x2\x585\x582\x3\x2\x2\x2"+
		"\x585\x583\x3\x2\x2\x2\x585\x584\x3\x2\x2\x2\x586\x588\x3\x2\x2\x2\x587"+
		"\x589\x5n\x38\x2\x588\x587\x3\x2\x2\x2\x588\x589\x3\x2\x2\x2\x589\x58A"+
		"\x3\x2\x2\x2\x58A\x58B\a\x20A\x2\x2\x58B_\x3\x2\x2\x2\x58C\x58E\a\x46"+
		"\x2\x2\x58D\x58F\a\x65\x2\x2\x58E\x58D\x3\x2\x2\x2\x58E\x58F\x3\x2\x2"+
		"\x2\x58F\x591\x3\x2\x2\x2\x590\x592\t\r\x2\x2\x591\x590\x3\x2\x2\x2\x591"+
		"\x592\x3\x2\x2\x2\x592\x596\x3\x2\x2\x2\x593\x595\x5\xB4[\x2\x594\x593"+
		"\x3\x2\x2\x2\x595\x598\x3\x2\x2\x2\x596\x594\x3\x2\x2\x2\x596\x597\x3"+
		"\x2\x2\x2\x597\x59B\x3\x2\x2\x2\x598\x596\x3\x2\x2\x2\x599\x59A\a\x14B"+
		"\x2\x2\x59A\x59C\a\x169\x2\x2\x59B\x599\x3\x2\x2\x2\x59B\x59C\x3\x2\x2"+
		"\x2\x59C\x61\x3\x2\x2\x2\x59D\x59F\a\x144\x2\x2\x59E\x5A0\x5\xB2Z\x2\x59F"+
		"\x59E\x3\x2\x2\x2\x59F\x5A0\x3\x2\x2\x2\x5A0\x5A1\x3\x2\x2\x2\x5A1\x5A2"+
		"\a\x15\x2\x2\x5A2\x5A3\a\x10C\x2\x2\x5A3\x5A4\a\x1FE\x2\x2\x5A4\x5A9\x5"+
		"\x90I\x2\x5A5\x5A6\a\x204\x2\x2\x5A6\x5A8\x5\x90I\x2\x5A7\x5A5\x3\x2\x2"+
		"\x2\x5A8\x5AB\x3\x2\x2\x2\x5A9\x5A7\x3\x2\x2\x2\x5A9\x5AA\x3\x2\x2\x2"+
		"\x5AA\x5AC\x3\x2\x2\x2\x5AB\x5A9\x3\x2\x2\x2\x5AC\x5AD\a\x1FF\x2\x2\x5AD"+
		"\x63\x3\x2\x2\x2\x5AE\x5B3\x5\x66\x34\x2\x5AF\x5B0\a\x204\x2\x2\x5B0\x5B2"+
		"\x5\x66\x34\x2\x5B1\x5AF\x3\x2\x2\x2\x5B2\x5B5\x3\x2\x2\x2\x5B3\x5B1\x3"+
		"\x2\x2\x2\x5B3\x5B4\x3\x2\x2\x2\x5B4\x65\x3\x2\x2\x2\x5B5\x5B3\x3\x2\x2"+
		"\x2\x5B6\x5B9\t\xE\x2\x2\x5B7\x5BA\x5\xA0Q\x2\x5B8\x5BA\x5\x98M\x2\x5B9"+
		"\x5B7\x3\x2\x2\x2\x5B9\x5B8\x3\x2\x2\x2\x5BAg\x3\x2\x2\x2\x5BB\x5BC\t"+
		"\xF\x2\x2\x5BC\x5C9\a\x1A\x2\x2\x5BD\x5CA\x5j\x36\x2\x5BE\x5BF\a\x1FE"+
		"\x2\x2\x5BF\x5C4\x5j\x36\x2\x5C0\x5C1\a\x204\x2\x2\x5C1\x5C3\x5j\x36\x2"+
		"\x5C2\x5C0\x3\x2\x2\x2\x5C3\x5C6\x3\x2\x2\x2\x5C4\x5C2\x3\x2\x2\x2\x5C4"+
		"\x5C5\x3\x2\x2\x2\x5C5\x5C7\x3\x2\x2\x2\x5C6\x5C4\x3\x2\x2\x2\x5C7\x5C8"+
		"\a\x1FF\x2\x2\x5C8\x5CA\x3\x2\x2\x2\x5C9\x5BD\x3\x2\x2\x2\x5C9\x5BE\x3"+
		"\x2\x2\x2\x5CAi\x3\x2\x2\x2\x5CB\x5CD\x5\x29E\x150\x2\x5CC\x5CE\x5\x2E6"+
		"\x174\x2\x5CD\x5CC\x3\x2\x2\x2\x5CD\x5CE\x3\x2\x2\x2\x5CEk\x3\x2\x2\x2"+
		"\x5CF\x5D5\a\xEC\x2\x2\x5D0\x5D1\a\xD5\x2\x2\x5D1\x5D6\x5\x202\x102\x2"+
		"\x5D2\x5D3\a|\x2\x2\x5D3\x5D4\a\x19F\x2\x2\x5D4\x5D6\x5\x2E6\x174\x2\x5D5"+
		"\x5D0\x3\x2\x2\x2\x5D5\x5D2\x3\x2\x2\x2\x5D6m\x3\x2\x2\x2\x5D7\x5E8\a"+
		"\xC3\x2\x2\x5D8\x5E2\a\x35\x2\x2\x5D9\x5DA\aQ\x2\x2\x5DA\x5DB\a\x194\x2"+
		"\x2\x5DB\x5E3\a\x184\x2\x2\x5DC\x5DE\a\x105\x2\x2\x5DD\x5DC\x3\x2\x2\x2"+
		"\x5DD\x5DE\x3\x2\x2\x2\x5DE\x5DF\x3\x2\x2\x2\x5DF\x5E0\a\xB0\x2\x2\x5E0"+
		"\x5E1\a\x188\x2\x2\x5E1\x5E3\a^\x2\x2\x5E2\x5D9\x3\x2\x2\x2\x5E2\x5DD"+
		"\x3\x2\x2\x2\x5E2\x5E3\x3\x2\x2\x2\x5E3\x5E5\x3\x2\x2\x2\x5E4\x5E6\x5"+
		"p\x39\x2\x5E5\x5E4\x3\x2\x2\x2\x5E5\x5E6\x3\x2\x2\x2\x5E6\x5E8\x3\x2\x2"+
		"\x2\x5E7\x5D7\x3\x2\x2\x2\x5E7\x5D8\x3\x2\x2\x2\x5E8o\x3\x2\x2\x2\x5E9"+
		"\x5EB\a\x9F\x2\x2\x5EA\x5E9\x3\x2\x2\x2\x5EA\x5EB\x3\x2\x2\x2\x5EB\x5EC"+
		"\x3\x2\x2\x2\x5EC\x5ED\a\x8A\x2\x2\x5ED\x5EE\a\xC2\x2\x2\x5EE\x5EF\x5"+
		"\x2D6\x16C\x2\x5EFq\x3\x2\x2\x2\x5F0\x5F3\aV\x2\x2\x5F1\x5F2\a\x115\x2"+
		"\x2\x5F2\x5F4\a\x144\x2\x2\x5F3\x5F1\x3\x2\x2\x2\x5F3\x5F4\x3\x2\x2\x2"+
		"\x5F4\x5F5\x3\x2\x2\x2\x5F5\x5F8\a\x19F\x2\x2\x5F6\x5F9\x5t;\x2\x5F7\x5F9"+
		"\x5\x80\x41\x2\x5F8\x5F6\x3\x2\x2\x2\x5F8\x5F7\x3\x2\x2\x2\x5F9\x5FA\x3"+
		"\x2\x2\x2\x5FA\x5FB\a\x20A\x2\x2\x5FBs\x3\x2\x2\x2\x5FC\x5FF\x5\x2BC\x15F"+
		"\x2\x5FD\x5FE\a\x10F\x2\x2\x5FE\x600\a\x1FA\x2\x2\x5FF\x5FD\x3\x2\x2\x2"+
		"\x5FF\x600\x3\x2\x2\x2\x600\x602\x3\x2\x2\x2\x601\x603\x5v<\x2\x602\x601"+
		"\x3\x2\x2\x2\x602\x603\x3\x2\x2\x2\x603u\x3\x2\x2\x2\x604\x606\x5\xB2"+
		"Z\x2\x605\x604\x3\x2\x2\x2\x605\x606\x3\x2\x2\x2\x606\x609\x3\x2\x2\x2"+
		"\x607\x60A\x5x=\x2\x608\x60A\x5z>\x2\x609\x607\x3\x2\x2\x2\x609\x608\x3"+
		"\x2\x2\x2\x60A\x60C\x3\x2\x2\x2\x60B\x60D\x5~@\x2\x60C\x60B\x3\x2\x2\x2"+
		"\x60C\x60D\x3\x2\x2\x2\x60D\x619\x3\x2\x2\x2\x60E\x60F\a\x1FE\x2\x2\x60F"+
		"\x614\x5\x90I\x2\x610\x611\a\x204\x2\x2\x611\x613\x5\x90I\x2\x612\x610"+
		"\x3\x2\x2\x2\x613\x616\x3\x2\x2\x2\x614\x612\x3\x2\x2\x2\x614\x615\x3"+
		"\x2\x2\x2\x615\x617\x3\x2\x2\x2\x616\x614\x3\x2\x2\x2\x617\x618\a\x1FF"+
		"\x2\x2\x618\x61A\x3\x2\x2\x2\x619\x60E\x3\x2\x2\x2\x619\x61A\x3\x2\x2"+
		"\x2\x61A\x61E\x3\x2\x2\x2\x61B\x61D\x5\x8EH\x2\x61C\x61B\x3\x2\x2\x2\x61D"+
		"\x620\x3\x2\x2\x2\x61E\x61C\x3\x2\x2\x2\x61E\x61F\x3\x2\x2\x2\x61Fw\x3"+
		"\x2\x2\x2\x620\x61E\x3\x2\x2\x2\x621\x625\x5\f\a\x2\x622\x626\a\x10C\x2"+
		"\x2\x623\x626\x5\xE0q\x2\x624\x626\x5|?\x2\x625\x622\x3\x2\x2\x2\x625"+
		"\x623\x3\x2\x2\x2\x625\x624\x3\x2\x2\x2\x626y\x3\x2\x2\x2\x627\x628\a"+
		"\x1A1\x2\x2\x628\x629\x5\x2E6\x174\x2\x629{\x3\x2\x2\x2\x62A\x62B\a\x188"+
		"\x2\x2\x62B\x62C\a\x10D\x2\x2\x62C\x62F\x5\x2E6\x174\x2\x62D\x62E\a\x105"+
		"\x2\x2\x62E\x630\a\x107\x2\x2\x62F\x62D\x3\x2\x2\x2\x62F\x630\x3\x2\x2"+
		"\x2\x630}\x3\x2\x2\x2\x631\x632\a\x91\x2\x2\x632\x633\a\xEF\x2\x2\x633"+
		"\x634\x5\x202\x102\x2\x634\x635\a\xCA\x2\x2\x635\x636\a\xC7\x2\x2\x636"+
		"\x637\a\x1AC\x2\x2\x637\x638\t\x10\x2\x2\x638\x7F\x3\x2\x2\x2\x639\x63A"+
		"\a*\x2\x2\x63A\x63B\x5\x2BC\x15F\x2\x63B\x63D\x5\f\a\x2\x63C\x63E\x5\x82"+
		"\x42\x2\x63D\x63C\x3\x2\x2\x2\x63E\x63F\x3\x2\x2\x2\x63F\x63D\x3\x2\x2"+
		"\x2\x63F\x640\x3\x2\x2\x2\x640\x641\x3\x2\x2\x2\x641\x642\a\x82\x2\x2"+
		"\x642\x81\x3\x2\x2\x2\x643\x646\x5\x84\x43\x2\x644\x646\x5\x86\x44\x2"+
		"\x645\x643\x3\x2\x2\x2\x645\x644\x3\x2\x2\x2\x646\x83\x3\x2\x2\x2\x647"+
		"\x648\t\x11\x2\x2\x648\x649\a\xE3\x2\x2\x649\x64A\x5\x8A\x46\x2\x64A\x85"+
		"\x3\x2\x2\x2\x64B\x64F\t\x12\x2\x2\x64C\x650\x5\x88\x45\x2\x64D\x650\x5"+
		"\x8A\x46\x2\x64E\x650\x5\x8CG\x2\x64F\x64C\x3\x2\x2\x2\x64F\x64D\x3\x2"+
		"\x2\x2\x64F\x64E\x3\x2\x2\x2\x650\x87\x3\x2\x2\x2\x651\x652\a\x137\x2"+
		"\x2\x652\x653\x5\x2C4\x163\x2\x653\x654\a\x1FE\x2\x2\x654\x659\x5\xA6"+
		"T\x2\x655\x656\a\x204\x2\x2\x656\x658\x5\xA6T\x2\x657\x655\x3\x2\x2\x2"+
		"\x658\x65B\x3\x2\x2\x2\x659\x657\x3\x2\x2\x2\x659\x65A\x3\x2\x2\x2\x65A"+
		"\x65C\x3\x2\x2\x2\x65B\x659\x3\x2\x2\x2\x65C\x65D\a\x1FF\x2\x2\x65D\x668"+
		"\x5\f\a\x2\x65E\x669\x5\xB6\\\x2\x65F\x661\x5\xC4\x63\x2\x660\x65F\x3"+
		"\x2\x2\x2\x661\x664\x3\x2\x2\x2\x662\x660\x3\x2\x2\x2\x662\x663\x3\x2"+
		"\x2\x2\x663\x665\x3\x2\x2\x2\x664\x662\x3\x2\x2\x2\x665\x666\x5\x10E\x88"+
		"\x2\x666\x667\a\x20A\x2\x2\x667\x669\x3\x2\x2\x2\x668\x65E\x3\x2\x2\x2"+
		"\x668\x662\x3\x2\x2\x2\x669\x89\x3\x2\x2\x2\x66A\x66B\a\xA2\x2\x2\x66B"+
		"\x677\x5\x2C2\x162\x2\x66C\x66D\a\x1FE\x2\x2\x66D\x672\x5\xA6T\x2\x66E"+
		"\x66F\a\x204\x2\x2\x66F\x671\x5\xA6T\x2\x670\x66E\x3\x2\x2\x2\x671\x674"+
		"\x3\x2\x2\x2\x672\x670\x3\x2\x2\x2\x672\x673\x3\x2\x2\x2\x673\x675\x3"+
		"\x2\x2\x2\x674\x672\x3\x2\x2\x2\x675\x676\a\x1FF\x2\x2\x676\x678\x3\x2"+
		"\x2\x2\x677\x66C\x3\x2\x2\x2\x677\x678\x3\x2\x2\x2\x678\x679\x3\x2\x2"+
		"\x2\x679\x67A\a\x149\x2\x2\x67A\x67B\x5\x2E6\x174\x2\x67B\x686\x5\f\a"+
		"\x2\x67C\x687\x5\xB6\\\x2\x67D\x67F\x5\xC4\x63\x2\x67E\x67D\x3\x2\x2\x2"+
		"\x67F\x682\x3\x2\x2\x2\x680\x67E\x3\x2\x2\x2\x680\x681\x3\x2\x2\x2\x681"+
		"\x683\x3\x2\x2\x2\x682\x680\x3\x2\x2\x2\x683\x684\x5\x10E\x88\x2\x684"+
		"\x685\a\x20A\x2\x2\x685\x687\x3\x2\x2\x2\x686\x67C\x3\x2\x2\x2\x686\x680"+
		"\x3\x2\x2\x2\x687\x8B\x3\x2\x2\x2\x688\x68A\a\x97\x2\x2\x689\x688\x3\x2"+
		"\x2\x2\x689\x68A\x3\x2\x2\x2\x68A\x68C\x3\x2\x2\x2\x68B\x68D\a\xBC\x2"+
		"\x2\x68C\x68B\x3\x2\x2\x2\x68C\x68D\x3\x2\x2\x2\x68D\x68E\x3\x2\x2\x2"+
		"\x68E\x68F\aM\x2\x2\x68F\x690\a\xA2\x2\x2\x690\x6A2\x5\x2E6\x174\x2\x691"+
		"\x692\a\x1FE\x2\x2\x692\x693\a\x160\x2\x2\x693\x694\a\xAE\x2\x2\x694\x695"+
		"\a\x11A\x2\x2\x695\x696\x5\x2E6\x174\x2\x696\x697\a\x204\x2\x2\x697\x698"+
		"\x3\x2\x2\x2\x698\x69D\x5\xA6T\x2\x699\x69A\a\x204\x2\x2\x69A\x69C\x5"+
		"\xA6T\x2\x69B\x699\x3\x2\x2\x2\x69C\x69F\x3\x2\x2\x2\x69D\x69B\x3\x2\x2"+
		"\x2\x69D\x69E\x3\x2\x2\x2\x69E\x6A0\x3\x2\x2\x2\x69F\x69D\x3\x2\x2\x2"+
		"\x6A0\x6A1\a\x1FF\x2\x2\x6A1\x6A3\x3\x2\x2\x2\x6A2\x691\x3\x2\x2\x2\x6A2"+
		"\x6A3\x3\x2\x2\x2\x6A3\x6A4\x3\x2\x2\x2\x6A4\x6A5\a\x149\x2\x2\x6A5\x6A6"+
		"\a\x160\x2\x2\x6A6\x6A7\a\x15\x2\x2\x6A7\x6A8\a\x147\x2\x2\x6A8\x6B3\x5"+
		"\f\a\x2\x6A9\x6B4\x5\xB6\\\x2\x6AA\x6AC\x5\xC4\x63\x2\x6AB\x6AA\x3\x2"+
		"\x2\x2\x6AC\x6AF\x3\x2\x2\x2\x6AD\x6AB\x3\x2\x2\x2\x6AD\x6AE\x3\x2\x2"+
		"\x2\x6AE\x6B0\x3\x2\x2\x2\x6AF\x6AD\x3\x2\x2\x2\x6B0\x6B1\x5\x10E\x88"+
		"\x2\x6B1\x6B2\a\x20A\x2\x2\x6B2\x6B4\x3\x2\x2\x2\x6B3\x6A9\x3\x2\x2\x2"+
		"\x6B3\x6AD\x3\x2\x2\x2\x6B4\x8D\x3\x2\x2\x2\x6B5\x6B7\a\x105\x2\x2\x6B6"+
		"\x6B5\x3\x2\x2\x2\x6B6\x6B7\x3\x2\x2\x2\x6B7\x6B8\x3\x2\x2\x2\x6B8\x6B9"+
		"\t\x13\x2\x2\x6B9\x8F\x3\x2\x2\x2\x6BA\x6BB\x5\x2FC\x17F\x2\x6BB\x6BD"+
		"\x5\x2E6\x174\x2\x6BC\x6BE\x5\x92J\x2\x6BD\x6BC\x3\x2\x2\x2\x6BD\x6BE"+
		"\x3\x2\x2\x2\x6BE\x6C1\x3\x2\x2\x2\x6BF\x6C1\x5\x94K\x2\x6C0\x6BA\x3\x2"+
		"\x2\x2\x6C0\x6BF\x3\x2\x2\x2\x6C1\x91\x3\x2\x2\x2\x6C2\x6C3\a\x91\x2\x2"+
		"\x6C3\x6C4\a\xEF\x2\x2\x6C4\x6C5\x5\x202\x102\x2\x6C5\x93\x3\x2\x2\x2"+
		"\x6C6\x6C8\x5\x8EH\x2\x6C7\x6C6\x3\x2\x2\x2\x6C7\x6C8\x3\x2\x2\x2\x6C8"+
		"\x6CA\x3\x2\x2\x2\x6C9\x6CB\x5\x96L\x2\x6CA\x6C9\x3\x2\x2\x2\x6CB\x6CC"+
		"\x3\x2\x2\x2\x6CC\x6CA\x3\x2\x2\x2\x6CC\x6CD\x3\x2\x2\x2\x6CD\x6D0\x3"+
		"\x2\x2\x2\x6CE\x6CF\a\x204\x2\x2\x6CF\x6D1\x5\xA2R\x2\x6D0\x6CE\x3\x2"+
		"\x2\x2\x6D0\x6D1\x3\x2\x2\x2\x6D1\x95\x3\x2\x2\x2\x6D2\x6D6\x5\x98M\x2"+
		"\x6D3\x6D6\x5\x9EP\x2\x6D4\x6D6\x5\xA0Q\x2\x6D5\x6D2\x3\x2\x2\x2\x6D5"+
		"\x6D3\x3\x2\x2\x2\x6D5\x6D4\x3\x2\x2\x2\x6D6\x97\x3\x2\x2\x2\x6D7\x6DA"+
		"\t\x12\x2\x2\x6D8\x6DB\x5\x9AN\x2\x6D9\x6DB\x5\x9CO\x2\x6DA\x6D8\x3\x2"+
		"\x2\x2\x6DA\x6D9\x3\x2\x2\x2\x6DB\x99\x3\x2\x2\x2\x6DC\x6DD\a\x137\x2"+
		"\x2\x6DD\x6DE\x5\x2C4\x163\x2\x6DE\x6DF\a\x1FE\x2\x2\x6DF\x6E4\x5\xA6"+
		"T\x2\x6E0\x6E1\a\x204\x2\x2\x6E1\x6E3\x5\xA6T\x2\x6E2\x6E0\x3\x2\x2\x2"+
		"\x6E3\x6E6\x3\x2\x2\x2\x6E4\x6E2\x3\x2\x2\x2\x6E4\x6E5\x3\x2\x2\x2\x6E5"+
		"\x6E7\x3\x2\x2\x2\x6E6\x6E4\x3\x2\x2\x2\x6E7\x6EB\a\x1FF\x2\x2\x6E8\x6E9"+
		"\x5\f\a\x2\x6E9\x6EA\x5\xB6\\\x2\x6EA\x6EC\x3\x2\x2\x2\x6EB\x6E8\x3\x2"+
		"\x2\x2\x6EB\x6EC\x3\x2\x2\x2\x6EC\x9B\x3\x2\x2\x2\x6ED\x6EE\a\xA2\x2\x2"+
		"\x6EE\x6FA\x5\x2C2\x162\x2\x6EF\x6F0\a\x1FE\x2\x2\x6F0\x6F5\x5\xA6T\x2"+
		"\x6F1\x6F2\a\x204\x2\x2\x6F2\x6F4\x5\xA6T\x2\x6F3\x6F1\x3\x2\x2\x2\x6F4"+
		"\x6F7\x3\x2\x2\x2\x6F5\x6F3\x3\x2\x2\x2\x6F5\x6F6\x3\x2\x2\x2\x6F6\x6F8"+
		"\x3\x2\x2\x2\x6F7\x6F5\x3\x2\x2\x2\x6F8\x6F9\a\x1FF\x2\x2\x6F9\x6FB\x3"+
		"\x2\x2\x2\x6FA\x6EF\x3\x2\x2\x2\x6FA\x6FB\x3\x2\x2\x2\x6FB\x6FC\x3\x2"+
		"\x2\x2\x6FC\x701\a\x149\x2\x2\x6FD\x702\x5\x2E6\x174\x2\x6FE\x6FF\a\x160"+
		"\x2\x2\x6FF\x700\a\x15\x2\x2\x700\x702\a\x147\x2\x2\x701\x6FD\x3\x2\x2"+
		"\x2\x701\x6FE\x3\x2\x2\x2\x702\x70C\x3\x2\x2\x2\x703\x704\x5\f\a\x2\x704"+
		"\x705\x5\xB6\\\x2\x705\x70D\x3\x2\x2\x2\x706\x708\a\x91\x2\x2\x707\x709"+
		"\a\x1B2\x2\x2\x708\x707\x3\x2\x2\x2\x708\x709\x3\x2\x2\x2\x709\x70A\x3"+
		"\x2\x2\x2\x70A\x70B\a\xEF\x2\x2\x70B\x70D\x5\x202\x102\x2\x70C\x703\x3"+
		"\x2\x2\x2\x70C\x706\x3\x2\x2\x2\x70C\x70D\x3\x2\x2\x2\x70D\x9D\x3\x2\x2"+
		"\x2\x70E\x710\a\x97\x2\x2\x70F\x70E\x3\x2\x2\x2\x70F\x710\x3\x2\x2\x2"+
		"\x710\x712\x3\x2\x2\x2\x711\x713\a\xBC\x2\x2\x712\x711\x3\x2\x2\x2\x712"+
		"\x713\x3\x2\x2\x2\x713\x714\x3\x2\x2\x2\x714\x715\aM\x2\x2\x715\x716\a"+
		"\xA2\x2\x2\x716\x728\x5\x2E6\x174\x2\x717\x718\a\x1FE\x2\x2\x718\x719"+
		"\a\x160\x2\x2\x719\x71A\a\xAE\x2\x2\x71A\x71B\a\x11A\x2\x2\x71B\x71C\x5"+
		"\x2E6\x174\x2\x71C\x71D\a\x204\x2\x2\x71D\x71E\x3\x2\x2\x2\x71E\x723\x5"+
		"\xA6T\x2\x71F\x720\a\x204\x2\x2\x720\x722\x5\xA6T\x2\x721\x71F\x3\x2\x2"+
		"\x2\x722\x725\x3\x2\x2\x2\x723\x721\x3\x2\x2\x2\x723\x724\x3\x2\x2\x2"+
		"\x724\x726\x3\x2\x2\x2\x725\x723\x3\x2\x2\x2\x726\x727\a\x1FF\x2\x2\x727"+
		"\x729\x3\x2\x2\x2\x728\x717\x3\x2\x2\x2\x728\x729\x3\x2\x2\x2\x729\x72A"+
		"\x3\x2\x2\x2\x72A\x72B\a\x149\x2\x2\x72B\x72C\a\x160\x2\x2\x72C\x72D\a"+
		"\x15\x2\x2\x72D\x731\a\x147\x2\x2\x72E\x72F\x5\f\a\x2\x72F\x730\x5\xB6"+
		"\\\x2\x730\x732\x3\x2\x2\x2\x731\x72E\x3\x2\x2\x2\x731\x732\x3\x2\x2\x2"+
		"\x732\x9F\x3\x2\x2\x2\x733\x734\t\x11\x2\x2\x734\x735\a\xE3\x2\x2\x735"+
		"\x736\x5\x9CO\x2\x736\xA1\x3\x2\x2\x2\x737\x738\a\x132\x2\x2\x738\x739"+
		"\a\x146\x2\x2\x739\x73A\a\x1FE\x2\x2\x73A\x73F\x5\xA4S\x2\x73B\x73C\a"+
		"\x204\x2\x2\x73C\x73E\x5\xA4S\x2\x73D\x73B\x3\x2\x2\x2\x73E\x741\x3\x2"+
		"\x2\x2\x73F\x73D\x3\x2\x2\x2\x73F\x740\x3\x2\x2\x2\x740\x742\x3\x2\x2"+
		"\x2\x741\x73F\x3\x2\x2\x2\x742\x743\a\x1FF\x2\x2\x743\xA3\x3\x2\x2\x2"+
		"\x744\x747\x5\x2FC\x17F\x2\x745\x747\ak\x2\x2\x746\x744\x3\x2\x2\x2\x746"+
		"\x745\x3\x2\x2\x2\x747\xA5\x3\x2\x2\x2\x748\x749\x5\x2AE\x158\x2\x749"+
		"\x74A\x5\x2E6\x174\x2\x74A\xA7\x3\x2\x2\x2\x74B\x74C\ay\x2\x2\x74C\x74D"+
		"\a\x161\x2\x2\x74D\x74E\x5\x2BE\x160\x2\x74E\x74F\a\x20A\x2\x2\x74F\xA9"+
		"\x3\x2\x2\x2\x750\x751\a\x10\x2\x2\x751\x752\a\x161\x2\x2\x752\x754\x5"+
		"\x2BE\x160\x2\x753\x755\x5\xAEX\x2\x754\x753\x3\x2\x2\x2\x755\x756\x3"+
		"\x2\x2\x2\x756\x754\x3\x2\x2\x2\x756\x757\x3\x2\x2\x2\x757\x758\x3\x2"+
		"\x2\x2\x758\x759\a\x20A\x2\x2\x759\xAB\x3\x2\x2\x2\x75A\x75B\aV\x2\x2"+
		"\x75B\x75C\a\x161\x2\x2\x75C\x761\x5\x2BE\x160\x2\x75D\x760\x5\xB0Y\x2"+
		"\x75E\x760\x5\xAEX\x2\x75F\x75D\x3\x2\x2\x2\x75F\x75E\x3\x2\x2\x2\x760"+
		"\x763\x3\x2\x2\x2\x761\x75F\x3\x2\x2\x2\x761\x762\x3\x2\x2\x2\x762\x764"+
		"\x3\x2\x2\x2\x763\x761\x3\x2\x2\x2\x764\x765\a\x20A\x2\x2\x765\xAD\x3"+
		"\x2\x2\x2\x766\x767\a\xB1\x2\x2\x767\x768\a/\x2\x2\x768\x777\a\x1F8\x2"+
		"\x2\x769\x76A\a\xE1\x2\x2\x76A\x777\a\x1F8\x2\x2\x76B\x777\a\x100\x2\x2"+
		"\x76C\x76D\a\xE7\x2\x2\x76D\x777\a\x1F8\x2\x2\x76E\x777\a\x101\x2\x2\x76F"+
		"\x777\a]\x2\x2\x770\x777\a\xFE\x2\x2\x771\x772\a\x32\x2\x2\x772\x777\a"+
		"\x1F8\x2\x2\x773\x777\a\xFC\x2\x2\x774\x777\a\x117\x2\x2\x775\x777\a\x103"+
		"\x2\x2\x776\x766\x3\x2\x2\x2\x776\x769\x3\x2\x2\x2\x776\x76B\x3\x2\x2"+
		"\x2\x776\x76C\x3\x2\x2\x2\x776\x76E\x3\x2\x2\x2\x776\x76F\x3\x2\x2\x2"+
		"\x776\x770\x3\x2\x2\x2\x776\x771\x3\x2\x2\x2\x776\x773\x3\x2\x2\x2\x776"+
		"\x774\x3\x2\x2\x2\x776\x775\x3\x2\x2\x2\x777\xAF\x3\x2\x2\x2\x778\x779"+
		"\a\x17B\x2\x2\x779\x77A\a\x1BE\x2\x2\x77A\x77B\a\x1F8\x2\x2\x77B\xB1\x3"+
		"\x2\x2\x2\x77C\x77D\a\x1C\x2\x2\x77D\x77E\t\x14\x2\x2\x77E\xB3\x3\x2\x2"+
		"\x2\x77F\x780\x5\x2FC\x17F\x2\x780\x781\a\x215\x2\x2\x781\x782\x5\x202"+
		"\x102\x2\x782\xB5\x3\x2\x2\x2\x783\x786\a\xCA\x2\x2\x784\x787\x5\xB8]"+
		"\x2\x785\x787\x5\xBA^\x2\x786\x784\x3\x2\x2\x2\x786\x785\x3\x2\x2\x2\x787"+
		"\xB7\x3\x2\x2\x2\x788\x789\a\xC7\x2\x2\x789\x78A\a\xEF\x2\x2\x78A\x78B"+
		"\a\x1FA\x2\x2\x78B\xB9\x3\x2\x2\x2\x78C\x78F\a\x31\x2\x2\x78D\x78E\a\xEF"+
		"\x2\x2\x78E\x790\a\x1FA\x2\x2\x78F\x78D\x3\x2\x2\x2\x78F\x790\x3\x2\x2"+
		"\x2\x790\x791\x3\x2\x2\x2\x791\x792\a\xD0\x2\x2\x792\x794\x5\x2FC\x17F"+
		"\x2\x793\x795\x5\xBC_\x2\x794\x793\x3\x2\x2\x2\x794\x795\x3\x2\x2\x2\x795"+
		"\x798\x3\x2\x2\x2\x796\x797\a\x1BE\x2\x2\x797\x799\aO\x2\x2\x798\x796"+
		"\x3\x2\x2\x2\x798\x799\x3\x2\x2\x2\x799\x79B\x3\x2\x2\x2\x79A\x79C\x5"+
		"\xBE`\x2\x79B\x79A\x3\x2\x2\x2\x79B\x79C\x3\x2\x2\x2\x79C\xBB\x3\x2\x2"+
		"\x2\x79D\x79E\a\r\x2\x2\x79E\x79F\a\xAE\x2\x2\x79F\x7A0\a\x1FE\x2\x2\x7A0"+
		"\x7A5\x5\x202\x102\x2\x7A1\x7A2\a\x204\x2\x2\x7A2\x7A4\x5\x202\x102\x2"+
		"\x7A3\x7A1\x3\x2\x2\x2\x7A4\x7A7\x3\x2\x2\x2\x7A5\x7A3\x3\x2\x2\x2\x7A5"+
		"\x7A6\x3\x2\x2\x2\x7A6\x7A8\x3\x2\x2\x2\x7A7\x7A5\x3\x2\x2\x2\x7A8\x7A9"+
		"\a\x1FF\x2\x2\x7A9\xBD\x3\x2\x2\x2\x7AA\x7AB\a\x120\x2\x2\x7AB\x7B7\a"+
		"\x1FE\x2\x2\x7AC\x7B1\x5\x202\x102\x2\x7AD\x7AE\a\x204\x2\x2\x7AE\x7B0"+
		"\x5\x202\x102\x2\x7AF\x7AD\x3\x2\x2\x2\x7B0\x7B3\x3\x2\x2\x2\x7B1\x7AF"+
		"\x3\x2\x2\x2\x7B1\x7B2\x3\x2\x2\x2\x7B2\x7B8\x3\x2\x2\x2\x7B3\x7B1\x3"+
		"\x2\x2\x2\x7B4\x7B5\a\x1F7\x2\x2\x7B5\x7B6\a\x1F7\x2\x2\x7B6\x7B8\a\x1F7"+
		"\x2\x2\x7B7\x7AC\x3\x2\x2\x2\x7B7\x7B4\x3\x2\x2\x2\x7B8\x7B9\x3\x2\x2"+
		"\x2\x7B9\x7BA\a\x1FF\x2\x2\x7BA\xBF\x3\x2\x2\x2\x7BB\x7BF\x5\x2AE\x158"+
		"\x2\x7BC\x7BE\t\x15\x2\x2\x7BD\x7BC\x3\x2\x2\x2\x7BE\x7C1\x3\x2\x2\x2"+
		"\x7BF\x7BD\x3\x2\x2\x2\x7BF\x7C0\x3\x2\x2\x2\x7C0\x7C3\x3\x2\x2\x2\x7C1"+
		"\x7BF\x3\x2\x2\x2\x7C2\x7C4\x5\x2E6\x174\x2\x7C3\x7C2\x3\x2\x2\x2\x7C3"+
		"\x7C4\x3\x2\x2\x2\x7C4\x7C6\x3\x2\x2\x2\x7C5\x7C7\x5\xC2\x62\x2\x7C6\x7C5"+
		"\x3\x2\x2\x2\x7C6\x7C7\x3\x2\x2\x2\x7C7\xC1\x3\x2\x2\x2\x7C8\x7C9\t\x16"+
		"\x2\x2\x7C9\x7CA\x5\x202\x102\x2\x7CA\xC3\x3\x2\x2\x2\x7CB\x7D6\x5\xC6"+
		"\x64\x2\x7CC\x7D6\x5\xC8\x65\x2\x7CD\x7D6\x5\xCA\x66\x2\x7CE\x7D6\x5\xCE"+
		"h\x2\x7CF\x7D6\x5\xD0i\x2\x7D0\x7D6\x5\xD2j\x2\x7D1\x7D6\x5\xDAn\x2\x7D2"+
		"\x7D6\x5\x32\x1A\x2\x7D3\x7D6\x5\x12\n\x2\x7D4\x7D6\x5\x288\x145\x2\x7D5"+
		"\x7CB\x3\x2\x2\x2\x7D5\x7CC\x3\x2\x2\x2\x7D5\x7CD\x3\x2\x2\x2\x7D5\x7CE"+
		"\x3\x2\x2\x2\x7D5\x7CF\x3\x2\x2\x2\x7D5\x7D0\x3\x2\x2\x2\x7D5\x7D1\x3"+
		"\x2\x2\x2\x7D5\x7D2\x3\x2\x2\x2\x7D5\x7D3\x3\x2\x2\x2\x7D5\x7D4\x3\x2"+
		"\x2\x2\x7D6\xC5\x3\x2\x2\x2\x7D7\x7D9\x5\x2C8\x165\x2\x7D8\x7DA\aJ\x2"+
		"\x2\x7D9\x7D8\x3\x2\x2\x2\x7D9\x7DA\x3\x2\x2\x2\x7DA\x7DB\x3\x2\x2\x2"+
		"\x7DB\x7DE\x5\x2E6\x174\x2\x7DC\x7DD\a\x105\x2\x2\x7DD\x7DF\a\x107\x2"+
		"\x2\x7DE\x7DC\x3\x2\x2\x2\x7DE\x7DF\x3\x2\x2\x2\x7DF\x7E1\x3\x2\x2\x2"+
		"\x7E0\x7E2\x5\xC2\x62\x2\x7E1\x7E0\x3\x2\x2\x2\x7E1\x7E2\x3\x2\x2\x2\x7E2"+
		"\x7E3\x3\x2\x2\x2\x7E3\x7E4\a\x20A\x2\x2\x7E4\xC7\x3\x2\x2\x2\x7E5\x7E6"+
		"\a\x185\x2\x2\x7E6\x7E7\x5\x2BC\x15F\x2\x7E7\x7E8\a\xC4\x2\x2\x7E8\x7EE"+
		"\x5\x2E6\x174\x2\x7E9\x7EA\a\x139\x2\x2\x7EA\x7EB\x5\x202\x102\x2\x7EB"+
		"\x7EC\a\x3\x2\x2\x7EC\x7ED\x5\x202\x102\x2\x7ED\x7EF\x3\x2\x2\x2\x7EE"+
		"\x7E9\x3\x2\x2\x2\x7EE\x7EF\x3\x2\x2\x2\x7EF\x7F2\x3\x2\x2\x2\x7F0\x7F1"+
		"\a\x105\x2\x2\x7F1\x7F3\a\x107\x2\x2\x7F2\x7F0\x3\x2\x2\x2\x7F2\x7F3\x3"+
		"\x2\x2\x2\x7F3\x7F4\x3\x2\x2\x2\x7F4\x7F5\a\x20A\x2\x2\x7F5\xC9\x3\x2"+
		"\x2\x2\x7F6\x7F7\a[\x2\x2\x7F7\x803\x5\x2CC\x167\x2\x7F8\x7F9\a\x1FE\x2"+
		"\x2\x7F9\x7FE\x5\xCCg\x2\x7FA\x7FB\a\x204\x2\x2\x7FB\x7FD\x5\xCCg\x2\x7FC"+
		"\x7FA\x3\x2\x2\x2\x7FD\x800\x3\x2\x2\x2\x7FE\x7FC\x3\x2\x2\x2\x7FE\x7FF"+
		"\x3\x2\x2\x2\x7FF\x801\x3\x2\x2\x2\x800\x7FE\x3\x2\x2\x2\x801\x802\a\x1FF"+
		"\x2\x2\x802\x804\x3\x2\x2\x2\x803\x7F8\x3\x2\x2\x2\x803\x804\x3\x2\x2"+
		"\x2\x804\x807\x3\x2\x2\x2\x805\x806\a\x149\x2\x2\x806\x808\x5\x2E6\x174"+
		"\x2\x807\x805\x3\x2\x2\x2\x807\x808\x3\x2\x2\x2\x808\x80B\x3\x2\x2\x2"+
		"\x809\x80A\a\xC4\x2\x2\x80A\x80C\x5\x13E\xA0\x2\x80B\x809\x3\x2\x2\x2"+
		"\x80B\x80C\x3\x2\x2\x2\x80C\x80D\x3\x2\x2\x2\x80D\x80E\a\x20A\x2\x2\x80E"+
		"\xCB\x3\x2\x2\x2\x80F\x814\x5\x2AE\x158\x2\x810\x812\a\xAE\x2\x2\x811"+
		"\x810\x3\x2\x2\x2\x811\x812\x3\x2\x2\x2\x812\x813\x3\x2\x2\x2\x813\x815"+
		"\x5\x2E6\x174\x2\x814\x811\x3\x2\x2\x2\x814\x815\x3\x2\x2\x2\x815\x817"+
		"\x3\x2\x2\x2\x816\x818\x5\xC2\x62\x2\x817\x816\x3\x2\x2\x2\x817\x818\x3"+
		"\x2\x2\x2\x818\xCD\x3\x2\x2\x2\x819\x81A\x5\x2C0\x161\x2\x81A\x81B\a\x88"+
		"\x2\x2\x81B\x81C\a\x20A\x2\x2\x81C\xCF\x3\x2\x2\x2\x81D\x83F\a\x132\x2"+
		"\x2\x81E\x840\a\x164\x2\x2\x81F\x840\a\x1F\x2\x2\x820\x821\a\x89\x2\x2"+
		"\x821\x822\a\x1FE\x2\x2\x822\x823\x5\x2C0\x161\x2\x823\x825\a\x204\x2"+
		"\x2\x824\x826\a\x203\x2\x2\x825\x824\x3\x2\x2\x2\x825\x826\x3\x2\x2\x2"+
		"\x826\x827\x3\x2\x2\x2\x827\x828\x5\x2F8\x17D\x2\x828\x829\a\x1FF\x2\x2"+
		"\x829\x840\x3\x2\x2\x2\x82A\x82B\a\xB8\x2\x2\x82B\x82C\a\x1FE\x2\x2\x82C"+
		"\x82D\x5\x2FC\x17F\x2\x82D\x82E\a\x204\x2\x2\x82E\x82F\x5\x202\x102\x2"+
		"\x82F\x830\a\x1FF\x2\x2\x830\x840\x3\x2\x2\x2\x831\x832\a\x146\x2\x2\x832"+
		"\x835\a\x1FE\x2\x2\x833\x836\x5\x2FC\x17F\x2\x834\x836\ak\x2\x2\x835\x833"+
		"\x3\x2\x2\x2\x835\x834\x3\x2\x2\x2\x836\x839\x3\x2\x2\x2\x837\x838\a\x204"+
		"\x2\x2\x838\x83A\x5\x2FC\x17F\x2\x839\x837\x3\x2\x2\x2\x83A\x83B\x3\x2"+
		"\x2\x2\x83B\x839\x3\x2\x2\x2\x83B\x83C\x3\x2\x2\x2\x83C\x83D\x3\x2\x2"+
		"\x2\x83D\x83E\a\x1FF\x2\x2\x83E\x840\x3\x2\x2\x2\x83F\x81E\x3\x2\x2\x2"+
		"\x83F\x81F\x3\x2\x2\x2\x83F\x820\x3\x2\x2\x2\x83F\x82A\x3\x2\x2\x2\x83F"+
		"\x831\x3\x2\x2\x2\x840\x841\x3\x2\x2\x2\x841\x842\a\x20A\x2\x2\x842\xD1"+
		"\x3\x2\x2\x2\x843\x846\x5\xD4k\x2\x844\x846\x5\xD8m\x2\x845\x843\x3\x2"+
		"\x2\x2\x845\x844\x3\x2\x2\x2\x846\xD3\x3\x2\x2\x2\x847\x848\a\x19F\x2"+
		"\x2\x848\x849\x5\x2BC\x15F\x2\x849\x85C\a\xC4\x2\x2\x84A\x84B\a\x13D\x2"+
		"\x2\x84B\x84C\a\x1FE\x2\x2\x84C\x851\x5\xD6l\x2\x84D\x84E\a\x204\x2\x2"+
		"\x84E\x850\x5\xD6l\x2\x84F\x84D\x3\x2\x2\x2\x850\x853\x3\x2\x2\x2\x851"+
		"\x84F\x3\x2\x2\x2\x851\x852\x3\x2\x2\x2\x852\x854\x3\x2\x2\x2\x853\x851"+
		"\x3\x2\x2\x2\x854\x855\a\x1FF\x2\x2\x855\x85D\x3\x2\x2\x2\x856\x857\a"+
		"\x13E\x2\x2\x857\x85A\a[\x2\x2\x858\x859\a\x149\x2\x2\x859\x85B\x5\x2E6"+
		"\x174\x2\x85A\x858\x3\x2\x2\x2\x85A\x85B\x3\x2\x2\x2\x85B\x85D\x3\x2\x2"+
		"\x2\x85C\x84A\x3\x2\x2\x2\x85C\x856\x3\x2\x2\x2\x85D\x85E\x3\x2\x2\x2"+
		"\x85E\x85F\a\x20A\x2\x2\x85F\xD5\x3\x2\x2\x2\x860\x862\x5\x2D4\x16B\x2"+
		"\x861\x863\x5\x2E6\x174\x2\x862\x861\x3\x2\x2\x2\x862\x863\x3\x2\x2\x2"+
		"\x863\x866\x3\x2\x2\x2\x864\x865\a\x105\x2\x2\x865\x867\a\x107\x2\x2\x866"+
		"\x864\x3\x2\x2\x2\x866\x867\x3\x2\x2\x2\x867\x869\x3\x2\x2\x2\x868\x86A"+
		"\x5\xC2\x62\x2\x869\x868\x3\x2\x2\x2\x869\x86A\x3\x2\x2\x2\x86A\xD7\x3"+
		"\x2\x2\x2\x86B\x86C\x5\x2CE\x168\x2\x86C\x86F\x5\x2BC\x15F\x2\x86D\x86E"+
		"\a\x206\x2\x2\x86E\x870\x5\x2D2\x16A\x2\x86F\x86D\x3\x2\x2\x2\x86F\x870"+
		"\x3\x2\x2\x2\x870\x876\x3\x2\x2\x2\x871\x877\a\x126\x2\x2\x872\x874\a"+
		"\x127\x2\x2\x873\x875\x5\xC2\x62\x2\x874\x873\x3\x2\x2\x2\x874\x875\x3"+
		"\x2\x2\x2\x875\x877\x3\x2\x2\x2\x876\x871\x3\x2\x2\x2\x876\x872\x3\x2"+
		"\x2\x2\x877\x878\x3\x2\x2\x2\x878\x879\a\x20A\x2\x2\x879\xD9\x3\x2\x2"+
		"\x2\x87A\x87D\x5\xDCo\x2\x87B\x87D\x5\xE2r\x2\x87C\x87A\x3\x2\x2\x2\x87C"+
		"\x87B\x3\x2\x2\x2\x87D\x87E\x3\x2\x2\x2\x87E\x87F\a\x20A\x2\x2\x87F\xDB"+
		"\x3\x2\x2\x2\x880\x881\a\x19F\x2\x2\x881\x882\x5\x2BC\x15F\x2\x882\x88E"+
		"\a\xC4\x2\x2\x883\x884\a\x188\x2\x2\x884\x885\a\x10D\x2\x2\x885\x887\x5"+
		"\x2E6\x174\x2\x886\x888\x5\xDEp\x2\x887\x886\x3\x2\x2\x2\x887\x888\x3"+
		"\x2\x2\x2\x888\x88B\x3\x2\x2\x2\x889\x88A\a\x105\x2\x2\x88A\x88C\a\x107"+
		"\x2\x2\x88B\x889\x3\x2\x2\x2\x88B\x88C\x3\x2\x2\x2\x88C\x88F\x3\x2\x2"+
		"\x2\x88D\x88F\x5\xE0q\x2\x88E\x883\x3\x2\x2\x2\x88E\x88D\x3\x2\x2\x2\x88F"+
		"\xDD\x3\x2\x2\x2\x890\x893\a\xB4\x2\x2\x891\x893\a\xB3\x2\x2\x892\x890"+
		"\x3\x2\x2\x2\x892\x891\x3\x2\x2\x2\x893\x894\x3\x2\x2\x2\x894\x895\a/"+
		"\x2\x2\x895\x896\x5\x2E6\x174\x2\x896\xDF\x3\x2\x2\x2\x897\x89B\a\x1B3"+
		"\x2\x2\x898\x899\a\x1B4\x2\x2\x899\x89B\a\x14\x2\x2\x89A\x897\x3\x2\x2"+
		"\x2\x89A\x898\x3\x2\x2\x2\x89B\x89C\x3\x2\x2\x2\x89C\x89D\a\x1FE\x2\x2"+
		"\x89D\x89E\x5\x202\x102\x2\x89E\x89F\a\x1FF\x2\x2\x89F\x8A0\a\x10D\x2"+
		"\x2\x8A0\x8A3\x5\x2E6\x174\x2\x8A1\x8A2\a\x105\x2\x2\x8A2\x8A4\a\x107"+
		"\x2\x2\x8A3\x8A1\x3\x2\x2\x2\x8A3\x8A4\x3\x2\x2\x2\x8A4\xE1\x3\x2\x2\x2"+
		"\x8A5\x8A6\x5\x2A4\x153\x2\x8A6\x8A7\x5\x2E6\x174\x2\x8A7\xE3\x3\x2\x2"+
		"\x2\x8A8\x8A9\x5\xE8u\x2\x8A9\x8AA\a\x20A\x2\x2\x8AA\x8AE\x3\x2\x2\x2"+
		"\x8AB\x8AE\x5\xE6t\x2\x8AC\x8AE\x5\x288\x145\x2\x8AD\x8A8\x3\x2\x2\x2"+
		"\x8AD\x8AB\x3\x2\x2\x2\x8AD\x8AC\x3\x2\x2\x2\x8AE\x8AF\x3\x2\x2\x2\x8AF"+
		"\x8AD\x3\x2\x2\x2\x8AF\x8B0\x3\x2\x2\x2\x8B0\xE5\x3\x2\x2\x2\x8B1\x8B2"+
		"\a\x20C\x2\x2\x8B2\x8B3\a\x20C\x2\x2\x8B3\x8B4\x5\x2BA\x15E\x2\x8B4\x8B5"+
		"\a\x212\x2\x2\x8B5\x8B6\a\x212\x2\x2\x8B6\xE7\x3\x2\x2\x2\x8B7\x8B8\a"+
		"V\x2\x2\x8B8\x8D3\x5\x2\x2\x2\x8B9\x8BA\a\x10\x2\x2\x8BA\x8D3\x5\x2\x2"+
		"\x2\x8BB\x8BC\a\xA4\x2\x2\x8BC\x8D3\x5\x2\x2\x2\x8BD\x8BE\a\x19E\x2\x2"+
		"\x8BE\x8D3\x5\x2\x2\x2\x8BF\x8C0\a\x132\x2\x2\x8C0\x8D3\x5\x2\x2\x2\x8C1"+
		"\x8D3\x5\x10E\x88\x2\x8C2\x8D3\x5\x11A\x8E\x2\x8C3\x8D3\x5\xEAv\x2\x8C4"+
		"\x8D3\x5\xECw\x2\x8C5\x8D3\x5\xEEx\x2\x8C6\x8D3\x5\xF0y\x2\x8C7\x8D3\x5"+
		"\xF2z\x2\x8C8\x8D3\x5\xF8}\x2\x8C9\x8D3\x5\xFC\x7F\x2\x8CA\x8D3\x5\x106"+
		"\x84\x2\x8CB\x8D3\x5\x108\x85\x2\x8CC\x8D3\x5\x10A\x86\x2\x8CD\x8D3\x5"+
		"\x238\x11D\x2\x8CE\x8D3\x5\x11C\x8F\x2\x8CF\x8D3\x5\x10C\x87\x2\x8D0\x8D3"+
		"\x5\x112\x8A\x2\x8D1\x8D3\x5\x110\x89\x2\x8D2\x8B7\x3\x2\x2\x2\x8D2\x8B9"+
		"\x3\x2\x2\x2\x8D2\x8BB\x3\x2\x2\x2\x8D2\x8BD\x3\x2\x2\x2\x8D2\x8BF\x3"+
		"\x2\x2\x2\x8D2\x8C1\x3\x2\x2\x2\x8D2\x8C2\x3\x2\x2\x2\x8D2\x8C3\x3\x2"+
		"\x2\x2\x8D2\x8C4\x3\x2\x2\x2\x8D2\x8C5\x3\x2\x2\x2\x8D2\x8C6\x3\x2\x2"+
		"\x2\x8D2\x8C7\x3\x2\x2\x2\x8D2\x8C8\x3\x2\x2\x2\x8D2\x8C9\x3\x2\x2\x2"+
		"\x8D2\x8CA\x3\x2\x2\x2\x8D2\x8CB\x3\x2\x2\x2\x8D2\x8CC\x3\x2\x2\x2\x8D2"+
		"\x8CD\x3\x2\x2\x2\x8D2\x8CE\x3\x2\x2\x2\x8D2\x8CF\x3\x2\x2\x2\x8D2\x8D0"+
		"\x3\x2\x2\x2\x8D2\x8D1\x3\x2\x2\x2\x8D3\xE9\x3\x2\x2\x2\x8D4\x8D8\x5\x1F8"+
		"\xFD\x2\x8D5\x8D8\x5\x2F0\x179\x2\x8D6\x8D8\x5\x2EE\x178\x2\x8D7\x8D4"+
		"\x3\x2\x2\x2\x8D7\x8D5\x3\x2\x2\x2\x8D7\x8D6\x3\x2\x2\x2\x8D8\x8D9\x3"+
		"\x2\x2\x2\x8D9\x8DA\a\x207\x2\x2\x8DA\x8DB\x5\x202\x102\x2\x8DB\xEB\x3"+
		"\x2\x2\x2\x8DC\x8DE\aP\x2\x2\x8DD\x8DF\x5\x2BA\x15E\x2\x8DE\x8DD\x3\x2"+
		"\x2\x2\x8DE\x8DF\x3\x2\x2\x2\x8DF\x8E2\x3\x2\x2\x2\x8E0\x8E1\a\x1BA\x2"+
		"\x2\x8E1\x8E3\x5\x1FE\x100\x2\x8E2\x8E0\x3\x2\x2\x2\x8E2\x8E3\x3\x2\x2"+
		"\x2\x8E3\xED\x3\x2\x2\x2\x8E4\x8E6\a\x8F\x2\x2\x8E5\x8E7\x5\x2BA\x15E"+
		"\x2\x8E6\x8E5\x3\x2\x2\x2\x8E6\x8E7\x3\x2\x2\x2\x8E7\x8EA\x3\x2\x2\x2"+
		"\x8E8\x8E9\a\x1BA\x2\x2\x8E9\x8EB\x5\x1FE\x100\x2\x8EA\x8E8\x3\x2\x2\x2"+
		"\x8EA\x8EB\x3\x2\x2\x2\x8EB\xEF\x3\x2\x2\x2\x8EC\x8ED\a\xA3\x2\x2\x8ED"+
		"\x8EE\x5\x2BA\x15E\x2\x8EE\xF1\x3\x2\x2\x2\x8EF\x8F0\a\xAB\x2\x2\x8F0"+
		"\x8F1\x5\x1FE\x100\x2\x8F1\x8F2\a\x18A\x2\x2\x8F2\x8F6\x5\xE4s\x2\x8F3"+
		"\x8F5\x5\xF4{\x2\x8F4\x8F3\x3\x2\x2\x2\x8F5\x8F8\x3\x2\x2\x2\x8F6\x8F4"+
		"\x3\x2\x2\x2\x8F6\x8F7\x3\x2\x2\x2\x8F7\x8FA\x3\x2\x2\x2\x8F8\x8F6\x3"+
		"\x2\x2\x2\x8F9\x8FB\x5\xF6|\x2\x8FA\x8F9\x3\x2\x2\x2\x8FA\x8FB\x3\x2\x2"+
		"\x2\x8FB\x8FC\x3\x2\x2\x2\x8FC\x8FD\a\x82\x2\x2\x8FD\x8FE\a\xAB\x2\x2"+
		"\x8FE\xF3\x3\x2\x2\x2\x8FF\x900\a~\x2\x2\x900\x901\x5\x1FE\x100\x2\x901"+
		"\x902\a\x18A\x2\x2\x902\x903\x5\xE4s\x2\x903\xF5\x3\x2\x2\x2\x904\x905"+
		"\a}\x2\x2\x905\x906\x5\xE4s\x2\x906\xF7\x3\x2\x2\x2\x907\x909\x5\x2BA"+
		"\x15E\x2\x908\x907\x3\x2\x2\x2\x908\x909\x3\x2\x2\x2\x909\x90E\x3\x2\x2"+
		"\x2\x90A\x90B\a\x1BD\x2\x2\x90B\x90F\x5\x1FE\x100\x2\x90C\x90D\a\x9D\x2"+
		"\x2\x90D\x90F\x5\xFA~\x2\x90E\x90A\x3\x2\x2\x2\x90E\x90C\x3\x2\x2\x2\x90E"+
		"\x90F\x3\x2\x2\x2\x90F\x910\x3\x2\x2\x2\x910\x911\a\xDD\x2\x2\x911\x912"+
		"\x5\xE4s\x2\x912\x913\a\x82\x2\x2\x913\x915\a\xDD\x2\x2\x914\x916\x5\x2BA"+
		"\x15E\x2\x915\x914\x3\x2\x2\x2\x915\x916\x3\x2\x2\x2\x916\xF9\x3\x2\x2"+
		"\x2\x917\x918\x5\x2CA\x166\x2\x918\x91A\a\xAE\x2\x2\x919\x91B\a\x14C\x2"+
		"\x2\x91A\x919\x3\x2\x2\x2\x91A\x91B\x3\x2\x2\x2\x91B\x91C\x3\x2\x2\x2"+
		"\x91C\x91D\x5\x102\x82\x2\x91D\x91E\a\x3\x2\x2\x91E\x91F\x5\x104\x83\x2"+
		"\x91F\x92D\x3\x2\x2\x2\x920\x921\x5\x2CE\x168\x2\x921\x92A\a\xAE\x2\x2"+
		"\x922\x924\x5\x2CC\x167\x2\x923\x925\x5\x1FC\xFF\x2\x924\x923\x3\x2\x2"+
		"\x2\x924\x925\x3\x2\x2\x2\x925\x92B\x3\x2\x2\x2\x926\x927\a\x1FE\x2\x2"+
		"\x927\x928\x5\x13E\xA0\x2\x928\x929\a\x1FF\x2\x2\x929\x92B\x3\x2\x2\x2"+
		"\x92A\x922\x3\x2\x2\x2\x92A\x926\x3\x2\x2\x2\x92B\x92D\x3\x2\x2\x2\x92C"+
		"\x917\x3\x2\x2\x2\x92C\x920\x3\x2\x2\x2\x92D\xFB\x3\x2\x2\x2\x92E\x92F"+
		"\a\x9E\x2\x2\x92F\x930\x5\x2CA\x166\x2\x930\x931\a\xAE\x2\x2\x931\x932"+
		"\x5\xFE\x80\x2\x932\x935\x5\x11C\x8F\x2\x933\x934\a\x156\x2\x2\x934\x936"+
		"\a\x8A\x2\x2\x935\x933\x3\x2\x2\x2\x935\x936\x3\x2\x2\x2\x936\xFD\x3\x2"+
		"\x2\x2\x937\x938\x5\x102\x82\x2\x938\x939\a\x3\x2\x2\x939\x93A\x5\x104"+
		"\x83\x2\x93A\x945\x3\x2\x2\x2\x93B\x93C\a\xB6\x2\x2\x93C\x93D\a\x10D\x2"+
		"\x2\x93D\x93F\x5\x2D0\x169\x2\x93E\x940\x5\x100\x81\x2\x93F\x93E\x3\x2"+
		"\x2\x2\x93F\x940\x3\x2\x2\x2\x940\x945\x3\x2\x2\x2\x941\x942\a\x1AF\x2"+
		"\x2\x942\x943\a\x10D\x2\x2\x943\x945\x5\x2CA\x166\x2\x944\x937\x3\x2\x2"+
		"\x2\x944\x93B\x3\x2\x2\x2\x944\x941\x3\x2\x2\x2\x945\xFF\x3\x2\x2\x2\x946"+
		"\x947\a#\x2\x2\x947\x948\x5\x102\x82\x2\x948\x949\a\x12\x2\x2\x949\x94A"+
		"\x5\x104\x83\x2\x94A\x101\x3\x2\x2\x2\x94B\x94C\x5\x21E\x110\x2\x94C\x103"+
		"\x3\x2\x2\x2\x94D\x94E\x5\x21E\x110\x2\x94E\x105\x3\x2\x2\x2\x94F\x950"+
		"\a\x107\x2\x2\x950\x107\x3\x2\x2\x2\x951\x953\a\x138\x2\x2\x952\x954\x5"+
		"\x2C0\x161\x2\x953\x952\x3\x2\x2\x2\x953\x954\x3\x2\x2\x2\x954\x109\x3"+
		"\x2\x2\x2\x955\x957\a\x149\x2\x2\x956\x958\x5\x1FE\x100\x2\x957\x956\x3"+
		"\x2\x2\x2\x957\x958\x3\x2\x2\x2\x958\x10B\x3\x2\x2\x2\x959\x95B\a\x33"+
		"\x2\x2\x95A\x959\x3\x2\x2\x2\x95A\x95B\x3\x2\x2\x2\x95B\x95C\x3\x2\x2"+
		"\x2\x95C\x95E\x5\x2A8\x155\x2\x95D\x95F\x5\x2DC\x16F\x2\x95E\x95D\x3\x2"+
		"\x2\x2\x95E\x95F\x3\x2\x2\x2\x95F\x10D\x3\x2\x2\x2\x960\x961\a\"\x2\x2"+
		"\x961\x963\x5\xE4s\x2\x962\x964\x5\x114\x8B\x2\x963\x962\x3\x2\x2\x2\x963"+
		"\x964\x3\x2\x2\x2\x964\x965\x3\x2\x2\x2\x965\x967\a\x82\x2\x2\x966\x968"+
		"\x5\x2BA\x15E\x2\x967\x966\x3\x2\x2\x2\x967\x968\x3\x2\x2\x2\x968\x10F"+
		"\x3\x2\x2\x2\x969\x96A\x5\x1F8\xFD\x2\x96A\x96B\a\x1F7\x2\x2\x96B\x975"+
		"\ao\x2\x2\x96C\x972\a\x1FE\x2\x2\x96D\x970\x5\x202\x102\x2\x96E\x96F\a"+
		"\x204\x2\x2\x96F\x971\x5\x202\x102\x2\x970\x96E\x3\x2\x2\x2\x970\x971"+
		"\x3\x2\x2\x2\x971\x973\x3\x2\x2\x2\x972\x96D\x3\x2\x2\x2\x972\x973\x3"+
		"\x2\x2\x2\x973\x974\x3\x2\x2\x2\x974\x976\a\x1FF\x2\x2\x975\x96C\x3\x2"+
		"\x2\x2\x975\x976\x3\x2\x2\x2\x976\x990\x3\x2\x2\x2\x977\x978\x5\x1F8\xFD"+
		"\x2\x978\x979\a\x1F7\x2\x2\x979\x983\a\x92\x2\x2\x97A\x980\a\x1FE\x2\x2"+
		"\x97B\x97E\x5\x202\x102\x2\x97C\x97D\a\x204\x2\x2\x97D\x97F\x5\x202\x102"+
		"\x2\x97E\x97C\x3\x2\x2\x2\x97E\x97F\x3\x2\x2\x2\x97F\x981\x3\x2\x2\x2"+
		"\x980\x97B\x3\x2\x2\x2\x980\x981\x3\x2\x2\x2\x981\x982\x3\x2\x2\x2\x982"+
		"\x984\a\x1FF\x2\x2\x983\x97A\x3\x2\x2\x2\x983\x984\x3\x2\x2\x2\x984\x990"+
		"\x3\x2\x2\x2\x985\x986\x5\x1F8\xFD\x2\x986\x987\a\x1F7\x2\x2\x987\x98D"+
		"\a\x19C\x2\x2\x988\x98A\a\x1FE\x2\x2\x989\x98B\x5\x202\x102\x2\x98A\x989"+
		"\x3\x2\x2\x2\x98A\x98B\x3\x2\x2\x2\x98B\x98C\x3\x2\x2\x2\x98C\x98E\a\x1FF"+
		"\x2\x2\x98D\x988\x3\x2\x2\x2\x98D\x98E\x3\x2\x2\x2\x98E\x990\x3\x2\x2"+
		"\x2\x98F\x969\x3\x2\x2\x2\x98F\x977\x3\x2\x2\x2\x98F\x985\x3\x2\x2\x2"+
		"\x990\x111\x3\x2\x2\x2\x991\x992\a\x12C\x2\x2\x992\x993\a\x151\x2\x2\x993"+
		"\x994\a\x1FE\x2\x2\x994\x995\x5\x202\x102\x2\x995\x996\a\x1FF\x2\x2\x996"+
		"\x113\x3\x2\x2\x2\x997\x999\a\x88\x2\x2\x998\x99A\x5\x116\x8C\x2\x999"+
		"\x998\x3\x2\x2\x2\x99A\x99B\x3\x2\x2\x2\x99B\x999\x3\x2\x2\x2\x99B\x99C"+
		"\x3\x2\x2\x2\x99C\x115\x3\x2\x2\x2\x99D\x99E\a\x1BA\x2\x2\x99E\x9A3\x5"+
		"\x2C0\x161\x2\x99F\x9A0\a\x115\x2\x2\x9A0\x9A2\x5\x2C0\x161\x2\x9A1\x99F"+
		"\x3\x2\x2\x2\x9A2\x9A5\x3\x2\x2\x2\x9A3\x9A1\x3\x2\x2\x2\x9A3\x9A4\x3"+
		"\x2\x2\x2\x9A4\x9A6\x3\x2\x2\x2\x9A5\x9A3\x3\x2\x2\x2\x9A6\x9A7\a\x18A"+
		"\x2\x2\x9A7\x9A8\x5\xE4s\x2\x9A8\x117\x3\x2\x2\x2\x9A9\x9AB\x5\n\x6\x2"+
		"\x9AA\x9A9\x3\x2\x2\x2\x9AA\x9AB\x3\x2\x2\x2\x9AB\x9AC\x3\x2\x2\x2\x9AC"+
		"\x9AD\x5\x10E\x88\x2\x9AD\x119\x3\x2\x2\x2\x9AE\x9B0\x5\n\x6\x2\x9AF\x9AE"+
		"\x3\x2\x2\x2\x9AF\x9B0\x3\x2\x2\x2\x9B0\x9B1\x3\x2\x2\x2\x9B1\x9B2\x5"+
		"\x10E\x88\x2\x9B2\x11B\x3\x2\x2\x2\x9B3\x9B8\x5\x11E\x90\x2\x9B4\x9B8"+
		"\x5\x122\x92\x2\x9B5\x9B8\x5\x124\x93\x2\x9B6\x9B8\x5\x12E\x98\x2\x9B7"+
		"\x9B3\x3\x2\x2\x2\x9B7\x9B4\x3\x2\x2\x2\x9B7\x9B5\x3\x2\x2\x2\x9B7\x9B6"+
		"\x3\x2\x2\x2\x9B8\x11D\x3\x2\x2\x2\x9B9\x9BA\a\x8D\x2\x2\x9BA\x9BB\a\xAD"+
		"\x2\x2\x9BB\x9C5\x5\x202\x102\x2\x9BC\x9BE\x5\x298\x14D\x2\x9BD\x9BF\x5"+
		"\x264\x133\x2\x9BE\x9BD\x3\x2\x2\x2\x9BE\x9BF\x3\x2\x2\x2\x9BF\x9C6\x3"+
		"\x2\x2\x2\x9C0\x9C2\x5\x264\x133\x2\x9C1\x9C3\x5\x120\x91\x2\x9C2\x9C1"+
		"\x3\x2\x2\x2\x9C2\x9C3\x3\x2\x2\x2\x9C3\x9C6\x3\x2\x2\x2\x9C4\x9C6\x5"+
		"\x120\x91\x2\x9C5\x9BC\x3\x2\x2\x2\x9C5\x9C0\x3\x2\x2\x2\x9C5\x9C4\x3"+
		"\x2\x2\x2\x9C5\x9C6\x3\x2\x2\x2\x9C6\x11F\x3\x2\x2\x2\x9C7\x9C8\t\x17"+
		"\x2\x2\x9C8\x9C9\x5\x298\x14D\x2\x9C9\x121\x3\x2\x2\x2\x9CA\x9D2\x5\x1CC"+
		"\xE7\x2\x9CB\x9D2\x5\x1D8\xED\x2\x9CC\x9D2\x5\x13E\xA0\x2\x9CD\x9D2\x5"+
		"\x1B2\xDA\x2\x9CE\x9D2\x5\x1B8\xDD\x2\x9CF\x9D2\x5\x1BA\xDE\x2\x9D0\x9D2"+
		"\x5\x13C\x9F\x2\x9D1\x9CA\x3\x2\x2\x2\x9D1\x9CB\x3\x2\x2\x2\x9D1\x9CC"+
		"\x3\x2\x2\x2\x9D1\x9CD\x3\x2\x2\x2\x9D1\x9CE\x3\x2\x2\x2\x9D1\x9CF\x3"+
		"\x2\x2\x2\x9D1\x9D0\x3\x2\x2\x2\x9D2\x123\x3\x2\x2\x2\x9D3\x9D8\x5\x126"+
		"\x94\x2\x9D4\x9D8\x5\x128\x95\x2\x9D5\x9D8\x5\x12A\x96\x2\x9D6\x9D8\x5"+
		"\x12C\x97\x2\x9D7\x9D3\x3\x2\x2\x2\x9D7\x9D4\x3\x2\x2\x2\x9D7\x9D5\x3"+
		"\x2\x2\x2\x9D7\x9D6\x3\x2\x2\x2\x9D8\x125\x3\x2\x2\x2\x9D9\x9DA\a>\x2"+
		"\x2\x9DA\x9DB\x5\x2CC\x167\x2\x9DB\x127\x3\x2\x2\x2\x9DC\x9DD\a\x113\x2"+
		"\x2\x9DD\x9DF\x5\x2CC\x167\x2\x9DE\x9E0\x5\x1FC\xFF\x2\x9DF\x9DE\x3\x2"+
		"\x2\x2\x9DF\x9E0\x3\x2\x2\x2\x9E0\x129\x3\x2\x2\x2\x9E1\x9E2\a\x96\x2"+
		"\x2\x9E2\x9FE\x5\x2CC\x167\x2\x9E3\x9E4\a\xC2\x2\x2\x9E4\x9E9\x5\x2C8"+
		"\x165\x2\x9E5\x9E6\a\x204\x2\x2\x9E6\x9E8\x5\x2C8\x165\x2\x9E7\x9E5\x3"+
		"\x2\x2\x2\x9E8\x9EB\x3\x2\x2\x2\x9E9\x9E7\x3\x2\x2\x2\x9E9\x9EA\x3\x2"+
		"\x2\x2\x9EA\x9FF\x3\x2\x2\x2\x9EB\x9E9\x3\x2\x2\x2\x9EC\x9ED\a.\x2\x2"+
		"\x9ED\x9EE\a@\x2\x2\x9EE\x9EF\a\xC2\x2\x2\x9EF\x9F4\x5\x2C8\x165\x2\x9F0"+
		"\x9F1\a\x204\x2\x2\x9F1\x9F3\x5\x2C8\x165\x2\x9F2\x9F0\x3\x2\x2\x2\x9F3"+
		"\x9F6\x3\x2\x2\x2\x9F4\x9F2\x3\x2\x2\x2\x9F4\x9F5\x3\x2\x2\x2\x9F5\x9FC"+
		"\x3\x2\x2\x2\x9F6\x9F4\x3\x2\x2\x2\x9F7\x9FA\a\xD5\x2\x2\x9F8\x9FB\x5"+
		"\x2C8\x165\x2\x9F9\x9FB\x5\x2F8\x17D\x2\x9FA\x9F8\x3\x2\x2\x2\x9FA\x9F9"+
		"\x3\x2\x2\x2\x9FB\x9FD\x3\x2\x2\x2\x9FC\x9F7\x3\x2\x2\x2\x9FC\x9FD\x3"+
		"\x2\x2\x2\x9FD\x9FF\x3\x2\x2\x2\x9FE\x9E3\x3\x2\x2\x2\x9FE\x9EC\x3\x2"+
		"\x2\x2\x9FF\x12B\x3\x2\x2\x2\xA00\xA01\a\x113\x2\x2\xA01\xA02\x5\x2C8"+
		"\x165\x2\xA02\xA05\a\x9D\x2\x2\xA03\xA06\x5\x13E\xA0\x2\xA04\xA06\x5\x202"+
		"\x102\x2\xA05\xA03\x3\x2\x2\x2\xA05\xA04\x3\x2\x2\x2\xA06\xA08\x3\x2\x2"+
		"\x2\xA07\xA09\x5\x264\x133\x2\xA08\xA07\x3\x2\x2\x2\xA08\xA09\x3\x2\x2"+
		"\x2\xA09\x12D\x3\x2\x2\x2\xA0A\xA10\x5\x130\x99\x2\xA0B\xA10\x5\x132\x9A"+
		"\x2\xA0C\xA10\x5\x134\x9B\x2\xA0D\xA10\x5\x138\x9D\x2\xA0E\xA10\x5\x13A"+
		"\x9E\x2\xA0F\xA0A\x3\x2\x2\x2\xA0F\xA0B\x3\x2\x2\x2\xA0F\xA0C\x3\x2\x2"+
		"\x2\xA0F\xA0D\x3\x2\x2\x2\xA0F\xA0E\x3\x2\x2\x2\xA10\x12F\x3\x2\x2\x2"+
		"\xA11\xA12\a\x167\x2\x2\xA12\xA20\a\x198\x2\x2\xA13\xA14\a\x13B\x2\x2"+
		"\xA14\xA21\t\x18\x2\x2\xA15\xA16\a\xC5\x2\x2\xA16\xA1A\a\xCF\x2\x2\xA17"+
		"\xA1B\a\x163\x2\x2\xA18\xA19\a\x13B\x2\x2\xA19\xA1B\a\x44\x2\x2\xA1A\xA17"+
		"\x3\x2\x2\x2\xA1A\xA18\x3\x2\x2\x2\xA1B\xA21\x3\x2\x2\x2\xA1C\xA1D\a\x1AB"+
		"\x2\x2\xA1D\xA1E\a\x14F\x2\x2\xA1E\xA1F\a\x15E\x2\x2\xA1F\xA21\x5\x2A2"+
		"\x152\x2\xA20\xA13\x3\x2\x2\x2\xA20\xA15\x3\x2\x2\x2\xA20\xA1C\x3\x2\x2"+
		"\x2\xA20\xA21\x3\x2\x2\x2\xA21\xA24\x3\x2\x2\x2\xA22\xA23\a\xEF\x2\x2"+
		"\xA23\xA25\x5\x2FA\x17E\x2\xA24\xA22\x3\x2\x2\x2\xA24\xA25\x3\x2\x2\x2"+
		"\xA25\x131\x3\x2\x2\x2\xA26\xA27\a\x167\x2\x2\xA27\xA31\t\x19\x2\x2\xA28"+
		"\xA32\a\xF\x2\x2\xA29\xA2E\x5\x2B8\x15D\x2\xA2A\xA2B\a\x204\x2\x2\xA2B"+
		"\xA2D\x5\x2B8\x15D\x2\xA2C\xA2A\x3\x2\x2\x2\xA2D\xA30\x3\x2\x2\x2\xA2E"+
		"\xA2C\x3\x2\x2\x2\xA2E\xA2F\x3\x2\x2\x2\xA2F\xA32\x3\x2\x2\x2\xA30\xA2E"+
		"\x3\x2\x2\x2\xA31\xA28\x3\x2\x2\x2\xA31\xA29\x3\x2\x2\x2\xA32\xA33\x3"+
		"\x2\x2\x2\xA33\xA34\t\x1A\x2\x2\xA34\x133\x3\x2\x2\x2\xA35\xA37\a\x43"+
		"\x2\x2\xA36\xA38\a\x1C0\x2\x2\xA37\xA36\x3\x2\x2\x2\xA37\xA38\x3\x2\x2"+
		"\x2\xA38\xA46\x3\x2\x2\x2\xA39\xA3A\a\x42\x2\x2\xA3A\xA47\x5\x202\x102"+
		"\x2\xA3B\xA44\a\x9F\x2\x2\xA3C\xA3D\aR\x2\x2\xA3D\xA45\x5\x202\x102\x2"+
		"\xA3E\xA45\aS\x2\x2\xA3F\xA42\x5\x202\x102\x2\xA40\xA41\a\x204\x2\x2\xA41"+
		"\xA43\x5\x202\x102\x2\xA42\xA40\x3\x2\x2\x2\xA42\xA43\x3\x2\x2\x2\xA43"+
		"\xA45\x3\x2\x2\x2\xA44\xA3C\x3\x2\x2\x2\xA44\xA3E\x3\x2\x2\x2\xA44\xA3F"+
		"\x3\x2\x2\x2\xA45\xA47\x3\x2\x2\x2\xA46\xA39\x3\x2\x2\x2\xA46\xA3B\x3"+
		"\x2\x2\x2\xA46\xA47\x3\x2\x2\x2\xA47\xA49\x3\x2\x2\x2\xA48\xA4A\x5\x136"+
		"\x9C\x2\xA49\xA48\x3\x2\x2\x2\xA49\xA4A\x3\x2\x2\x2\xA4A\x135\x3\x2\x2"+
		"\x2\xA4B\xA4D\a\x1C1\x2\x2\xA4C\xA4E\t\x1B\x2\x2\xA4D\xA4C\x3\x2\x2\x2"+
		"\xA4D\xA4E\x3\x2\x2\x2\xA4E\xA50\x3\x2\x2\x2\xA4F\xA51\t\x1C\x2\x2\xA50"+
		"\xA4F\x3\x2\x2\x2\xA50\xA51\x3\x2\x2\x2\xA51\x137\x3\x2\x2\x2\xA52\xA54"+
		"\a\x14F\x2\x2\xA53\xA55\a\x1C0\x2\x2\xA54\xA53\x3\x2\x2\x2\xA54\xA55\x3"+
		"\x2\x2\x2\xA55\xA5D\x3\x2\x2\x2\xA56\xA58\a\x194\x2\x2\xA57\xA59\a\x157"+
		"\x2\x2\xA58\xA57\x3\x2\x2\x2\xA58\xA59\x3\x2\x2\x2\xA59\xA5A\x3\x2\x2"+
		"\x2\xA5A\xA5E\x5\x2A0\x151\x2\xA5B\xA5C\a\x9F\x2\x2\xA5C\xA5E\x5\x2FA"+
		"\x17E\x2\xA5D\xA56\x3\x2\x2\x2\xA5D\xA5B\x3\x2\x2\x2\xA5D\xA5E\x3\x2\x2"+
		"\x2\xA5E\x139\x3\x2\x2\x2\xA5F\xA60\a\x157\x2\x2\xA60\xA61\x5\x2A0\x151"+
		"\x2\xA61\x13B\x3\x2\x2\x2\xA62\xA63\a\x90\x2\x2\xA63\xA68\a\x12E\x2\x2"+
		"\xA64\xA65\a\x167\x2\x2\xA65\xA66\a\x17E\x2\x2\xA66\xA67\a\x215\x2\x2"+
		"\xA67\xA69\x5\x2FA\x17E\x2\xA68\xA64\x3\x2\x2\x2\xA68\xA69\x3\x2\x2\x2"+
		"\xA69\xA6C\x3\x2\x2\x2\xA6A\xA6B\a\xC2\x2\x2\xA6B\xA6D\x5\x2D6\x16C\x2"+
		"\xA6C\xA6A\x3\x2\x2\x2\xA6C\xA6D\x3\x2\x2\x2\xA6D\xA6E\x3\x2\x2\x2\xA6E"+
		"\xA74\a\x9D\x2\x2\xA6F\xA75\x5\x13E\xA0\x2\xA70\xA75\x5\x1B2\xDA\x2\xA71"+
		"\xA75\x5\x1B8\xDD\x2\xA72\xA75\x5\x1BA\xDE\x2\xA73\xA75\x5\x1CC\xE7\x2"+
		"\xA74\xA6F\x3\x2\x2\x2\xA74\xA70\x3\x2\x2\x2\xA74\xA71\x3\x2\x2\x2\xA74"+
		"\xA72\x3\x2\x2\x2\xA74\xA73\x3\x2\x2\x2\xA75\x13D\x3\x2\x2\x2\xA76\xA7B"+
		"\x5\x148\xA5\x2\xA77\xA7A\x5\x1AC\xD7\x2\xA78\xA7A\x5\x1A8\xD5\x2\xA79"+
		"\xA77\x3\x2\x2\x2\xA79\xA78\x3\x2\x2\x2\xA7A\xA7D\x3\x2\x2\x2\xA7B\xA79"+
		"\x3\x2\x2\x2\xA7B\xA7C\x3\x2\x2\x2\xA7C\x13F\x3\x2\x2\x2\xA7D\xA7B\x3"+
		"\x2\x2\x2\xA7E\xA7F\a\x1BE\x2\x2\xA7F\xA84\x5\x142\xA2\x2\xA80\xA81\a"+
		"\x204\x2\x2\xA81\xA83\x5\x142\xA2\x2\xA82\xA80\x3\x2\x2\x2\xA83\xA86\x3"+
		"\x2\x2\x2\xA84\xA82\x3\x2\x2\x2\xA84\xA85\x3\x2\x2\x2\xA85\x141\x3\x2"+
		"\x2\x2\xA86\xA84\x3\x2\x2\x2\xA87\xA93\x5\x2B6\x15C\x2\xA88\xA89\a\x1FE"+
		"\x2\x2\xA89\xA8E\x5\x2D4\x16B\x2\xA8A\xA8B\a\x204\x2\x2\xA8B\xA8D\x5\x2D4"+
		"\x16B\x2\xA8C\xA8A\x3\x2\x2\x2\xA8D\xA90\x3\x2\x2\x2\xA8E\xA8C\x3\x2\x2"+
		"\x2\xA8E\xA8F\x3\x2\x2\x2\xA8F\xA91\x3\x2\x2\x2\xA90\xA8E\x3\x2\x2\x2"+
		"\xA91\xA92\a\x1FF\x2\x2\xA92\xA94\x3\x2\x2\x2\xA93\xA88\x3\x2\x2\x2\xA93"+
		"\xA94\x3\x2\x2\x2\xA94\xA95\x3\x2\x2\x2\xA95\xA96\a\x15\x2\x2\xA96\xA97"+
		"\a\x1FE\x2\x2\xA97\xA99\x5\x148\xA5\x2\xA98\xA9A\x5\x1A8\xD5\x2\xA99\xA98"+
		"\x3\x2\x2\x2\xA99\xA9A\x3\x2\x2\x2\xA9A\xA9B\x3\x2\x2\x2\xA9B\xA9D\a\x1FF"+
		"\x2\x2\xA9C\xA9E\x5\x144\xA3\x2\xA9D\xA9C\x3\x2\x2\x2\xA9D\xA9E\x3\x2"+
		"\x2\x2\xA9E\xAA0\x3\x2\x2\x2\xA9F\xAA1\x5\x146\xA4\x2\xAA0\xA9F\x3\x2"+
		"\x2\x2\xAA0\xAA1\x3\x2\x2\x2\xAA1\x143\x3\x2\x2\x2\xAA2\xAA3\a\x15B\x2"+
		"\x2\xAA3\xAA4\t\x1D\x2\x2\xAA4\xAA5\a\x98\x2\x2\xAA5\xAA6\a/\x2\x2\xAA6"+
		"\xAA8\x5\x2D4\x16B\x2\xAA7\xAA9\a\x16\x2\x2\xAA8\xAA7\x3\x2\x2\x2\xAA8"+
		"\xAA9\x3\x2\x2\x2\xAA9\xAAB\x3\x2\x2\x2\xAAA\xAAC\aq\x2\x2\xAAB\xAAA\x3"+
		"\x2\x2\x2\xAAB\xAAC\x3\x2\x2\x2\xAAC\xAAF\x3\x2\x2\x2\xAAD\xAAE\a\x108"+
		"\x2\x2\xAAE\xAB0\a\x98\x2\x2\xAAF\xAAD\x3\x2\x2\x2\xAAF\xAB0\x3\x2\x2"+
		"\x2\xAB0\xAB3\x3\x2\x2\x2\xAB1\xAB2\a\x108\x2\x2\xAB2\xAB4\a\xCB\x2\x2"+
		"\xAB3\xAB1\x3\x2\x2\x2\xAB3\xAB4\x3\x2\x2\x2\xAB4\xAC7\x3\x2\x2\x2\xAB5"+
		"\xAB6\a\x204\x2\x2\xAB6\xAB8\x5\x2D4\x16B\x2\xAB7\xAB9\a\x16\x2\x2\xAB8"+
		"\xAB7\x3\x2\x2\x2\xAB8\xAB9\x3\x2\x2\x2\xAB9\xABB\x3\x2\x2\x2\xABA\xABC"+
		"\aq\x2\x2\xABB\xABA\x3\x2\x2\x2\xABB\xABC\x3\x2\x2\x2\xABC\xABF\x3\x2"+
		"\x2\x2\xABD\xABE\a\x108\x2\x2\xABE\xAC0\a\x98\x2\x2\xABF\xABD\x3\x2\x2"+
		"\x2\xABF\xAC0\x3\x2\x2\x2\xAC0\xAC3\x3\x2\x2\x2\xAC1\xAC2\a\x108\x2\x2"+
		"\xAC2\xAC4\a\xCB\x2\x2\xAC3\xAC1\x3\x2\x2\x2\xAC3\xAC4\x3\x2\x2\x2\xAC4"+
		"\xAC6\x3\x2\x2\x2\xAC5\xAB5\x3\x2\x2\x2\xAC6\xAC9\x3\x2\x2\x2\xAC7\xAC5"+
		"\x3\x2\x2\x2\xAC7\xAC8\x3\x2\x2\x2\xAC8\xACA\x3\x2\x2\x2\xAC9\xAC7\x3"+
		"\x2\x2\x2\xACA\xACB\a\x167\x2\x2\xACB\xACC\x5\x2D4\x16B\x2\xACC\x145\x3"+
		"\x2\x2\x2\xACD\xACE\a]\x2\x2\xACE\xAD3\x5\x2D4\x16B\x2\xACF\xAD0\a\x204"+
		"\x2\x2\xAD0\xAD2\x5\x2D4\x16B\x2\xAD1\xACF\x3\x2\x2\x2\xAD2\xAD5\x3\x2"+
		"\x2\x2\xAD3\xAD1\x3\x2\x2\x2\xAD3\xAD4\x3\x2\x2\x2\xAD4\xAD6\x3\x2\x2"+
		"\x2\xAD5\xAD3\x3\x2\x2\x2\xAD6\xAD7\a\x167\x2\x2\xAD7\xAD8\x5\x2D4\x16B"+
		"\x2\xAD8\xAD9\a\x194\x2\x2\xAD9\xADA\x5\x202\x102\x2\xADA\xADB\ak\x2\x2"+
		"\xADB\xADC\x5\x202\x102\x2\xADC\x147\x3\x2\x2\x2\xADD\xAE1\x5\x14C\xA7"+
		"\x2\xADE\xAE0\x5\x14A\xA6\x2\xADF\xADE\x3\x2\x2\x2\xAE0\xAE3\x3\x2\x2"+
		"\x2\xAE1\xADF\x3\x2\x2\x2\xAE1\xAE2\x3\x2\x2\x2\xAE2\x149\x3\x2\x2\x2"+
		"\xAE3\xAE1\x3\x2\x2\x2\xAE4\xAE6\a\x1A2\x2\x2\xAE5\xAE7\a\xF\x2\x2\xAE6"+
		"\xAE5\x3\x2\x2\x2\xAE6\xAE7\x3\x2\x2\x2\xAE7\xAEB\x3\x2\x2\x2\xAE8\xAEB"+
		"\a\xC0\x2\x2\xAE9\xAEB\a\xE5\x2\x2\xAEA\xAE4\x3\x2\x2\x2\xAEA\xAE8\x3"+
		"\x2\x2\x2\xAEA\xAE9\x3\x2\x2\x2\xAEB\xAEC\x3\x2\x2\x2\xAEC\xAED\x5\x14C"+
		"\xA7\x2\xAED\x14B\x3\x2\x2\x2\xAEE\xAF4\x5\x14E\xA8\x2\xAEF\xAF0\a\x1FE"+
		"\x2\x2\xAF0\xAF1\x5\x148\xA5\x2\xAF1\xAF2\a\x1FF\x2\x2\xAF2\xAF4\x3\x2"+
		"\x2\x2\xAF3\xAEE\x3\x2\x2\x2\xAF3\xAEF\x3\x2\x2\x2\xAF4\x14D\x3\x2\x2"+
		"\x2\xAF5\xAF7\x5\x140\xA1\x2\xAF6\xAF5\x3\x2\x2\x2\xAF6\xAF7\x3\x2\x2"+
		"\x2\xAF7\xAF8\x3\x2\x2\x2\xAF8\xAFA\a\x15F\x2\x2\xAF9\xAFB\t\x1E\x2\x2"+
		"\xAFA\xAF9\x3\x2\x2\x2\xAFA\xAFB\x3\x2\x2\x2\xAFB\xB05\x3\x2\x2\x2\xAFC"+
		"\xB06\a\x201\x2\x2\xAFD\xB02\x5\x150\xA9\x2\xAFE\xAFF\a\x204\x2\x2\xAFF"+
		"\xB01\x5\x150\xA9\x2\xB00\xAFE\x3\x2\x2\x2\xB01\xB04\x3\x2\x2\x2\xB02"+
		"\xB00\x3\x2\x2\x2\xB02\xB03\x3\x2\x2\x2\xB03\xB06\x3\x2\x2\x2\xB04\xB02"+
		"\x3\x2\x2\x2\xB05\xAFC\x3\x2\x2\x2\xB05\xAFD\x3\x2\x2\x2\xB06\xB08\x3"+
		"\x2\x2\x2\xB07\xB09\x5\x298\x14D\x2\xB08\xB07\x3\x2\x2\x2\xB08\xB09\x3"+
		"\x2\x2\x2\xB09\xB0A\x3\x2\x2\x2\xB0A\xB0C\x5\x152\xAA\x2\xB0B\xB0D\x5"+
		"\x292\x14A\x2\xB0C\xB0B\x3\x2\x2\x2\xB0C\xB0D\x3\x2\x2\x2\xB0D\xB0F\x3"+
		"\x2\x2\x2\xB0E\xB10\x5\x17A\xBE\x2\xB0F\xB0E\x3\x2\x2\x2\xB0F\xB10\x3"+
		"\x2\x2\x2\xB10\xB12\x3\x2\x2\x2\xB11\xB13\x5\x17E\xC0\x2\xB12\xB11\x3"+
		"\x2\x2\x2\xB12\xB13\x3\x2\x2\x2\xB13\xB15\x3\x2\x2\x2\xB14\xB16\x5\x1A8"+
		"\xD5\x2\xB15\xB14\x3\x2\x2\x2\xB15\xB16\x3\x2\x2\x2\xB16\xB18\x3\x2\x2"+
		"\x2\xB17\xB19\x5\x18A\xC6\x2\xB18\xB17\x3\x2\x2\x2\xB18\xB19\x3\x2\x2"+
		"\x2\xB19\xB1B\x3\x2\x2\x2\xB1A\xB1C\a\x20A\x2\x2\xB1B\xB1A\x3\x2\x2\x2"+
		"\xB1B\xB1C\x3\x2\x2\x2\xB1C\x14F\x3\x2\x2\x2\xB1D\xB1F\x5\x154\xAB\x2"+
		"\xB1E\xB20\x5\x28C\x147\x2\xB1F\xB1E\x3\x2\x2\x2\xB1F\xB20\x3\x2\x2\x2"+
		"\xB20\x151\x3\x2\x2\x2\xB21\xB22\a\xA0\x2\x2\xB22\xB23\x5\x156\xAC\x2"+
		"\xB23\x153\x3\x2\x2\x2\xB24\xB25\x5\x2D6\x16C\x2\xB25\xB26\a\x1F7\x2\x2"+
		"\xB26\xB27\a\x201\x2\x2\xB27\xB2A\x3\x2\x2\x2\xB28\xB2A\x5\x202\x102\x2"+
		"\xB29\xB24\x3\x2\x2\x2\xB29\xB28\x3\x2\x2\x2\xB2A\x155\x3\x2\x2\x2\xB2B"+
		"\xB30\x5\x158\xAD\x2\xB2C\xB2D\a\x204\x2\x2\xB2D\xB2F\x5\x158\xAD\x2\xB2E"+
		"\xB2C\x3\x2\x2\x2\xB2F\xB32\x3\x2\x2\x2\xB30\xB2E\x3\x2\x2\x2\xB30\xB31"+
		"\x3\x2\x2\x2\xB31\x157\x3\x2\x2\x2\xB32\xB30\x3\x2\x2\x2\xB33\xB37\x5"+
		"\x15A\xAE\x2\xB34\xB36\x5\x15C\xAF\x2\xB35\xB34\x3\x2\x2\x2\xB36\xB39"+
		"\x3\x2\x2\x2\xB37\xB35\x3\x2\x2\x2\xB37\xB38\x3\x2\x2\x2\xB38\xB3C\x3"+
		"\x2\x2\x2\xB39\xB37\x3\x2\x2\x2\xB3A\xB3D\x5\x168\xB5\x2\xB3B\xB3D\x5"+
		"\x174\xBB\x2\xB3C\xB3A\x3\x2\x2\x2\xB3C\xB3B\x3\x2\x2\x2\xB3C\xB3D\x3"+
		"\x2\x2\x2\xB3D\x159\x3\x2\x2\x2\xB3E\xB41\x5\x1EA\xF6\x2\xB3F\xB42\x5"+
		"\x168\xB5\x2\xB40\xB42\x5\x174\xBB\x2\xB41\xB3F\x3\x2\x2\x2\xB41\xB40"+
		"\x3\x2\x2\x2\xB41\xB42\x3\x2\x2\x2\xB42\xB5C\x3\x2\x2\x2\xB43\xB44\a\x1FE"+
		"\x2\x2\xB44\xB48\x5\x158\xAD\x2\xB45\xB47\x5\x14A\xA6\x2\xB46\xB45\x3"+
		"\x2\x2\x2\xB47\xB4A\x3\x2\x2\x2\xB48\xB46\x3\x2\x2\x2\xB48\xB49\x3\x2"+
		"\x2\x2\xB49\xB4B\x3\x2\x2\x2\xB4A\xB48\x3\x2\x2\x2\xB4B\xB4E\a\x1FF\x2"+
		"\x2\xB4C\xB4F\x5\x168\xB5\x2\xB4D\xB4F\x5\x174\xBB\x2\xB4E\xB4C\x3\x2"+
		"\x2\x2\xB4E\xB4D\x3\x2\x2\x2\xB4E\xB4F\x3\x2\x2\x2\xB4F\xB5C\x3\x2\x2"+
		"\x2\xB50\xB51\a\x112\x2\x2\xB51\xB52\a\x1FE\x2\x2\xB52\xB53\x5\x1EA\xF6"+
		"\x2\xB53\xB54\a\x1FF\x2\x2\xB54\xB5C\x3\x2\x2\x2\xB55\xB58\x5\x1EA\xF6"+
		"\x2\xB56\xB59\x5\x168\xB5\x2\xB57\xB59\x5\x174\xBB\x2\xB58\xB56\x3\x2"+
		"\x2\x2\xB58\xB57\x3\x2\x2\x2\xB58\xB59\x3\x2\x2\x2\xB59\xB5C\x3\x2\x2"+
		"\x2\xB5A\xB5C\x5\x252\x12A\x2\xB5B\xB3E\x3\x2\x2\x2\xB5B\xB43\x3\x2\x2"+
		"\x2\xB5B\xB50\x3\x2\x2\x2\xB5B\xB55\x3\x2\x2\x2\xB5B\xB5A\x3\x2\x2\x2"+
		"\xB5C\xB60\x3\x2\x2\x2\xB5D\xB5F\x5\x166\xB4\x2\xB5E\xB5D\x3\x2\x2\x2"+
		"\xB5F\xB62\x3\x2\x2\x2\xB60\xB5E\x3\x2\x2\x2\xB60\xB61\x3\x2\x2\x2\xB61"+
		"\xB64\x3\x2\x2\x2\xB62\xB60\x3\x2\x2\x2\xB63\xB65\x5\x28E\x148\x2\xB64"+
		"\xB63\x3\x2\x2\x2\xB64\xB65\x3\x2\x2\x2\xB65\x15B\x3\x2\x2\x2\xB66\xB68"+
		"\x5\x164\xB3\x2\xB67\xB66\x3\x2\x2\x2\xB67\xB68\x3\x2\x2\x2\xB68\xB6A"+
		"\x3\x2\x2\x2\xB69\xB6B\t\x1F\x2\x2\xB6A\xB69\x3\x2\x2\x2\xB6A\xB6B\x3"+
		"\x2\x2\x2\xB6B\xB6E\x3\x2\x2\x2\xB6C\xB6F\a\xB9\x2\x2\xB6D\xB6F\x5\x162"+
		"\xB2\x2\xB6E\xB6C\x3\x2\x2\x2\xB6E\xB6D\x3\x2\x2\x2\xB6E\xB6F\x3\x2\x2"+
		"\x2\xB6F\xB70\x3\x2\x2\x2\xB70\xB71\a\xC8\x2\x2\xB71\xB73\x5\x15A\xAE"+
		"\x2\xB72\xB74\x5\x164\xB3\x2\xB73\xB72\x3\x2\x2\x2\xB73\xB74\x3\x2\x2"+
		"\x2\xB74\xB79\x3\x2\x2\x2\xB75\xB78\x5\x15E\xB0\x2\xB76\xB78\x5\x160\xB1"+
		"\x2\xB77\xB75\x3\x2\x2\x2\xB77\xB76\x3\x2\x2\x2\xB78\xB7B\x3\x2\x2\x2"+
		"\xB79\xB77\x3\x2\x2\x2\xB79\xB7A\x3\x2\x2\x2\xB7A\x15D\x3\x2\x2\x2\xB7B"+
		"\xB79\x3\x2\x2\x2\xB7C\xB7D\a\x111\x2\x2\xB7D\xB7E\x5\x1FE\x100\x2\xB7E"+
		"\x15F\x3\x2\x2\x2\xB7F\xB80\a\x1AC\x2\x2\xB80\xB81\a\x1FE\x2\x2\xB81\xB86"+
		"\x5\x2D4\x16B\x2\xB82\xB83\a\x204\x2\x2\xB83\xB85\x5\x2D4\x16B\x2\xB84"+
		"\xB82\x3\x2\x2\x2\xB85\xB88\x3\x2\x2\x2\xB86\xB84\x3\x2\x2\x2\xB86\xB87"+
		"\x3\x2\x2\x2\xB87\xB89\x3\x2\x2\x2\xB88\xB86\x3\x2\x2\x2\xB89\xB8A\a\x1FF"+
		"\x2\x2\xB8A\x161\x3\x2\x2\x2\xB8B\xB8D\t \x2\x2\xB8C\xB8E\a\x11B\x2\x2"+
		"\xB8D\xB8C\x3\x2\x2\x2\xB8D\xB8E\x3\x2\x2\x2\xB8E\x163\x3\x2\x2\x2\xB8F"+
		"\xB90\a\x122\x2\x2\xB90\xB9E\a/\x2\x2\xB91\xB92\a\x1FE\x2\x2\xB92\xB93"+
		"\x5\x148\xA5\x2\xB93\xB94\a\x1FF\x2\x2\xB94\xB9F\x3\x2\x2\x2\xB95\xB9F"+
		"\x5\x1FC\xFF\x2\xB96\xB9B\x5\x202\x102\x2\xB97\xB98\a\x204\x2\x2\xB98"+
		"\xB9A\x5\x202\x102\x2\xB99\xB97\x3\x2\x2\x2\xB9A\xB9D\x3\x2\x2\x2\xB9B"+
		"\xB99\x3\x2\x2\x2\xB9B\xB9C\x3\x2\x2\x2\xB9C\xB9F\x3\x2\x2\x2\xB9D\xB9B"+
		"\x3\x2\x2\x2\xB9E\xB91\x3\x2\x2\x2\xB9E\xB95\x3\x2\x2\x2\xB9E\xB96\x3"+
		"\x2\x2\x2\xB9F\x165\x3\x2\x2\x2\xBA0\xBA1\a\x1B6\x2\x2\xBA1\xBA2\a#\x2"+
		"\x2\xBA2\xBA3\t!\x2\x2\xBA3\xBA9\x5\x202\x102\x2\xBA4\xBA5\a\x15\x2\x2"+
		"\xBA5\xBA6\a\x10D\x2\x2\xBA6\xBA7\t\"\x2\x2\xBA7\xBA9\x5\x202\x102\x2"+
		"\xBA8\xBA0\x3\x2\x2\x2\xBA8\xBA4\x3\x2\x2\x2\xBA9\x167\x3\x2\x2\x2\xBAA"+
		"\xBAC\a\x12D\x2\x2\xBAB\xBAD\a\x1C2\x2\x2\xBAC\xBAB\x3\x2\x2\x2\xBAC\xBAD"+
		"\x3\x2\x2\x2\xBAD\xBAE\x3\x2\x2\x2\xBAE\xBAF\a\x1FE\x2\x2\xBAF\xBB4\x5"+
		"\x16A\xB6\x2\xBB0\xBB1\a\x204\x2\x2\xBB1\xBB3\x5\x16A\xB6\x2\xBB2\xBB0"+
		"\x3\x2\x2\x2\xBB3\xBB6\x3\x2\x2\x2\xBB4\xBB2\x3\x2\x2\x2\xBB4\xBB5\x3"+
		"\x2\x2\x2\xBB5\xBB7\x3\x2\x2\x2\xBB6\xBB4\x3\x2\x2\x2\xBB7\xBB8\x5\x16C"+
		"\xB7\x2\xBB8\xBB9\x5\x16E\xB8\x2\xBB9\xBBA\a\x1FF\x2\x2\xBBA\x169\x3\x2"+
		"\x2\x2\xBBB\xBBC\x5\x2B4\x15B\x2\xBBC\xBBD\a\x1FE\x2\x2\xBBD\xBBE\x5\x202"+
		"\x102\x2\xBBE\xBC0\a\x1FF\x2\x2\xBBF\xBC1\x5\x28C\x147\x2\xBC0\xBBF\x3"+
		"\x2\x2\x2\xBC0\xBC1\x3\x2\x2\x2\xBC1\x16B\x3\x2\x2\x2\xBC2\xBCF\a\x9D"+
		"\x2\x2\xBC3\xBD0\x5\x2D4\x16B\x2\xBC4\xBC5\a\x1FE\x2\x2\xBC5\xBCA\x5\x2D4"+
		"\x16B\x2\xBC6\xBC7\a\x204\x2\x2\xBC7\xBC9\x5\x2D4\x16B\x2\xBC8\xBC6\x3"+
		"\x2\x2\x2\xBC9\xBCC\x3\x2\x2\x2\xBCA\xBC8\x3\x2\x2\x2\xBCA\xBCB\x3\x2"+
		"\x2\x2\xBCB\xBCD\x3\x2\x2\x2\xBCC\xBCA\x3\x2\x2\x2\xBCD\xBCE\a\x1FF\x2"+
		"\x2\xBCE\xBD0\x3\x2\x2\x2\xBCF\xBC3\x3\x2\x2\x2\xBCF\xBC4\x3\x2\x2\x2"+
		"\xBD0\x16D\x3\x2\x2\x2\xBD1\xBD2\a\xAE\x2\x2\xBD2\xBE4\a\x1FE\x2\x2\xBD3"+
		"\xBE5\x5\x148\xA5\x2\xBD4\xBD9\a\x13\x2\x2\xBD5\xBD6\a\x204\x2\x2\xBD6"+
		"\xBD8\a\x13\x2\x2\xBD7\xBD5\x3\x2\x2\x2\xBD8\xBDB\x3\x2\x2\x2\xBD9\xBD7"+
		"\x3\x2\x2\x2\xBD9\xBDA\x3\x2\x2\x2\xBDA\xBE5\x3\x2\x2\x2\xBDB\xBD9\x3"+
		"\x2\x2\x2\xBDC\xBE1\x5\x170\xB9\x2\xBDD\xBDE\a\x204\x2\x2\xBDE\xBE0\x5"+
		"\x170\xB9\x2\xBDF\xBDD\x3\x2\x2\x2\xBE0\xBE3\x3\x2\x2\x2\xBE1\xBDF\x3"+
		"\x2\x2\x2\xBE1\xBE2\x3\x2\x2\x2\xBE2\xBE5\x3\x2\x2\x2\xBE3\xBE1\x3\x2"+
		"\x2\x2\xBE4\xBD3\x3\x2\x2\x2\xBE4\xBD4\x3\x2\x2\x2\xBE4\xBDC\x3\x2\x2"+
		"\x2\xBE5\xBE6\x3\x2\x2\x2\xBE6\xBE7\a\x1FF\x2\x2\xBE7\x16F\x3\x2\x2\x2"+
		"\xBE8\xBEA\x5\x172\xBA\x2\xBE9\xBEB\x5\x28C\x147\x2\xBEA\xBE9\x3\x2\x2"+
		"\x2\xBEA\xBEB\x3\x2\x2\x2\xBEB\x171\x3\x2\x2\x2\xBEC\xBEF\x5\x202\x102"+
		"\x2\xBED\xBEF\x5\x1FC\xFF\x2\xBEE\xBEC\x3\x2\x2\x2\xBEE\xBED\x3\x2\x2"+
		"\x2\xBEF\x173\x3\x2\x2\x2\xBF0\xBF3\a\x1A5\x2\x2\xBF1\xBF2\t#\x2\x2\xBF2"+
		"\xBF4\a\x108\x2\x2\xBF3\xBF1\x3\x2\x2\x2\xBF3\xBF4\x3\x2\x2\x2\xBF4\xBF5"+
		"\x3\x2\x2\x2\xBF5\xC02\a\x1FE\x2\x2\xBF6\xC03\x5\x2D4\x16B\x2\xBF7\xBF8"+
		"\a\x1FE\x2\x2\xBF8\xBFD\x5\x2D4\x16B\x2\xBF9\xBFA\a\x204\x2\x2\xBFA\xBFC"+
		"\x5\x2D4\x16B\x2\xBFB\xBF9\x3\x2\x2\x2\xBFC\xBFF\x3\x2\x2\x2\xBFD\xBFB"+
		"\x3\x2\x2\x2\xBFD\xBFE\x3\x2\x2\x2\xBFE\xC00\x3\x2\x2\x2\xBFF\xBFD\x3"+
		"\x2\x2\x2\xC00\xC01\a\x1FF\x2\x2\xC01\xC03\x3\x2\x2\x2\xC02\xBF6\x3\x2"+
		"\x2\x2\xC02\xBF7\x3\x2\x2\x2\xC03\xC04\x3\x2\x2\x2\xC04\xC05\x5\x16C\xB7"+
		"\x2\xC05\xC06\x5\x176\xBC\x2\xC06\xC07\a\x1FF\x2\x2\xC07\x175\x3\x2\x2"+
		"\x2\xC08\xC09\a\xAE\x2\x2\xC09\xC0A\a\x1FE\x2\x2\xC0A\xC0F\x5\x178\xBD"+
		"\x2\xC0B\xC0C\a\x204\x2\x2\xC0C\xC0E\x5\x178\xBD\x2\xC0D\xC0B\x3\x2\x2"+
		"\x2\xC0E\xC11\x3\x2\x2\x2\xC0F\xC0D\x3\x2\x2\x2\xC0F\xC10\x3\x2\x2\x2"+
		"\xC10\xC12\x3\x2\x2\x2\xC11\xC0F\x3\x2\x2\x2\xC12\xC13\a\x1FF\x2\x2\xC13"+
		"\x177\x3\x2\x2\x2\xC14\xC21\x5\x2D4\x16B\x2\xC15\xC16\a\x1FE\x2\x2\xC16"+
		"\xC1B\x5\x2D4\x16B\x2\xC17\xC18\a\x204\x2\x2\xC18\xC1A\x5\x2D4\x16B\x2"+
		"\xC19\xC17\x3\x2\x2\x2\xC1A\xC1D\x3\x2\x2\x2\xC1B\xC19\x3\x2\x2\x2\xC1B"+
		"\xC1C\x3\x2\x2\x2\xC1C\xC1E\x3\x2\x2\x2\xC1D\xC1B\x3\x2\x2\x2\xC1E\xC1F"+
		"\a\x1FF\x2\x2\xC1F\xC21\x3\x2\x2\x2\xC20\xC14\x3\x2\x2\x2\xC20\xC15\x3"+
		"\x2\x2\x2\xC21\xC31\x3\x2\x2\x2\xC22\xC2F\a\x15\x2\x2\xC23\xC30\x5\x2F6"+
		"\x17C\x2\xC24\xC25\a\x1FE\x2\x2\xC25\xC2A\x5\x2F6\x17C\x2\xC26\xC27\a"+
		"\x204\x2\x2\xC27\xC29\x5\x2F6\x17C\x2\xC28\xC26\x3\x2\x2\x2\xC29\xC2C"+
		"\x3\x2\x2\x2\xC2A\xC28\x3\x2\x2\x2\xC2A\xC2B\x3\x2\x2\x2\xC2B\xC2D\x3"+
		"\x2\x2\x2\xC2C\xC2A\x3\x2\x2\x2\xC2D\xC2E\a\x1FF\x2\x2\xC2E\xC30\x3\x2"+
		"\x2\x2\xC2F\xC23\x3\x2\x2\x2\xC2F\xC24\x3\x2\x2\x2\xC30\xC32\x3\x2\x2"+
		"\x2\xC31\xC22\x3\x2\x2\x2\xC31\xC32\x3\x2\x2\x2\xC32\x179\x3\x2\x2\x2"+
		"\xC33\xC34\aH\x2\x2\xC34\xC36\a/\x2\x2\xC35\xC37\a\xFE\x2\x2\xC36\xC35"+
		"\x3\x2\x2\x2\xC36\xC37\x3\x2\x2\x2\xC37\xC38\x3\x2\x2\x2\xC38\xC3A\x5"+
		"\x1FE\x100\x2\xC39\xC3B\x5\x17C\xBF\x2\xC3A\xC39\x3\x2\x2\x2\xC3A\xC3B"+
		"\x3\x2\x2\x2\xC3B\xC45\x3\x2\x2\x2\xC3C\xC3D\x5\x17C\xBF\x2\xC3D\xC3E"+
		"\aH\x2\x2\xC3E\xC40\a/\x2\x2\xC3F\xC41\a\xFE\x2\x2\xC40\xC3F\x3\x2\x2"+
		"\x2\xC40\xC41\x3\x2\x2\x2\xC41\xC42\x3\x2\x2\x2\xC42\xC43\x5\x1FE\x100"+
		"\x2\xC43\xC45\x3\x2\x2\x2\xC44\xC33\x3\x2\x2\x2\xC44\xC3C\x3\x2\x2\x2"+
		"\xC45\x17B\x3\x2\x2\x2\xC46\xC47\a\x17B\x2\x2\xC47\xC48\a\x1BE\x2\x2\xC48"+
		"\xC49\x5\x1FE\x100\x2\xC49\x17D\x3\x2\x2\x2\xC4A\xC4B\a\xA5\x2\x2\xC4B"+
		"\xC4C\a/\x2\x2\xC4C\xC51\x5\x180\xC1\x2\xC4D\xC4E\a\x204\x2\x2\xC4E\xC50"+
		"\x5\x180\xC1\x2\xC4F\xC4D\x3\x2\x2\x2\xC50\xC53\x3\x2\x2\x2\xC51\xC4F"+
		"\x3\x2\x2\x2\xC51\xC52\x3\x2\x2\x2\xC52\xC55\x3\x2\x2\x2\xC53\xC51\x3"+
		"\x2\x2\x2\xC54\xC56\x5\x188\xC5\x2\xC55\xC54\x3\x2\x2\x2\xC55\xC56\x3"+
		"\x2\x2\x2\xC56\xC65\x3\x2\x2\x2\xC57\xC62\x5\x188\xC5\x2\xC58\xC59\a\xA5"+
		"\x2\x2\xC59\xC5A\a/\x2\x2\xC5A\xC5F\x5\x180\xC1\x2\xC5B\xC5C\a\x204\x2"+
		"\x2\xC5C\xC5E\x5\x180\xC1\x2\xC5D\xC5B\x3\x2\x2\x2\xC5E\xC61\x3\x2\x2"+
		"\x2\xC5F\xC5D\x3\x2\x2\x2\xC5F\xC60\x3\x2\x2\x2\xC60\xC63\x3\x2\x2\x2"+
		"\xC61\xC5F\x3\x2\x2\x2\xC62\xC58\x3\x2\x2\x2\xC62\xC63\x3\x2\x2\x2\xC63"+
		"\xC65\x3\x2\x2\x2\xC64\xC4A\x3\x2\x2\x2\xC64\xC57\x3\x2\x2\x2\xC65\x17F"+
		"\x3\x2\x2\x2\xC66\xC6A\x5\x184\xC3\x2\xC67\xC6A\x5\x182\xC2\x2\xC68\xC6A"+
		"\x5\x202\x102\x2\xC69\xC66\x3\x2\x2\x2\xC69\xC67\x3\x2\x2\x2\xC69\xC68"+
		"\x3\x2\x2\x2\xC6A\x181\x3\x2\x2\x2\xC6B\xC6C\t$\x2\x2\xC6C\xC6D\a\x1FE"+
		"\x2\x2\xC6D\xC72\x5\x186\xC4\x2\xC6E\xC6F\a\x204\x2\x2\xC6F\xC71\x5\x186"+
		"\xC4\x2\xC70\xC6E\x3\x2\x2\x2\xC71\xC74\x3\x2\x2\x2\xC72\xC70\x3\x2\x2"+
		"\x2\xC72\xC73\x3\x2\x2\x2\xC73\xC75\x3\x2\x2\x2\xC74\xC72\x3\x2\x2\x2"+
		"\xC75\xC76\a\x1FF\x2\x2\xC76\x183\x3\x2\x2\x2\xC77\xC78\a\xA6\x2\x2\xC78"+
		"\xC79\a\x168\x2\x2\xC79\xC7A\a\x1FE\x2\x2\xC7A\xC7F\x5\x186\xC4\x2\xC7B"+
		"\xC7C\a\x204\x2\x2\xC7C\xC7E\x5\x186\xC4\x2\xC7D\xC7B\x3\x2\x2\x2\xC7E"+
		"\xC81\x3\x2\x2\x2\xC7F\xC7D\x3\x2\x2\x2\xC7F\xC80\x3\x2\x2\x2\xC80\xC82"+
		"\x3\x2\x2\x2\xC81\xC7F\x3\x2\x2\x2\xC82\xC83\a\x1FF\x2\x2\xC83\x185\x3"+
		"\x2\x2\x2\xC84\xC88\x5\x182\xC2\x2\xC85\xC88\x5\x1FC\xFF\x2\xC86\xC88"+
		"\x5\x202\x102\x2\xC87\xC84\x3\x2\x2\x2\xC87\xC85\x3\x2\x2\x2\xC87\xC86"+
		"\x3\x2\x2\x2\xC88\x187\x3\x2\x2\x2\xC89\xC8A\a\xA8\x2\x2\xC8A\xC8B\x5"+
		"\x1FE\x100\x2\xC8B\x189\x3\x2\x2\x2\xC8C\xC90\a\xEB\x2\x2\xC8D\xC8F\x5"+
		"\x18C\xC7\x2\xC8E\xC8D\x3\x2\x2\x2\xC8F\xC92\x3\x2\x2\x2\xC90\xC8E\x3"+
		"\x2\x2\x2\xC90\xC91\x3\x2\x2\x2\xC91\xC94\x3\x2\x2\x2\xC92\xC90\x3\x2"+
		"\x2\x2\xC93\xC95\x5\x18E\xC8\x2\xC94\xC93\x3\x2\x2\x2\xC94\xC95\x3\x2"+
		"\x2\x2\xC95\xC99\x3\x2\x2\x2\xC96\xC98\x5\x190\xC9\x2\xC97\xC96\x3\x2"+
		"\x2\x2\xC98\xC9B\x3\x2\x2\x2\xC99\xC97\x3\x2\x2\x2\xC99\xC9A\x3\x2\x2"+
		"\x2\xC9A\xC9C\x3\x2\x2\x2\xC9B\xC99\x3\x2\x2\x2\xC9C\xC9D\x5\x192\xCA"+
		"\x2\xC9D\x18B\x3\x2\x2\x2\xC9E\xC9F\t%\x2\x2\xC9F\xCA7\a\xF3\x2\x2\xCA0"+
		"\xCA4\a\x1A3\x2\x2\xCA1\xCA5\as\x2\x2\xCA2\xCA3\a\x170\x2\x2\xCA3\xCA5"+
		"\a\x13F\x2\x2\xCA4\xCA1\x3\x2\x2\x2\xCA4\xCA2\x3\x2\x2\x2\xCA5\xCA7\x3"+
		"\x2\x2\x2\xCA6\xC9E\x3\x2\x2\x2\xCA6\xCA0\x3\x2\x2\x2\xCA7\x18D\x3\x2"+
		"\x2\x2\xCA8\xCA9\a\x149\x2\x2\xCA9\xCAA\t&\x2\x2\xCAA\xCAB\a\x153\x2\x2"+
		"\xCAB\x18F\x3\x2\x2\x2\xCAC\xCAD\a\x13F\x2\x2\xCAD\xCAE\x5\x2B0\x159\x2"+
		"\xCAE\xCAF\a\x111\x2\x2\xCAF\xCB0\a\x1FE\x2\x2\xCB0\xCB1\x5\x148\xA5\x2"+
		"\xCB1\xCB2\a\x1FF\x2\x2\xCB2\xCB6\x5\x194\xCB\x2\xCB3\xCB5\x5\x18C\xC7"+
		"\x2\xCB4\xCB3\x3\x2\x2\x2\xCB5\xCB8\x3\x2\x2\x2\xCB6\xCB4\x3\x2\x2\x2"+
		"\xCB6\xCB7\x3\x2\x2\x2\xCB7\x191\x3\x2\x2\x2\xCB8\xCB6\x3\x2\x2\x2\xCB9"+
		"\xCBA\a\xDE\x2\x2\xCBA\xCBC\x5\x2B2\x15A\x2\xCBB\xCB9\x3\x2\x2\x2\xCBB"+
		"\xCBC\x3\x2\x2\x2\xCBC\xCBD\x3\x2\x2\x2\xCBD\xCC1\x5\x194\xCB\x2\xCBE"+
		"\xCC0\x5\x18C\xC7\x2\xCBF\xCBE\x3\x2\x2\x2\xCC0\xCC3\x3\x2\x2\x2\xCC1"+
		"\xCBF\x3\x2\x2\x2\xCC1\xCC2\x3\x2\x2\x2\xCC2\xCC4\x3\x2\x2\x2\xCC3\xCC1"+
		"\x3\x2\x2\x2\xCC4\xCC5\x5\x19C\xCF\x2\xCC5\x193\x3\x2\x2\x2\xCC6\xCC8"+
		"\x5\x196\xCC\x2\xCC7\xCC6\x3\x2\x2\x2\xCC7\xCC8\x3\x2\x2\x2\xCC8\xCC9"+
		"\x3\x2\x2\x2\xCC9\xCCA\as\x2\x2\xCCA\xCCB\a/\x2\x2\xCCB\xCCC\x5\x198\xCD"+
		"\x2\xCCC\xCCD\a\xE2\x2\x2\xCCD\xCCE\x5\x198\xCD\x2\xCCE\x195\x3\x2\x2"+
		"\x2\xCCF\xCD0\a\x122\x2\x2\xCD0\xCD1\a/\x2\x2\xCD1\xCD2\x5\x198\xCD\x2"+
		"\xCD2\x197\x3\x2\x2\x2\xCD3\xCD4\a\x1FE\x2\x2\xCD4\xCD9\x5\x19A\xCE\x2"+
		"\xCD5\xCD6\a\x204\x2\x2\xCD6\xCD8\x5\x19A\xCE\x2\xCD7\xCD5\x3\x2\x2\x2"+
		"\xCD8\xCDB\x3\x2\x2\x2\xCD9\xCD7\x3\x2\x2\x2\xCD9\xCDA\x3\x2\x2\x2\xCDA"+
		"\xCDC\x3\x2\x2\x2\xCDB\xCD9\x3\x2\x2\x2\xCDC\xCDD\a\x1FF\x2\x2\xCDD\x199"+
		"\x3\x2\x2\x2\xCDE\xCE0\x5\x202\x102\x2\xCDF\xCE1\x5\x28E\x148\x2\xCE0"+
		"\xCDF\x3\x2\x2\x2\xCE0\xCE1\x3\x2\x2\x2\xCE1\x19B\x3\x2\x2\x2\xCE2\xCE4"+
		"\x5\x19E\xD0\x2\xCE3\xCE2\x3\x2\x2\x2\xCE3\xCE4\x3\x2\x2\x2\xCE4\xCE5"+
		"\x3\x2\x2\x2\xCE5\xCE6\a\x1FE\x2\x2\xCE6\xCEB\x5\x1A0\xD1\x2\xCE7\xCE8"+
		"\a\x204\x2\x2\xCE8\xCEA\x5\x1A0\xD1\x2\xCE9\xCE7\x3\x2\x2\x2\xCEA\xCED"+
		"\x3\x2\x2\x2\xCEB\xCE9\x3\x2\x2\x2\xCEB\xCEC\x3\x2\x2\x2\xCEC\xCEE\x3"+
		"\x2\x2\x2\xCED\xCEB\x3\x2\x2\x2\xCEE\xCEF\a\x1FF\x2\x2\xCEF\x19D\x3\x2"+
		"\x2\x2\xCF0\xCF6\a\x154\x2\x2\xCF1\xCF7\a\x1A7\x2\x2\xCF2\xCF4\a\x1A9"+
		"\x2\x2\xCF3\xCF5\a\xF\x2\x2\xCF4\xCF3\x3\x2\x2\x2\xCF4\xCF5\x3\x2\x2\x2"+
		"\xCF5\xCF7\x3\x2\x2\x2\xCF6\xCF1\x3\x2\x2\x2\xCF6\xCF2\x3\x2\x2\x2\xCF6"+
		"\xCF7\x3\x2\x2\x2\xCF7\xCFA\x3\x2\x2\x2\xCF8\xCF9\t\'\x2\x2\xCF9\xCFB"+
		"\a\x117\x2\x2\xCFA\xCF8\x3\x2\x2\x2\xCFA\xCFB\x3\x2\x2\x2\xCFB\xCFD\x3"+
		"\x2\x2\x2\xCFC\xCFE\x5\x1A4\xD3\x2\xCFD\xCFC\x3\x2\x2\x2\xCFD\xCFE\x3"+
		"\x2\x2\x2\xCFE\x19F\x3\x2\x2\x2\xCFF\xD05\a\x1A7\x2\x2\xD00\xD02\a\x1A9"+
		"\x2\x2\xD01\xD03\a\xF\x2\x2\xD02\xD01\x3\x2\x2\x2\xD02\xD03\x3\x2\x2\x2"+
		"\xD03\xD05\x3\x2\x2\x2\xD04\xCFF\x3\x2\x2\x2\xD04\xD00\x3\x2\x2\x2\xD04"+
		"\xD05\x3\x2\x2\x2\xD05\xD06\x3\x2\x2\x2\xD06\xD08\x5\x1A2\xD2\x2\xD07"+
		"\xD09\x5\x1A8\xD5\x2\xD08\xD07\x3\x2\x2\x2\xD08\xD09\x3\x2\x2\x2\xD09"+
		"\xD0A\x3\x2\x2\x2\xD0A\xD0B\a\x215\x2\x2\xD0B\xD0C\x5\x202\x102\x2\xD0C"+
		"\x1A1\x3\x2\x2\x2\xD0D\xD0E\x5\x22A\x116\x2\xD0E\x1A3\x3\x2\x2\x2\xD0F"+
		"\xD10\a\xC6\x2\x2\xD10\xD11\a\x1FE\x2\x2\xD11\xD12\x5\x202\x102\x2\xD12"+
		"\xD14\a\x1FF\x2\x2\xD13\xD15\x5\x1A6\xD4\x2\xD14\xD13\x3\x2\x2\x2\xD14"+
		"\xD15\x3\x2\x2\x2\xD15\x1A5\x3\x2\x2\x2\xD16\xD17\a\x1A6\x2\x2\xD17\xD18"+
		"\a\x1FE\x2\x2\xD18\xD19\x5\x1FE\x100\x2\xD19\xD1A\a\x1FF\x2\x2\xD1A\x1A7"+
		"\x3\x2\x2\x2\xD1B\xD1D\a\x117\x2\x2\xD1C\xD1E\a\x16D\x2\x2\xD1D\xD1C\x3"+
		"\x2\x2\x2\xD1D\xD1E\x3\x2\x2\x2\xD1E\xD1F\x3\x2\x2\x2\xD1F\xD20\a/\x2"+
		"\x2\xD20\xD25\x5\x1AA\xD6\x2\xD21\xD22\a\x204\x2\x2\xD22\xD24\x5\x1AA"+
		"\xD6\x2\xD23\xD21\x3\x2\x2\x2\xD24\xD27\x3\x2\x2\x2\xD25\xD23\x3\x2\x2"+
		"\x2\xD25\xD26\x3\x2\x2\x2\xD26\x1A9\x3\x2\x2\x2\xD27\xD25\x3\x2\x2\x2"+
		"\xD28\xD2A\x5\x202\x102\x2\xD29\xD2B\t(\x2\x2\xD2A\xD29\x3\x2\x2\x2\xD2A"+
		"\xD2B\x3\x2\x2\x2\xD2B\xD2E\x3\x2\x2\x2\xD2C\xD2D\a\x108\x2\x2\xD2D\xD2F"+
		"\t)\x2\x2\xD2E\xD2C\x3\x2\x2\x2\xD2E\xD2F\x3\x2\x2\x2\xD2F\x1AB\x3\x2"+
		"\x2\x2\xD30\xD31\a\x9D\x2\x2\xD31\xD33\a\x1A7\x2\x2\xD32\xD34\x5\x1AE"+
		"\xD8\x2\xD33\xD32\x3\x2\x2\x2\xD33\xD34\x3\x2\x2\x2\xD34\xD36\x3\x2\x2"+
		"\x2\xD35\xD37\x5\x1B0\xD9\x2\xD36\xD35\x3\x2\x2\x2\xD36\xD37\x3\x2\x2"+
		"\x2\xD37\x1AD\x3\x2\x2\x2\xD38\xD39\a\x10D\x2\x2\xD39\xD3E\x5\x2D4\x16B"+
		"\x2\xD3A\xD3B\a\x204\x2\x2\xD3B\xD3D\x5\x2D4\x16B\x2\xD3C\xD3A\x3\x2\x2"+
		"\x2\xD3D\xD40\x3\x2\x2\x2\xD3E\xD3C\x3\x2\x2\x2\xD3E\xD3F\x3\x2\x2\x2"+
		"\xD3F\x1AF\x3\x2\x2\x2\xD40\xD3E\x3\x2\x2\x2\xD41\xD42\a\x172\x2\x2\xD42"+
		"\xD47\a\xD8\x2\x2\xD43\xD47\a\x106\x2\x2\xD44\xD45\a\x1B7\x2\x2\xD45\xD47"+
		"\x5\x202\x102\x2\xD46\xD41\x3\x2\x2\x2\xD46\xD43\x3\x2\x2\x2\xD46\xD44"+
		"\x3\x2\x2\x2\xD47\x1B1\x3\x2\x2\x2\xD48\xD49\a\x1A7\x2\x2\xD49\xD4A\x5"+
		"\x1E0\xF1\x2\xD4A\xD4C\x5\x1B4\xDB\x2\xD4B\xD4D\x5\x292\x14A\x2\xD4C\xD4B"+
		"\x3\x2\x2\x2\xD4C\xD4D\x3\x2\x2\x2\xD4D\xD4F\x3\x2\x2\x2\xD4E\xD50\x5"+
		"\x1E2\xF2\x2\xD4F\xD4E\x3\x2\x2\x2\xD4F\xD50\x3\x2\x2\x2\xD50\xD52\x3"+
		"\x2\x2\x2\xD51\xD53\x5\x1E4\xF3\x2\xD52\xD51\x3\x2\x2\x2\xD52\xD53\x3"+
		"\x2\x2\x2\xD53\x1B3\x3\x2\x2\x2\xD54\xD64\a\x167\x2\x2\xD55\xD5A\x5\x1B6"+
		"\xDC\x2\xD56\xD57\a\x204\x2\x2\xD57\xD59\x5\x1B6\xDC\x2\xD58\xD56\x3\x2"+
		"\x2\x2\xD59\xD5C\x3\x2\x2\x2\xD5A\xD58\x3\x2\x2\x2\xD5A\xD5B\x3\x2\x2"+
		"\x2\xD5B\xD65\x3\x2\x2\x2\xD5C\xD5A\x3\x2\x2\x2\xD5D\xD5E\a\x1AE\x2\x2"+
		"\xD5E\xD5F\a\x1FE\x2\x2\xD5F\xD60\x5\x2FC\x17F\x2\xD60\xD61\a\x1FF\x2"+
		"\x2\xD61\xD62\a\x215\x2\x2\xD62\xD63\x5\x202\x102\x2\xD63\xD65\x3\x2\x2"+
		"\x2\xD64\xD55\x3\x2\x2\x2\xD64\xD5D\x3\x2\x2\x2\xD65\x1B5\x3\x2\x2\x2"+
		"\xD66\xD67\x5\x2D4\x16B\x2\xD67\xD68\a\x215\x2\x2\xD68\xD69\x5\x202\x102"+
		"\x2\xD69\xD78\x3\x2\x2\x2\xD6A\xD6B\a\x1FE\x2\x2\xD6B\xD70\x5\x2D4\x16B"+
		"\x2\xD6C\xD6D\a\x204\x2\x2\xD6D\xD6F\x5\x2D4\x16B\x2\xD6E\xD6C\x3\x2\x2"+
		"\x2\xD6F\xD72\x3\x2\x2\x2\xD70\xD6E\x3\x2\x2\x2\xD70\xD71\x3\x2\x2\x2"+
		"\xD71\xD73\x3\x2\x2\x2\xD72\xD70\x3\x2\x2\x2\xD73\xD74\a\x1FF\x2\x2\xD74"+
		"\xD75\a\x215\x2\x2\xD75\xD76\x5\x148\xA5\x2\xD76\xD78\x3\x2\x2\x2\xD77"+
		"\xD66\x3\x2\x2\x2\xD77\xD6A\x3\x2\x2\x2\xD78\x1B7\x3\x2\x2\x2\xD79\xD7B"+
		"\ao\x2\x2\xD7A\xD7C\a\xA0\x2\x2\xD7B\xD7A\x3\x2\x2\x2\xD7B\xD7C\x3\x2"+
		"\x2\x2\xD7C\xD7D\x3\x2\x2\x2\xD7D\xD7F\x5\x1E0\xF1\x2\xD7E\xD80\x5\x292"+
		"\x14A\x2\xD7F\xD7E\x3\x2\x2\x2\xD7F\xD80\x3\x2\x2\x2\xD80\xD82\x3\x2\x2"+
		"\x2\xD81\xD83\x5\x1E2\xF2\x2\xD82\xD81\x3\x2\x2\x2\xD82\xD83\x3\x2\x2"+
		"\x2\xD83\xD85\x3\x2\x2\x2\xD84\xD86\x5\x1E4\xF3\x2\xD85\xD84\x3\x2\x2"+
		"\x2\xD85\xD86\x3\x2\x2\x2\xD86\x1B9\x3\x2\x2\x2\xD87\xD8A\a\xBB\x2\x2"+
		"\xD88\xD8B\x5\x1BC\xDF\x2\xD89\xD8B\x5\x1BE\xE0\x2\xD8A\xD88\x3\x2\x2"+
		"\x2\xD8A\xD89\x3\x2\x2\x2\xD8B\x1BB\x3\x2\x2\x2\xD8C\xD92\x5\x1C8\xE5"+
		"\x2\xD8D\xD8F\x5\x1CA\xE6\x2\xD8E\xD90\x5\x1E2\xF2\x2\xD8F\xD8E\x3\x2"+
		"\x2\x2\xD8F\xD90\x3\x2\x2\x2\xD90\xD93\x3\x2\x2\x2\xD91\xD93\x5\x13E\xA0"+
		"\x2\xD92\xD8D\x3\x2\x2\x2\xD92\xD91\x3\x2\x2\x2\xD93\xD95\x3\x2\x2\x2"+
		"\xD94\xD96\x5\x1E4\xF3\x2\xD95\xD94\x3\x2\x2\x2\xD95\xD96\x3\x2\x2\x2"+
		"\xD96\x1BD\x3\x2\x2\x2\xD97\xD99\a\xF\x2\x2\xD98\xD9A\x5\x1C0\xE1\x2\xD99"+
		"\xD98\x3\x2\x2\x2\xD9A\xD9B\x3\x2\x2\x2\xD9B\xD99\x3\x2\x2\x2\xD9B\xD9C"+
		"\x3\x2\x2\x2\xD9C\xD9F\x3\x2\x2\x2\xD9D\xD9F\x5\x1C2\xE2\x2\xD9E\xD97"+
		"\x3\x2\x2\x2\xD9E\xD9D\x3\x2\x2\x2\xD9F\xDA0\x3\x2\x2\x2\xDA0\xDA1\x5"+
		"\x13E\xA0\x2\xDA1\x1BF\x3\x2\x2\x2\xDA2\xDA4\x5\x1C8\xE5\x2\xDA3\xDA5"+
		"\x5\x1CA\xE6\x2\xDA4\xDA3\x3\x2\x2\x2\xDA4\xDA5\x3\x2\x2\x2\xDA5\xDA7"+
		"\x3\x2\x2\x2\xDA6\xDA8\x5\x1E4\xF3\x2\xDA7\xDA6\x3\x2\x2\x2\xDA7\xDA8"+
		"\x3\x2\x2\x2\xDA8\x1C1\x3\x2\x2\x2\xDA9\xDAB\t*\x2\x2\xDAA\xDA9\x3\x2"+
		"\x2\x2\xDAA\xDAB\x3\x2\x2\x2\xDAB\xDAD\x3\x2\x2\x2\xDAC\xDAE\x5\x1C4\xE3"+
		"\x2\xDAD\xDAC\x3\x2\x2\x2\xDAE\xDAF\x3\x2\x2\x2\xDAF\xDAD\x3\x2\x2\x2"+
		"\xDAF\xDB0\x3\x2\x2\x2\xDB0\xDB2\x3\x2\x2\x2\xDB1\xDB3\x5\x1C6\xE4\x2"+
		"\xDB2\xDB1\x3\x2\x2\x2\xDB2\xDB3\x3\x2\x2\x2\xDB3\x1C3\x3\x2\x2\x2\xDB4"+
		"\xDB5\a\x1BA\x2\x2\xDB5\xDB6\x5\x1FE\x100\x2\xDB6\xDB8\a\x18A\x2\x2\xDB7"+
		"\xDB9\x5\x1C0\xE1\x2\xDB8\xDB7\x3\x2\x2\x2\xDB9\xDBA\x3\x2\x2\x2\xDBA"+
		"\xDB8\x3\x2\x2\x2\xDBA\xDBB\x3\x2\x2\x2\xDBB\x1C5\x3\x2\x2\x2\xDBC\xDBE"+
		"\a}\x2\x2\xDBD\xDBF\x5\x1C0\xE1\x2\xDBE\xDBD\x3\x2\x2\x2\xDBF\xDC0\x3"+
		"\x2\x2\x2\xDC0\xDBE\x3\x2\x2\x2\xDC0\xDC1\x3\x2\x2\x2\xDC1\x1C7\x3\x2"+
		"\x2\x2\xDC2\xDC3\a\xC2\x2\x2\xDC3\xDCF\x5\x1E0\xF1\x2\xDC4\xDC5\a\x1FE"+
		"\x2\x2\xDC5\xDCA\x5\x2D4\x16B\x2\xDC6\xDC7\a\x204\x2\x2\xDC7\xDC9\x5\x2D4"+
		"\x16B\x2\xDC8\xDC6\x3\x2\x2\x2\xDC9\xDCC\x3\x2\x2\x2\xDCA\xDC8\x3\x2\x2"+
		"\x2\xDCA\xDCB\x3\x2\x2\x2\xDCB\xDCD\x3\x2\x2\x2\xDCC\xDCA\x3\x2\x2\x2"+
		"\xDCD\xDCE\a\x1FF\x2\x2\xDCE\xDD0\x3\x2\x2\x2\xDCF\xDC4\x3\x2\x2\x2\xDCF"+
		"\xDD0\x3\x2\x2\x2\xDD0\x1C9\x3\x2\x2\x2\xDD1\xDD5\a\x1AF\x2\x2\xDD2\xDD6"+
		"\x5\x1FC\xFF\x2\xDD3\xDD6\x5\x2CE\x168\x2\xDD4\xDD6\x5\x1F8\xFD\x2\xDD5"+
		"\xDD2\x3\x2\x2\x2\xDD5\xDD3\x3\x2\x2\x2\xDD5\xDD4\x3\x2\x2\x2\xDD6\x1CB"+
		"\x3\x2\x2\x2\xDD7\xDD8\a\xE4\x2\x2\xDD8\xDD9\a\xC2\x2\x2\xDD9\xDDB\x5"+
		"\x2D6\x16C\x2\xDDA\xDDC\x5\x28E\x148\x2\xDDB\xDDA\x3\x2\x2\x2\xDDB\xDDC"+
		"\x3\x2\x2\x2\xDDC\xDDD\x3\x2\x2\x2\xDDD\xDDE\a\x1AC\x2\x2\xDDE\xDDF\x5"+
		"\x1D6\xEC\x2\xDDF\xDE0\a\x111\x2\x2\xDE0\xDE1\a\x1FE\x2\x2\xDE1\xDE2\x5"+
		"\x1FE\x100\x2\xDE2\xDEB\a\x1FF\x2\x2\xDE3\xDE5\x5\x1CE\xE8\x2\xDE4\xDE6"+
		"\x5\x1D4\xEB\x2\xDE5\xDE4\x3\x2\x2\x2\xDE5\xDE6\x3\x2\x2\x2\xDE6\xDEC"+
		"\x3\x2\x2\x2\xDE7\xDE9\x5\x1D4\xEB\x2\xDE8\xDEA\x5\x1CE\xE8\x2\xDE9\xDE8"+
		"\x3\x2\x2\x2\xDE9\xDEA\x3\x2\x2\x2\xDEA\xDEC\x3\x2\x2\x2\xDEB\xDE3\x3"+
		"\x2\x2\x2\xDEB\xDE7\x3\x2\x2\x2\xDEB\xDEC\x3\x2\x2\x2\xDEC\xDEE\x3\x2"+
		"\x2\x2\xDED\xDEF\x5\x1E4\xF3\x2\xDEE\xDED\x3\x2\x2\x2\xDEE\xDEF\x3\x2"+
		"\x2\x2\xDEF\x1CD\x3\x2\x2\x2\xDF0\xDF1\a\x1BA\x2\x2\xDF1\xDF2\a\xE0\x2"+
		"\x2\xDF2\xDF3\a\x18A\x2\x2\xDF3\xDF4\a\x1A7\x2\x2\xDF4\xDF5\a\x167\x2"+
		"\x2\xDF5\xDFA\x5\x1D0\xE9\x2\xDF6\xDF7\a\x204\x2\x2\xDF7\xDF9\x5\x1D0"+
		"\xE9\x2\xDF8\xDF6\x3\x2\x2\x2\xDF9\xDFC\x3\x2\x2\x2\xDFA\xDF8\x3\x2\x2"+
		"\x2\xDFA\xDFB\x3\x2\x2\x2\xDFB\xDFE\x3\x2\x2\x2\xDFC\xDFA\x3\x2\x2\x2"+
		"\xDFD\xDFF\x5\x292\x14A\x2\xDFE\xDFD\x3\x2\x2\x2\xDFE\xDFF\x3\x2\x2\x2"+
		"\xDFF\xE01\x3\x2\x2\x2\xE00\xE02\x5\x1D2\xEA\x2\xE01\xE00\x3\x2\x2\x2"+
		"\xE01\xE02\x3\x2\x2\x2\xE02\x1CF\x3\x2\x2\x2\xE03\xE04\x5\x2D4\x16B\x2"+
		"\xE04\xE05\a\x215\x2\x2\xE05\xE06\x5\x202\x102\x2\xE06\x1D1\x3\x2\x2\x2"+
		"\xE07\xE08\ao\x2\x2\xE08\xE09\x5\x292\x14A\x2\xE09\x1D3\x3\x2\x2\x2\xE0A"+
		"\xE0B\a\x1BA\x2\x2\xE0B\xE0C\a\x105\x2\x2\xE0C\xE0D\a\xE0\x2\x2\xE0D\xE0E"+
		"\a\x18A\x2\x2\xE0E\xE1A\a\xBB\x2\x2\xE0F\xE10\a\x1FE\x2\x2\xE10\xE15\x5"+
		"\x2D4\x16B\x2\xE11\xE12\a\x204\x2\x2\xE12\xE14\x5\x2D4\x16B\x2\xE13\xE11"+
		"\x3\x2\x2\x2\xE14\xE17\x3\x2\x2\x2\xE15\xE13\x3\x2\x2\x2\xE15\xE16\x3"+
		"\x2\x2\x2\xE16\xE18\x3\x2\x2\x2\xE17\xE15\x3\x2\x2\x2\xE18\xE19\a\x1FF"+
		"\x2\x2\xE19\xE1B\x3\x2\x2\x2\xE1A\xE0F\x3\x2\x2\x2\xE1A\xE1B\x3\x2\x2"+
		"\x2\xE1B\xE1C\x3\x2\x2\x2\xE1C\xE1D\a\x1AF\x2\x2\xE1D\xE1F\x5\x1FC\xFF"+
		"\x2\xE1E\xE20\x5\x292\x14A\x2\xE1F\xE1E\x3\x2\x2\x2\xE1F\xE20\x3\x2\x2"+
		"\x2\xE20\x1D5\x3\x2\x2\x2\xE21\xE27\x5\x2D6\x16C\x2\xE22\xE23\a\x1FE\x2"+
		"\x2\xE23\xE24\x5\x13E\xA0\x2\xE24\xE25\a\x1FF\x2\x2\xE25\xE27\x3\x2\x2"+
		"\x2\xE26\xE21\x3\x2\x2\x2\xE26\xE22\x3\x2\x2\x2\xE27\xE29\x3\x2\x2\x2"+
		"\xE28\xE2A\x5\x28E\x148\x2\xE29\xE28\x3\x2\x2\x2\xE29\xE2A\x3\x2\x2\x2"+
		"\xE2A\x1D7\x3\x2\x2\x2\xE2B\xE2C\a\xD7\x2\x2\xE2C\xE2D\a\x188\x2\x2\xE2D"+
		"\xE32\x5\x1DC\xEF\x2\xE2E\xE2F\a\x204\x2\x2\xE2F\xE31\x5\x1DC\xEF\x2\xE30"+
		"\xE2E\x3\x2\x2\x2\xE31\xE34\x3\x2\x2\x2\xE32\xE30\x3\x2\x2\x2\xE32\xE33"+
		"\x3\x2\x2\x2\xE33\xE35\x3\x2\x2\x2\xE34\xE32\x3\x2\x2\x2\xE35\xE36\a\xAE"+
		"\x2\x2\xE36\xE37\x5\x1DE\xF0\x2\xE37\xE39\a\xEA\x2\x2\xE38\xE3A\x5\x1DA"+
		"\xEE\x2\xE39\xE38\x3\x2\x2\x2\xE39\xE3A\x3\x2\x2\x2\xE3A\x1D9\x3\x2\x2"+
		"\x2\xE3B\xE3C\a\x1B7\x2\x2\xE3C\xE3F\x5\x202\x102\x2\xE3D\xE3F\a\x106"+
		"\x2\x2\xE3E\xE3B\x3\x2\x2\x2\xE3E\xE3D\x3\x2\x2\x2\xE3F\x1DB\x3\x2\x2"+
		"\x2\xE40\xE42\x5\x2D6\x16C\x2\xE41\xE43\x5\x28A\x146\x2\xE42\xE41\x3\x2"+
		"\x2\x2\xE42\xE43\x3\x2\x2\x2\xE43\x1DD\x3\x2\x2\x2\xE44\xE45\a\x151\x2"+
		"\x2\xE45\xE51\a\x16A\x2\x2\xE46\xE47\a\x151\x2\x2\xE47\xE51\a\x8C\x2\x2"+
		"\xE48\xE4A\a\x16A\x2\x2\xE49\xE4B\a\x1A7\x2\x2\xE4A\xE49\x3\x2\x2\x2\xE4A"+
		"\xE4B\x3\x2\x2\x2\xE4B\xE51\x3\x2\x2\x2\xE4C\xE4D\a\x16A\x2\x2\xE4D\xE4E"+
		"\a\x151\x2\x2\xE4E\xE51\a\x8C\x2\x2\xE4F\xE51\a\x8C\x2\x2\xE50\xE44\x3"+
		"\x2\x2\x2\xE50\xE46\x3\x2\x2\x2\xE50\xE48\x3\x2\x2\x2\xE50\xE4C\x3\x2"+
		"\x2\x2\xE50\xE4F\x3\x2\x2\x2\xE51\x1DF\x3\x2\x2\x2\xE52\xE59\x5\x1EA\xF6"+
		"\x2\xE53\xE54\a\x112\x2\x2\xE54\xE55\a\x1FE\x2\x2\xE55\xE56\x5\x1EA\xF6"+
		"\x2\xE56\xE57\a\x1FF\x2\x2\xE57\xE59\x3\x2\x2\x2\xE58\xE52\x3\x2\x2\x2"+
		"\xE58\xE53\x3\x2\x2\x2\xE59\xE5B\x3\x2\x2\x2\xE5A\xE5C\x5\x28E\x148\x2"+
		"\xE5B\xE5A\x3\x2\x2\x2\xE5B\xE5C\x3\x2\x2\x2\xE5C\x1E1\x3\x2\x2\x2\xE5D"+
		"\xE5E\t\x17\x2\x2\xE5E\xE63\x5\x202\x102\x2\xE5F\xE60\a\x204\x2\x2\xE60"+
		"\xE62\x5\x202\x102\x2\xE61\xE5F\x3\x2\x2\x2\xE62\xE65\x3\x2\x2\x2\xE63"+
		"\xE61\x3\x2\x2\x2\xE63\xE64\x3\x2\x2\x2\xE64\xE66\x3\x2\x2\x2\xE65\xE63"+
		"\x3\x2\x2\x2\xE66\xE67\x5\x298\x14D\x2\xE67\x1E3\x3\x2\x2\x2\xE68\xE69"+
		"\a\xD9\x2\x2\xE69\xE6B\a\x84\x2\x2\xE6A\xE6C\x5\x1E6\xF4\x2\xE6B\xE6A"+
		"\x3\x2\x2\x2\xE6B\xE6C\x3\x2\x2\x2\xE6C\xE6E\x3\x2\x2\x2\xE6D\xE6F\x5"+
		"\x204\x103\x2\xE6E\xE6D\x3\x2\x2\x2\xE6E\xE6F\x3\x2\x2\x2\xE6F\xE71\x3"+
		"\x2\x2\x2\xE70\xE72\x5\x1E8\xF5\x2\xE71\xE70\x3\x2\x2\x2\xE71\xE72\x3"+
		"\x2\x2\x2\xE72\x1E5\x3\x2\x2\x2\xE73\xE74\a\xC2\x2\x2\xE74\xE75\x5\x2D6"+
		"\x16C\x2\xE75\x1E7\x3\x2\x2\x2\xE76\xE77\a\x141\x2\x2\xE77\xE7A\a\xD5"+
		"\x2\x2\xE78\xE7B\a\x1A4\x2\x2\xE79\xE7B\x5\x204\x103\x2\xE7A\xE78\x3\x2"+
		"\x2\x2\xE7A\xE79\x3\x2\x2\x2\xE7B\x1E9\x3\x2\x2\x2\xE7C\xE89\x5\x1EC\xF7"+
		"\x2\xE7D\xE7E\a\x1FE\x2\x2\xE7E\xE80\x5\x13E\xA0\x2\xE7F\xE81\x5\x1EE"+
		"\xF8\x2\xE80\xE7F\x3\x2\x2\x2\xE80\xE81\x3\x2\x2\x2\xE81\xE82\x3\x2\x2"+
		"\x2\xE82\xE83\a\x1FF\x2\x2\xE83\xE89\x3\x2\x2\x2\xE84\xE86\x5\x2D6\x16C"+
		"\x2\xE85\xE87\x5\x1F0\xF9\x2\xE86\xE85\x3\x2\x2\x2\xE86\xE87\x3\x2\x2"+
		"\x2\xE87\xE89\x3\x2\x2\x2\xE88\xE7C\x3\x2\x2\x2\xE88\xE7D\x3\x2\x2\x2"+
		"\xE88\xE84\x3\x2\x2\x2\xE89\x1EB\x3\x2\x2\x2\xE8A\xE97\t+\x2\x2\xE8B\xE8C"+
		"\a\x1FE\x2\x2\xE8C\xE8D\x5\x148\xA5\x2\xE8D\xE8E\a\x1FF\x2\x2\xE8E\xE98"+
		"\x3\x2\x2\x2\xE8F\xE90\a\x1FE\x2\x2\xE90\xE91\x5\x202\x102\x2\xE91\xE95"+
		"\a\x1FF\x2\x2\xE92\xE93\a\x1FE\x2\x2\xE93\xE94\a\x202\x2\x2\xE94\xE96"+
		"\a\x1FF\x2\x2\xE95\xE92\x3\x2\x2\x2\xE95\xE96\x3\x2\x2\x2\xE96\xE98\x3"+
		"\x2\x2\x2\xE97\xE8B\x3\x2\x2\x2\xE97\xE8F\x3\x2\x2\x2\xE98\x1ED\x3\x2"+
		"\x2\x2\xE99\xEA2\a\x1BE\x2\x2\xE9A\xE9B\a\x13B\x2\x2\xE9B\xEA3\a\x112"+
		"\x2\x2\xE9C\xE9D\a;\x2\x2\xE9D\xEA0\a\x114\x2\x2\xE9E\xE9F\aK\x2\x2\xE9F"+
		"\xEA1\x5\x2B8\x15D\x2\xEA0\xE9E\x3\x2\x2\x2\xEA0\xEA1\x3\x2\x2\x2\xEA1"+
		"\xEA3\x3\x2\x2\x2\xEA2\xE9A\x3\x2\x2\x2\xEA2\xE9C\x3\x2\x2\x2\xEA3\x1EF"+
		"\x3\x2\x2\x2\xEA4\xEA6\a\x155\x2\x2\xEA5\xEA7\a)\x2\x2\xEA6\xEA5\x3\x2"+
		"\x2\x2\xEA6\xEA7\x3\x2\x2\x2\xEA7\xEA8\x3\x2\x2\x2\xEA8\xEA9\a\x1FE\x2"+
		"\x2\xEA9\xEAC\x5\x202\x102\x2\xEAA\xEAB\a\x204\x2\x2\xEAB\xEAD\x5\x202"+
		"\x102\x2\xEAC\xEAA\x3\x2\x2\x2\xEAC\xEAD\x3\x2\x2\x2\xEAD\xEAE\x3\x2\x2"+
		"\x2\xEAE\xEB0\a\x1FF\x2\x2\xEAF\xEB1\x5\x1F2\xFA\x2\xEB0\xEAF\x3\x2\x2"+
		"\x2\xEB0\xEB1\x3\x2\x2\x2\xEB1\x1F1\x3\x2\x2\x2\xEB2\xEB3\a\x15D\x2\x2"+
		"\xEB3\xEB4\a\x1FE\x2\x2\xEB4\xEB5\x5\x202\x102\x2\xEB5\xEB6\a\x1FF\x2"+
		"\x2\xEB6\x1F3\x3\x2\x2\x2\xEB7\xEB8\a[\x2\x2\xEB8\xEB9\a\x1FE\x2\x2\xEB9"+
		"\xEBA\x5\x148\xA5\x2\xEBA\xEBB\a\x1FF\x2\x2\xEBB\xECA\x3\x2\x2\x2\xEBC"+
		"\xEBD\x5\x2CC\x167\x2\xEBD\xEBE\a\x129\x2\x2\xEBE\xECA\x3\x2\x2\x2\xEBF"+
		"\xEC0\x5\x2CC\x167\x2\xEC0\xEC1\a\x128\x2\x2\xEC1\xECA\x3\x2\x2\x2\xEC2"+
		"\xEC3\x5\x2CC\x167\x2\xEC3\xEC4\a\x125\x2\x2\xEC4\xECA\x3\x2\x2\x2\xEC5"+
		"\xEC6\x5\x2CC\x167\x2\xEC6\xEC7\a\x12A\x2\x2\xEC7\xECA\x3\x2\x2\x2\xEC8"+
		"\xECA\x5\x1F6\xFC\x2\xEC9\xEB7\x3\x2\x2\x2\xEC9\xEBC\x3\x2\x2\x2\xEC9"+
		"\xEBF\x3\x2\x2\x2\xEC9\xEC2\x3\x2\x2\x2\xEC9\xEC5\x3\x2\x2\x2\xEC9\xEC8"+
		"\x3\x2\x2\x2\xECA\x1F5\x3\x2\x2\x2\xECB\xECC\a\x179\x2\x2\xECC\x1F7\x3"+
		"\x2\x2\x2\xECD\xED4\x5\x2D0\x169\x2\xECE\xECF\a\x1FE\x2\x2\xECF\xED0\x5"+
		"\x202\x102\x2\xED0\xED1\a\x1FF\x2\x2\xED1\xED3\x3\x2\x2\x2\xED2\xECE\x3"+
		"\x2\x2\x2\xED3\xED6\x3\x2\x2\x2\xED4\xED2\x3\x2\x2\x2\xED4\xED5\x3\x2"+
		"\x2\x2\xED5\xED9\x3\x2\x2\x2\xED6\xED4\x3\x2\x2\x2\xED7\xED8\a\x1F7\x2"+
		"\x2\xED8\xEDA\x5\x2C8\x165\x2\xED9\xED7\x3\x2\x2\x2\xED9\xEDA\x3\x2\x2"+
		"\x2\xEDA\x1F9\x3\x2\x2\x2\xEDB\xF02\x5\x1F8\xFD\x2\xEDC\xEDD\x5\x1F8\xFD"+
		"\x2\xEDD\xEDE\a\x1F7\x2\x2\xEDE\xEDF\a\x98\x2\x2\xEDF\xF02\x3\x2\x2\x2"+
		"\xEE0\xEE1\x5\x1F8\xFD\x2\xEE1\xEE2\a\x1F7\x2\x2\xEE2\xEE3\a\xCB\x2\x2"+
		"\xEE3\xF02\x3\x2\x2\x2\xEE4\xEE5\x5\x1F8\xFD\x2\xEE5\xEE6\a\x1F7\x2\x2"+
		"\xEE6\xEE7\a\x8E\x2\x2\xEE7\xEE8\a\x1FE\x2\x2\xEE8\xEE9\x5\x202\x102\x2"+
		"\xEE9\xEEA\a\x1FF\x2\x2\xEEA\xF02\x3\x2\x2\x2\xEEB\xEEC\x5\x1F8\xFD\x2"+
		"\xEEC\xEED\a\x1F7\x2\x2\xEED\xEEE\a\x136\x2\x2\xEEE\xEEF\a\x1FE\x2\x2"+
		"\xEEF\xEF0\x5\x202\x102\x2\xEF0\xEF1\a\x1FF\x2\x2\xEF1\xF02\x3\x2\x2\x2"+
		"\xEF2\xEF3\x5\x1F8\xFD\x2\xEF3\xEF4\a\x1F7\x2\x2\xEF4\xEF5\a\xF9\x2\x2"+
		"\xEF5\xEF6\a\x1FE\x2\x2\xEF6\xEF7\x5\x202\x102\x2\xEF7\xEF8\a\x1FF\x2"+
		"\x2\xEF8\xF02\x3\x2\x2\x2\xEF9\xEFA\x5\x1F8\xFD\x2\xEFA\xEFB\a\x1F7\x2"+
		"\x2\xEFB\xEFC\aU\x2\x2\xEFC\xF02\x3\x2\x2\x2\xEFD\xEFE\x5\x1F8\xFD\x2"+
		"\xEFE\xEFF\a\x1F7\x2\x2\xEFF\xF00\a\xD5\x2\x2\xF00\xF02\x3\x2\x2\x2\xF01"+
		"\xEDB\x3\x2\x2\x2\xF01\xEDC\x3\x2\x2\x2\xF01\xEE0\x3\x2\x2\x2\xF01\xEE4"+
		"\x3\x2\x2\x2\xF01\xEEB\x3\x2\x2\x2\xF01\xEF2\x3\x2\x2\x2\xF01\xEF9\x3"+
		"\x2\x2\x2\xF01\xEFD\x3\x2\x2\x2\xF02\x1FB\x3\x2\x2\x2\xF03\xF05\a\x1FE"+
		"\x2\x2\xF04\xF06\x5\x202\x102\x2\xF05\xF04\x3\x2\x2\x2\xF05\xF06\x3\x2"+
		"\x2\x2\xF06\xF0B\x3\x2\x2\x2\xF07\xF08\a\x204\x2\x2\xF08\xF0A\x5\x202"+
		"\x102\x2\xF09\xF07\x3\x2\x2\x2\xF0A\xF0D\x3\x2\x2\x2\xF0B\xF09\x3\x2\x2"+
		"\x2\xF0B\xF0C\x3\x2\x2\x2\xF0C\xF0E\x3\x2\x2\x2\xF0D\xF0B\x3\x2\x2\x2"+
		"\xF0E\xF0F\a\x1FF\x2\x2\xF0F\x1FD\x3\x2\x2\x2\xF10\xF11\x5\x202\x102\x2"+
		"\xF11\x1FF\x3\x2\x2\x2\xF12\xF13\x5\x202\x102\x2\xF13\x201\x3\x2\x2\x2"+
		"\xF14\xF19\x5\x206\x104\x2\xF15\xF16\a\x115\x2\x2\xF16\xF18\x5\x202\x102"+
		"\x2\xF17\xF15\x3\x2\x2\x2\xF18\xF1B\x3\x2\x2\x2\xF19\xF17\x3\x2\x2\x2"+
		"\xF19\xF1A\x3\x2\x2\x2\xF1A\x203\x3\x2\x2\x2\xF1B\xF19\x3\x2\x2\x2\xF1C"+
		"\xF1D\x5\x202\x102\x2\xF1D\x205\x3\x2\x2\x2\xF1E\xF23\x5\x208\x105\x2"+
		"\xF1F\xF20\a\x12\x2\x2\xF20\xF22\x5\x208\x105\x2\xF21\xF1F\x3\x2\x2\x2"+
		"\xF22\xF25\x3\x2\x2\x2\xF23\xF21\x3\x2\x2\x2\xF23\xF24\x3\x2\x2\x2\xF24"+
		"\x207\x3\x2\x2\x2\xF25\xF23\x3\x2\x2\x2\xF26\xF27\a\x105\x2\x2\xF27\xF2A"+
		"\x5\x208\x105\x2\xF28\xF2A\x5\x20A\x106\x2\xF29\xF26\x3\x2\x2\x2\xF29"+
		"\xF28\x3\x2\x2\x2\xF2A\x209\x3\x2\x2\x2\xF2B\xF53\x5\x1FA\xFE\x2\xF2C"+
		"\xF4E\x5\x20E\x108\x2\xF2D\xF2F\a\xC4\x2\x2\xF2E\xF30\a\x105\x2\x2\xF2F"+
		"\xF2E\x3\x2\x2\x2\xF2F\xF30\x3\x2\x2\x2\xF30\xF4A\x3\x2\x2\x2\xF31\xF4B"+
		"\a\x107\x2\x2\xF32\xF4B\a\xF0\x2\x2\xF33\xF4B\a\x135\x2\x2\xF34\xF4B\a"+
		"\xB7\x2\x2\xF35\xF36\a\n\x2\x2\xF36\xF4B\a\x167\x2\x2\xF37\xF4B\a\x7F"+
		"\x2\x2\xF38\xF3A\a\x10D\x2\x2\xF39\xF3B\a\x19F\x2\x2\xF3A\xF39\x3\x2\x2"+
		"\x2\xF3A\xF3B\x3\x2\x2\x2\xF3B\xF3C\x3\x2\x2\x2\xF3C\xF3E\a\x1FE\x2\x2"+
		"\xF3D\xF3F\a\x112\x2\x2\xF3E\xF3D\x3\x2\x2\x2\xF3E\xF3F\x3\x2\x2\x2\xF3F"+
		"\xF40\x3\x2\x2\x2\xF40\xF45\x5\x2E6\x174\x2\xF41\xF42\a\x204\x2\x2\xF42"+
		"\xF44\x5\x2E6\x174\x2\xF43\xF41\x3\x2\x2\x2\xF44\xF47\x3\x2\x2\x2\xF45"+
		"\xF43\x3\x2\x2\x2\xF45\xF46\x3\x2\x2\x2\xF46\xF48\x3\x2\x2\x2\xF47\xF45"+
		"\x3\x2\x2\x2\xF48\xF49\a\x1FF\x2\x2\xF49\xF4B\x3\x2\x2\x2\xF4A\xF31\x3"+
		"\x2\x2\x2\xF4A\xF32\x3\x2\x2\x2\xF4A\xF33\x3\x2\x2\x2\xF4A\xF34\x3\x2"+
		"\x2\x2\xF4A\xF35\x3\x2\x2\x2\xF4A\xF37\x3\x2\x2\x2\xF4A\xF38\x3\x2\x2"+
		"\x2\xF4B\xF4D\x3\x2\x2\x2\xF4C\xF2D\x3\x2\x2\x2\xF4D\xF50\x3\x2\x2\x2"+
		"\xF4E\xF4C\x3\x2\x2\x2\xF4E\xF4F\x3\x2\x2\x2\xF4F\xF53\x3\x2\x2\x2\xF50"+
		"\xF4E\x3\x2\x2\x2\xF51\xF53\x5\x1F4\xFB\x2\xF52\xF2B\x3\x2\x2\x2\xF52"+
		"\xF2C\x3\x2\x2\x2\xF52\xF51\x3\x2\x2\x2\xF53\x20B\x3\x2\x2\x2\xF54\xF58"+
		"\x5\x2D0\x169\x2\xF55\xF58\x5\x1F8\xFD\x2\xF56\xF58\x5\x10C\x87\x2\xF57"+
		"\xF54\x3\x2\x2\x2\xF57\xF55\x3\x2\x2\x2\xF57\xF56\x3\x2\x2\x2\xF58\x20D"+
		"\x3\x2\x2\x2\xF59\xF60\x5\x20C\x107\x2\xF5A\xF5B\a\xEE\x2\x2\xF5B\xF5D"+
		"\t,\x2\x2\xF5C\xF5E\t-\x2\x2\xF5D\xF5C\x3\x2\x2\x2\xF5D\xF5E\x3\x2\x2"+
		"\x2\xF5E\xF5F\x3\x2\x2\x2\xF5F\xF61\x5\x20C\x107\x2\xF60\xF5A\x3\x2\x2"+
		"\x2\xF61\xF62\x3\x2\x2\x2\xF62\xF60\x3\x2\x2\x2\xF62\xF63\x3\x2\x2\x2"+
		"\xF63\xF71\x3\x2\x2\x2\xF64\xF6E\x5\x212\x10A\x2\xF65\xF67\a\x105\x2\x2"+
		"\xF66\xF65\x3\x2\x2\x2\xF66\xF67\x3\x2\x2\x2\xF67\xF68\x3\x2\x2\x2\xF68"+
		"\xF6A\x5\x210\x109\x2\xF69\xF6B\a\x10D\x2\x2\xF6A\xF69\x3\x2\x2\x2\xF6A"+
		"\xF6B\x3\x2\x2\x2\xF6B\xF6C\x3\x2\x2\x2\xF6C\xF6D\x5\x21E\x110\x2\xF6D"+
		"\xF6F\x3\x2\x2\x2\xF6E\xF66\x3\x2\x2\x2\xF6E\xF6F\x3\x2\x2\x2\xF6F\xF71"+
		"\x3\x2\x2\x2\xF70\xF59\x3\x2\x2\x2\xF70\xF64\x3\x2\x2\x2\xF71\x20F\x3"+
		"\x2\x2\x2\xF72\xF73\t.\x2\x2\xF73\x211\x3\x2\x2\x2\xF74\xF80\x5\x214\x10B"+
		"\x2\xF75\xF7C\a\x215\x2\x2\xF76\xF7C\x5\x300\x181\x2\xF77\xF7C\a\x20C"+
		"\x2\x2\xF78\xF7C\a\x212\x2\x2\xF79\xF7C\x5\x304\x183\x2\xF7A\xF7C\x5\x302"+
		"\x182\x2\xF7B\xF75\x3\x2\x2\x2\xF7B\xF76\x3\x2\x2\x2\xF7B\xF77\x3\x2\x2"+
		"\x2\xF7B\xF78\x3\x2\x2\x2\xF7B\xF79\x3\x2\x2\x2\xF7B\xF7A\x3\x2\x2\x2"+
		"\xF7C\xF7D\x3\x2\x2\x2\xF7D\xF7F\x5\x214\x10B\x2\xF7E\xF7B\x3\x2\x2\x2"+
		"\xF7F\xF82\x3\x2\x2\x2\xF80\xF7E\x3\x2\x2\x2\xF80\xF81\x3\x2\x2\x2\xF81"+
		"\x213\x3\x2\x2\x2\xF82\xF80\x3\x2\x2\x2\xF83\xF92\x5\x21E\x110\x2\xF84"+
		"\xF86\a\x105\x2\x2\xF85\xF84\x3\x2\x2\x2\xF85\xF86\x3\x2\x2\x2\xF86\xF90"+
		"\x3\x2\x2\x2\xF87\xF88\a\xAE\x2\x2\xF88\xF91\x5\x21A\x10E\x2\xF89\xF8A"+
		"\a#\x2\x2\xF8A\xF91\x5\x21C\x10F\x2\xF8B\xF8C\x5\x216\x10C\x2\xF8C\xF8E"+
		"\x5\x21E\x110\x2\xF8D\xF8F\x5\x218\x10D\x2\xF8E\xF8D\x3\x2\x2\x2\xF8E"+
		"\xF8F\x3\x2\x2\x2\xF8F\xF91\x3\x2\x2\x2\xF90\xF87\x3\x2\x2\x2\xF90\xF89"+
		"\x3\x2\x2\x2\xF90\xF8B\x3\x2\x2\x2\xF91\xF93\x3\x2\x2\x2\xF92\xF85\x3"+
		"\x2\x2\x2\xF92\xF93\x3\x2\x2\x2\xF93\xF96\x3\x2\x2\x2\xF94\xF96\x5\x10C"+
		"\x87\x2\xF95\xF83\x3\x2\x2\x2\xF95\xF94\x3\x2\x2\x2\xF96\x215\x3\x2\x2"+
		"\x2\xF97\xF98\t/\x2\x2\xF98\x217\x3\x2\x2\x2\xF99\xF9A\a\x85\x2\x2\xF9A"+
		"\xF9B\x5\x21E\x110\x2\xF9B\x219\x3\x2\x2\x2\xF9C\xF9D\a\x1FE\x2\x2\xF9D"+
		"\xF9E\x5\x148\xA5\x2\xF9E\xF9F\a\x1FF\x2\x2\xF9F\xFAF\x3\x2\x2\x2\xFA0"+
		"\xFA1\a\x1FE\x2\x2\xFA1\xFA6\x5\x220\x111\x2\xFA2\xFA3\a\x204\x2\x2\xFA3"+
		"\xFA5\x5\x220\x111\x2\xFA4\xFA2\x3\x2\x2\x2\xFA5\xFA8\x3\x2\x2\x2\xFA6"+
		"\xFA4\x3\x2\x2\x2\xFA6\xFA7\x3\x2\x2\x2\xFA7\xFA9\x3\x2\x2\x2\xFA8\xFA6"+
		"\x3\x2\x2\x2\xFA9\xFAA\a\x1FF\x2\x2\xFAA\xFAF\x3\x2\x2\x2\xFAB\xFAF\x5"+
		"\x2F6\x17C\x2\xFAC\xFAF\x5\x2EE\x178\x2\xFAD\xFAF\x5\x2F0\x179\x2\xFAE"+
		"\xF9C\x3\x2\x2\x2\xFAE\xFA0\x3\x2\x2\x2\xFAE\xFAB\x3\x2\x2\x2\xFAE\xFAC"+
		"\x3\x2\x2\x2\xFAE\xFAD\x3\x2\x2\x2\xFAF\x21B\x3\x2\x2\x2\xFB0\xFB1\x5"+
		"\x21E\x110\x2\xFB1\xFB2\a\x12\x2\x2\xFB2\xFB3\x5\x21E\x110\x2\xFB3\x21D"+
		"\x3\x2\x2\x2\xFB4\xFBA\x5\x222\x112\x2\xFB5\xFB6\x5\x306\x184\x2\xFB6"+
		"\xFB7\x5\x222\x112\x2\xFB7\xFB9\x3\x2\x2\x2\xFB8\xFB5\x3\x2\x2\x2\xFB9"+
		"\xFBC\x3\x2\x2\x2\xFBA\xFB8\x3\x2\x2\x2\xFBA\xFBB\x3\x2\x2\x2\xFBB\x21F"+
		"\x3\x2\x2\x2\xFBC\xFBA\x3\x2\x2\x2\xFBD\xFBE\x5\x21E\x110\x2\xFBE\x221"+
		"\x3\x2\x2\x2\xFBF\xFC4\x5\x224\x113\x2\xFC0\xFC1\t\x30\x2\x2\xFC1\xFC3"+
		"\x5\x224\x113\x2\xFC2\xFC0\x3\x2\x2\x2\xFC3\xFC6\x3\x2\x2\x2\xFC4\xFC2"+
		"\x3\x2\x2\x2\xFC4\xFC5\x3\x2\x2\x2\xFC5\x223\x3\x2\x2\x2\xFC6\xFC4\x3"+
		"\x2\x2\x2\xFC7\xFCC\x5\x226\x114\x2\xFC8\xFC9\t\x31\x2\x2\xFC9\xFCB\x5"+
		"\x226\x114\x2\xFCA\xFC8\x3\x2\x2\x2\xFCB\xFCE\x3\x2\x2\x2\xFCC\xFCA\x3"+
		"\x2\x2\x2\xFCC\xFCD\x3\x2\x2\x2\xFCD\x225\x3\x2\x2\x2\xFCE\xFCC\x3\x2"+
		"\x2\x2\xFCF\xFD8\x5\x22A\x116\x2\xFD0\xFD5\a\x19\x2\x2\xFD1\xFD6\a\xD6"+
		"\x2\x2\xFD2\xFD3\a\x18B\x2\x2\xFD3\xFD4\a\x1D4\x2\x2\xFD4\xFD6\x5\x220"+
		"\x111\x2\xFD5\xFD1\x3\x2\x2\x2\xFD5\xFD2\x3\x2\x2\x2\xFD6\xFD9\x3\x2\x2"+
		"\x2\xFD7\xFD9\x5\x228\x115\x2\xFD8\xFD0\x3\x2\x2\x2\xFD8\xFD7\x3\x2\x2"+
		"\x2\xFD8\xFD9\x3\x2\x2\x2\xFD9\x227\x3\x2\x2\x2\xFDA\xFDF\a\x61\x2\x2"+
		"\xFDB\xFDC\a\x1FE\x2\x2\xFDC\xFDD\x5\x220\x111\x2\xFDD\xFDE\a\x1FF\x2"+
		"\x2\xFDE\xFE0\x3\x2\x2\x2\xFDF\xFDB\x3\x2\x2\x2\xFDF\xFE0\x3\x2\x2\x2"+
		"\xFE0\xFE1\x3\x2\x2\x2\xFE1\xFE2\a\x194\x2\x2\xFE2\xFE7\a\x15C\x2\x2\xFE3"+
		"\xFE4\a\x1FE\x2\x2\xFE4\xFE5\x5\x220\x111\x2\xFE5\xFE6\a\x1FF\x2\x2\xFE6"+
		"\xFE8\x3\x2\x2\x2\xFE7\xFE3\x3\x2\x2\x2\xFE7\xFE8\x3\x2\x2\x2\xFE8\xFF3"+
		"\x3\x2\x2\x2\xFE9\xFEE\a\x1D1\x2\x2\xFEA\xFEB\a\x1FE\x2\x2\xFEB\xFEC\x5"+
		"\x220\x111\x2\xFEC\xFED\a\x1FF\x2\x2\xFED\xFEF\x3\x2\x2\x2\xFEE\xFEA\x3"+
		"\x2\x2\x2\xFEE\xFEF\x3\x2\x2\x2\xFEF\xFF0\x3\x2\x2\x2\xFF0\xFF1\a\x194"+
		"\x2\x2\xFF1\xFF3\a\xED\x2\x2\xFF2\xFDA\x3\x2\x2\x2\xFF2\xFE9\x3\x2\x2"+
		"\x2\xFF3\x229\x3\x2\x2\x2\xFF4\xFF9\x5\x236\x11C\x2\xFF5\xFF6\a\x216\x2"+
		"\x2\xFF6\xFF7\x5\x22C\x117\x2\xFF7\xFF8\a\x217\x2\x2\xFF8\xFFA\x3\x2\x2"+
		"\x2\xFF9\xFF5\x3\x2\x2\x2\xFF9\xFFA\x3\x2\x2\x2\xFFA\x22B\x3\x2\x2\x2"+
		"\xFFB\xFFE\a\x13\x2\x2\xFFC\xFFE\x5\x200\x101\x2\xFFD\xFFB\x3\x2\x2\x2"+
		"\xFFD\xFFC\x3\x2\x2\x2\xFFE\x1006\x3\x2\x2\x2\xFFF\x1002\a\x204\x2\x2"+
		"\x1000\x1003\a\x13\x2\x2\x1001\x1003\x5\x200\x101\x2\x1002\x1000\x3\x2"+
		"\x2\x2\x1002\x1001\x3\x2\x2\x2\x1003\x1005\x3\x2\x2\x2\x1004\xFFF\x3\x2"+
		"\x2\x2\x1005\x1008\x3\x2\x2\x2\x1006\x1004\x3\x2\x2\x2\x1006\x1007\x3"+
		"\x2\x2\x2\x1007\x1013\x3\x2\x2\x2\x1008\x1006\x3\x2\x2\x2\x1009\x100E"+
		"\x5\x22E\x118\x2\x100A\x100B\a\x204\x2\x2\x100B\x100D\x5\x22E\x118\x2"+
		"\x100C\x100A\x3\x2\x2\x2\x100D\x1010\x3\x2\x2\x2\x100E\x100C\x3\x2\x2"+
		"\x2\x100E\x100F\x3\x2\x2\x2\x100F\x1013\x3\x2\x2\x2\x1010\x100E\x3\x2"+
		"\x2\x2\x1011\x1013\x5\x234\x11B\x2\x1012\xFFD\x3\x2\x2\x2\x1012\x1009"+
		"\x3\x2\x2\x2\x1012\x1011\x3\x2\x2\x2\x1013\x22D\x3\x2\x2\x2\x1014\x1015"+
		"\a\x9D\x2\x2\x1015\x1022\x5\x2D4\x16B\x2\x1016\x1017\a\xAE\x2\x2\x1017"+
		"\x1023\x5\x1FC\xFF\x2\x1018\x101A\x5\x230\x119\x2\x1019\x1018\x3\x2\x2"+
		"\x2\x1019\x101A\x3\x2\x2\x2\x101A\x101B\x3\x2\x2\x2\x101B\x101C\a\xA0"+
		"\x2\x2\x101C\x101D\x5\x202\x102\x2\x101D\x101E\a\x194\x2\x2\x101E\x101F"+
		"\x5\x202\x102\x2\x101F\x1020\x5\x232\x11A\x2\x1020\x1021\x5\x202\x102"+
		"\x2\x1021\x1023\x3\x2\x2\x2\x1022\x1016\x3\x2\x2\x2\x1022\x1019\x3\x2"+
		"\x2\x2\x1023\x22F\x3\x2\x2\x2\x1024\x1025\a\xD1\x2\x2\x1025\x1026\x5\x202"+
		"\x102\x2\x1026\x231\x3\x2\x2\x2\x1027\x1028\t\x32\x2\x2\x1028\x233\x3"+
		"\x2\x2\x2\x1029\x102A\a\x9D\x2\x2\x102A\x102B\a\x1FE\x2\x2\x102B\x1030"+
		"\x5\x2D4\x16B\x2\x102C\x102D\a\x204\x2\x2\x102D\x102F\x5\x2D4\x16B\x2"+
		"\x102E\x102C\x3\x2\x2\x2\x102F\x1032\x3\x2\x2\x2\x1030\x102E\x3\x2\x2"+
		"\x2\x1030\x1031\x3\x2\x2\x2\x1031\x1033\x3\x2\x2\x2\x1032\x1030\x3\x2"+
		"\x2\x2\x1033\x1034\a\x1FF\x2\x2\x1034\x1035\a\xAE\x2\x2\x1035\x1042\a"+
		"\x1FE\x2\x2\x1036\x1043\x5\x148\xA5\x2\x1037\x1038\a\x1FE\x2\x2\x1038"+
		"\x103D\x5\x1FC\xFF\x2\x1039\x103A\a\x204\x2\x2\x103A\x103C\x5\x1FC\xFF"+
		"\x2\x103B\x1039\x3\x2\x2\x2\x103C\x103F\x3\x2\x2\x2\x103D\x103B\x3\x2"+
		"\x2\x2\x103D\x103E\x3\x2\x2\x2\x103E\x1040\x3\x2\x2\x2\x103F\x103D\x3"+
		"\x2\x2\x2\x1040\x1041\a\x1FF\x2\x2\x1041\x1043\x3\x2\x2\x2\x1042\x1036"+
		"\x3\x2\x2\x2\x1042\x1037\x3\x2\x2\x2\x1043\x1044\x3\x2\x2\x2\x1044\x1045"+
		"\a\x1FF\x2\x2\x1045\x235\x3\x2\x2\x2\x1046\x1047\a\x203\x2\x2\x1047\x1059"+
		"\x5\x236\x11C\x2\x1048\x1049\a\x202\x2\x2\x1049\x1059\x5\x236\x11C\x2"+
		"\x104A\x104B\a\x136\x2\x2\x104B\x1059\x5\x236\x11C\x2\x104C\x104D\aI\x2"+
		"\x2\x104D\x1059\x5\x236\x11C\x2\x104E\x104F\a\xF8\x2\x2\x104F\x1059\x5"+
		"\x236\x11C\x2\x1050\x1051\av\x2\x2\x1051\x1059\x5\x236\x11C\x2\x1052\x1053"+
		"\a\xF\x2\x2\x1053\x1059\x5\x236\x11C\x2\x1054\x1059\x5\x238\x11D\x2\x1055"+
		"\x1059\x5\x24A\x126\x2\x1056\x1059\x5\x254\x12B\x2\x1057\x1059\x5\x244"+
		"\x123\x2\x1058\x1046\x3\x2\x2\x2\x1058\x1048\x3\x2\x2\x2\x1058\x104A\x3"+
		"\x2\x2\x2\x1058\x104C\x3\x2\x2\x2\x1058\x104E\x3\x2\x2\x2\x1058\x1050"+
		"\x3\x2\x2\x2\x1058\x1052\x3\x2\x2\x2\x1058\x1054\x3\x2\x2\x2\x1058\x1055"+
		"\x3\x2\x2\x2\x1058\x1056\x3\x2\x2\x2\x1058\x1057\x3\x2\x2\x2\x1059\x237"+
		"\x3\x2\x2\x2\x105A\x105D\x5\x23E\x120\x2\x105B\x105D\x5\x23A\x11E\x2\x105C"+
		"\x105A\x3\x2\x2\x2\x105C\x105B\x3\x2\x2\x2\x105D\x239\x3\x2\x2\x2\x105E"+
		"\x1060\x5\x2BA\x15E\x2\x105F\x105E\x3\x2\x2\x2\x105F\x1060\x3\x2\x2\x2"+
		"\x1060\x1061\x3\x2\x2\x2\x1061\x1062\a\x36\x2\x2\x1062\x1064\x5\x202\x102"+
		"\x2\x1063\x1065\x5\x23C\x11F\x2\x1064\x1063\x3\x2\x2\x2\x1065\x1066\x3"+
		"\x2\x2\x2\x1066\x1064\x3\x2\x2\x2\x1066\x1067\x3\x2\x2\x2\x1067\x1069"+
		"\x3\x2\x2\x2\x1068\x106A\x5\x242\x122\x2\x1069\x1068\x3\x2\x2\x2\x1069"+
		"\x106A\x3\x2\x2\x2\x106A\x106B\x3\x2\x2\x2\x106B\x106D\a\x82\x2\x2\x106C"+
		"\x106E\a\x36\x2\x2\x106D\x106C\x3\x2\x2\x2\x106D\x106E\x3\x2\x2\x2\x106E"+
		"\x1070\x3\x2\x2\x2\x106F\x1071\x5\x2BA\x15E\x2\x1070\x106F\x3\x2\x2\x2"+
		"\x1070\x1071\x3\x2\x2\x2\x1071\x23B\x3\x2\x2\x2\x1072\x1073\a\x1BA\x2"+
		"\x2\x1073\x1074\x5\x204\x103\x2\x1074\x1077\a\x18A\x2\x2\x1075\x1078\x5"+
		"\xE4s\x2\x1076\x1078\x5\x204\x103\x2\x1077\x1075\x3\x2\x2\x2\x1077\x1076"+
		"\x3\x2\x2\x2\x1078\x23D\x3\x2\x2\x2\x1079\x107B\x5\x2BA\x15E\x2\x107A"+
		"\x1079\x3\x2\x2\x2\x107A\x107B\x3\x2\x2\x2\x107B\x107C\x3\x2\x2\x2\x107C"+
		"\x107E\a\x36\x2\x2\x107D\x107F\x5\x240\x121\x2\x107E\x107D\x3\x2\x2\x2"+
		"\x107F\x1080\x3\x2\x2\x2\x1080\x107E\x3\x2\x2\x2\x1080\x1081\x3\x2\x2"+
		"\x2\x1081\x1083\x3\x2\x2\x2\x1082\x1084\x5\x242\x122\x2\x1083\x1082\x3"+
		"\x2\x2\x2\x1083\x1084\x3\x2\x2\x2\x1084\x1085\x3\x2\x2\x2\x1085\x1087"+
		"\a\x82\x2\x2\x1086\x1088\a\x36\x2\x2\x1087\x1086\x3\x2\x2\x2\x1087\x1088"+
		"\x3\x2\x2\x2\x1088\x108A\x3\x2\x2\x2\x1089\x108B\x5\x2BA\x15E\x2\x108A"+
		"\x1089\x3\x2\x2\x2\x108A\x108B\x3\x2\x2\x2\x108B\x23F\x3\x2\x2\x2\x108C"+
		"\x108D\a\x1BA\x2\x2\x108D\x108E\x5\x200\x101\x2\x108E\x1091\a\x18A\x2"+
		"\x2\x108F\x1092\x5\xE4s\x2\x1090\x1092\x5\x204\x103\x2\x1091\x108F\x3"+
		"\x2\x2\x2\x1091\x1090\x3\x2\x2\x2\x1092\x241\x3\x2\x2\x2\x1093\x1096\a"+
		"}\x2\x2\x1094\x1097\x5\xE4s\x2\x1095\x1097\x5\x204\x103\x2\x1096\x1094"+
		"\x3\x2\x2\x2\x1096\x1095\x3\x2\x2\x2\x1097\x243\x3\x2\x2\x2\x1098\x1099"+
		"\x5\x2F4\x17B\x2\x1099\x109A\x5\x308\x185\x2\x109A\x10AE\x3\x2\x2\x2\x109B"+
		"\x10AE\x5\x2EE\x178\x2\x109C\x10AE\x5\x2F6\x17C\x2\x109D\x10AE\x5\x2F0"+
		"\x179\x2\x109E\x10AA\a\x1FE\x2\x2\x109F\x10A0\x5\x148\xA5\x2\x10A0\x10A4"+
		"\a\x1FF\x2\x2\x10A1\x10A3\x5\x14A\xA6\x2\x10A2\x10A1\x3\x2\x2\x2\x10A3"+
		"\x10A6\x3\x2\x2\x2\x10A4\x10A2\x3\x2\x2\x2\x10A4\x10A5\x3\x2\x2\x2\x10A5"+
		"\x10AB\x3\x2\x2\x2\x10A6\x10A4\x3\x2\x2\x2\x10A7\x10A8\x5\x246\x124\x2"+
		"\x10A8\x10A9\a\x1FF\x2\x2\x10A9\x10AB\x3\x2\x2\x2\x10AA\x109F\x3\x2\x2"+
		"\x2\x10AA\x10A7\x3\x2\x2\x2\x10AB\x10AE\x3\x2\x2\x2\x10AC\x10AE\x5\x1FA"+
		"\xFE\x2\x10AD\x1098\x3\x2\x2\x2\x10AD\x109B\x3\x2\x2\x2\x10AD\x109C\x3"+
		"\x2\x2\x2\x10AD\x109D\x3\x2\x2\x2\x10AD\x109E\x3\x2\x2\x2\x10AD\x10AC"+
		"\x3\x2\x2\x2\x10AE\x245\x3\x2\x2\x2\x10AF\x10B1\x5\x202\x102\x2\x10B0"+
		"\x10B2\x5\x248\x125\x2\x10B1\x10B0\x3\x2\x2\x2\x10B1\x10B2\x3\x2\x2\x2"+
		"\x10B2\x247\x3\x2\x2\x2\x10B3\x10B4\a\x204\x2\x2\x10B4\x10B9\x5\x202\x102"+
		"\x2\x10B5\x10B6\a\x204\x2\x2\x10B6\x10B8\x5\x202\x102\x2\x10B7\x10B5\x3"+
		"\x2\x2\x2\x10B8\x10BB\x3\x2\x2\x2\x10B9\x10B7\x3\x2\x2\x2\x10B9\x10BA"+
		"\x3\x2\x2\x2\x10BA\x249\x3\x2\x2\x2\x10BB\x10B9\x3\x2\x2\x2\x10BC\x10CC"+
		"\t\x33\x2\x2\x10BD\x10BE\a\x1FE\x2\x2\x10BE\x10BF\x5\x148\xA5\x2\x10BF"+
		"\x10C0\a\x1FF\x2\x2\x10C0\x10CD\x3\x2\x2\x2\x10C1\x10C2\a\x1FE\x2\x2\x10C2"+
		"\x10C7\x5\x202\x102\x2\x10C3\x10C4\a\x204\x2\x2\x10C4\x10C6\x5\x202\x102"+
		"\x2\x10C5\x10C3\x3\x2\x2\x2\x10C6\x10C9\x3\x2\x2\x2\x10C7\x10C5\x3\x2"+
		"\x2\x2\x10C7\x10C8\x3\x2\x2\x2\x10C8\x10CA\x3\x2\x2\x2\x10C9\x10C7\x3"+
		"\x2\x2\x2\x10CA\x10CB\a\x1FF\x2\x2\x10CB\x10CD\x3\x2\x2\x2\x10CC\x10BD"+
		"\x3\x2\x2\x2\x10CC\x10C1\x3\x2\x2\x2\x10CD\x24B\x3\x2\x2\x2\x10CE\x10CF"+
		"\a\x195\x2\x2\x10CF\x10D0\a\x1FE\x2\x2\x10D0\x10D5\x5\x202\x102\x2\x10D1"+
		"\x10D2\a\x204\x2\x2\x10D2\x10D4\x5\x202\x102\x2\x10D3\x10D1\x3\x2\x2\x2"+
		"\x10D4\x10D7\x3\x2\x2\x2\x10D5\x10D3\x3\x2\x2\x2\x10D5\x10D6\x3\x2\x2"+
		"\x2\x10D6\x10D8\x3\x2\x2\x2\x10D7\x10D5\x3\x2\x2\x2\x10D8\x10D9\a\x1FF"+
		"\x2\x2\x10D9\x10E7\x3\x2\x2\x2\x10DA\x10DB\a\x196\x2\x2\x10DB\x10DC\a"+
		"\x1FE\x2\x2\x10DC\x10E1\x5\x202\x102\x2\x10DD\x10DE\a\x204\x2\x2\x10DE"+
		"\x10E0\x5\x202\x102\x2\x10DF\x10DD\x3\x2\x2\x2\x10E0\x10E3\x3\x2\x2\x2"+
		"\x10E1\x10DF\x3\x2\x2\x2\x10E1\x10E2\x3\x2\x2\x2\x10E2\x10E4\x3\x2\x2"+
		"\x2\x10E3\x10E1\x3\x2\x2\x2\x10E4\x10E5\a\x1FF\x2\x2\x10E5\x10E7\x3\x2"+
		"\x2\x2\x10E6\x10CE\x3\x2\x2\x2\x10E6\x10DA\x3\x2\x2\x2\x10E7\x24D\x3\x2"+
		"\x2\x2\x10E8\x10E9\t\x34\x2\x2\x10E9\x10F0\a\x1FE\x2\x2\x10EA\x10EB\a"+
		"\xEE\x2\x2\x10EB\x10EC\a\x1FE\x2\x2\x10EC\x10ED\x5\x148\xA5\x2\x10ED\x10EE"+
		"\a\x1FF\x2\x2\x10EE\x10F1\x3\x2\x2\x2\x10EF\x10F1\x5\x220\x111\x2\x10F0"+
		"\x10EA\x3\x2\x2\x2\x10F0\x10EF\x3\x2\x2\x2\x10F1\x10F2\x3\x2\x2\x2\x10F2"+
		"\x10F3\a\x15\x2\x2\x10F3\x10F4\x5\x2E6\x174\x2\x10F4\x10F5\a\x1FF\x2\x2"+
		"\x10F5\x10F8\x3\x2\x2\x2\x10F6\x10F8\x5\x24C\x127\x2\x10F7\x10E8\x3\x2"+
		"\x2\x2\x10F7\x10F6\x3\x2\x2\x2\x10F8\x24F\x3\x2\x2\x2\x10F9\x10FA\a\x41"+
		"\x2\x2\x10FA\x10FF\x5\x274\x13B\x2\x10FB\x10FC\a\x204\x2\x2\x10FC\x10FE"+
		"\x5\x274\x13B\x2\x10FD\x10FB\x3\x2\x2\x2\x10FE\x1101\x3\x2\x2\x2\x10FF"+
		"\x10FD\x3\x2\x2\x2\x10FF\x1100\x3\x2\x2\x2\x1100\x251\x3\x2\x2\x2\x1101"+
		"\x10FF\x3\x2\x2\x2\x1102\x1103\a\x1D0\x2\x2\x1103\x1107\a\x1FE\x2\x2\x1104"+
		"\x1105\x5\x272\x13A\x2\x1105\x1106\a\x204\x2\x2\x1106\x1108\x3\x2\x2\x2"+
		"\x1107\x1104\x3\x2\x2\x2\x1107\x1108\x3\x2\x2\x2\x1108\x1109\x3\x2\x2"+
		"\x2\x1109\x110B\x5\x220\x111\x2\x110A\x110C\x5\x26E\x138\x2\x110B\x110A"+
		"\x3\x2\x2\x2\x110B\x110C\x3\x2\x2\x2\x110C\x110E\x3\x2\x2\x2\x110D\x110F"+
		"\x5\x250\x129\x2\x110E\x110D\x3\x2\x2\x2\x110E\x110F\x3\x2\x2\x2\x110F"+
		"\x1110\x3\x2\x2\x2\x1110\x1113\a\x1FF\x2\x2\x1111\x1112\a\x1F7\x2\x2\x1112"+
		"\x1114\x5\x2F2\x17A\x2\x1113\x1111\x3\x2\x2\x2\x1113\x1114\x3\x2\x2\x2"+
		"\x1114\x253\x3\x2\x2\x2\x1115\x1116\x5\x256\x12C\x2\x1116\x1118\x5\x2DE"+
		"\x170\x2\x1117\x1119\x5\x25C\x12F\x2\x1118\x1117\x3\x2\x2\x2\x1118\x1119"+
		"\x3\x2\x2\x2\x1119\x1236\x3\x2\x2\x2\x111A\x111B\x5\x30A\x186\x2\x111B"+
		"\x111D\x5\x2E0\x171\x2\x111C\x111E\x5\x264\x133\x2\x111D\x111C\x3\x2\x2"+
		"\x2\x111D\x111E\x3\x2\x2\x2\x111E\x1236\x3\x2\x2\x2\x111F\x1120\aU\x2"+
		"\x2\x1120\x1126\a\x1FE\x2\x2\x1121\x1127\a\x201\x2\x2\x1122\x1124\t\x1E"+
		"\x2\x2\x1123\x1122\x3\x2\x2\x2\x1123\x1124\x3\x2\x2\x2\x1124\x1125\x3"+
		"\x2\x2\x2\x1125\x1127\x5\x220\x111\x2\x1126\x1121\x3\x2\x2\x2\x1126\x1123"+
		"\x3\x2\x2\x2\x1127\x1128\x3\x2\x2\x2\x1128\x112A\a\x1FF\x2\x2\x1129\x112B"+
		"\x5\x25C\x12F\x2\x112A\x1129\x3\x2\x2\x2\x112A\x112B\x3\x2\x2\x2\x112B"+
		"\x1236\x3\x2\x2\x2\x112C\x1236\x5\x24E\x128\x2\x112D\x112E\a<\x2\x2\x112E"+
		"\x112F\a\x1FE\x2\x2\x112F\x1130\x5\x220\x111\x2\x1130\x1131\a\x1AC\x2"+
		"\x2\x1131\x1132\a\xF5\x2\x2\x1132\x1133\a\x1FF\x2\x2\x1133\x1236\x3\x2"+
		"\x2\x2\x1134\x1135\a@\x2\x2\x1135\x1137\a\x1FE\x2\x2\x1136\x1138\t\x35"+
		"\x2\x2\x1137\x1136\x3\x2\x2\x2\x1137\x1138\x3\x2\x2\x2\x1138\x1139\x3"+
		"\x2\x2\x2\x1139\x113B\x5\x220\x111\x2\x113A\x113C\x5\x268\x135\x2\x113B"+
		"\x113A\x3\x2\x2\x2\x113B\x113C\x3\x2\x2\x2\x113C\x113D\x3\x2\x2\x2\x113D"+
		"\x113E\a\x1FF\x2\x2\x113E\x1236\x3\x2\x2\x2\x113F\x1140\x5\x258\x12D\x2"+
		"\x1140\x1142\x5\x2DC\x16F\x2\x1141\x1143\x5\x26A\x136\x2\x1142\x1141\x3"+
		"\x2\x2\x2\x1143\x1144\x3\x2\x2\x2\x1144\x1142\x3\x2\x2\x2\x1144\x1145"+
		"\x3\x2\x2\x2\x1145\x1236\x3\x2\x2\x2\x1146\x1147\ai\x2\x2\x1147\x1148"+
		"\a\x1FE\x2\x2\x1148\x114A\x5\x220\x111\x2\x1149\x114B\t\x36\x2\x2\x114A"+
		"\x1149\x3\x2\x2\x2\x114A\x114B\x3\x2\x2\x2\x114B\x114C\x3\x2\x2\x2\x114C"+
		"\x114D\a\x1FF\x2\x2\x114D\x1236\x3\x2\x2\x2\x114E\x114F\a\x93\x2\x2\x114F"+
		"\x1150\a\x1FE\x2\x2\x1150\x1151\x5\x30A\x186\x2\x1151\x1152\a\xA0\x2\x2"+
		"\x1152\x1153\x5\x220\x111\x2\x1153\x1154\a\x1FF\x2\x2\x1154\x1236\x3\x2"+
		"\x2\x2\x1155\x1156\t\x37\x2\x2\x1156\x1158\x5\x2DE\x170\x2\x1157\x1159"+
		"\x5\x2E2\x172\x2\x1158\x1157\x3\x2\x2\x2\x1158\x1159\x3\x2\x2\x2\x1159"+
		"\x115A\x3\x2\x2\x2\x115A\x115B\x5\x25C\x12F\x2\x115B\x1236\x3\x2\x2\x2"+
		"\x115C\x115D\x5\x25A\x12E\x2\x115D\x115E\a\x1FE\x2\x2\x115E\x1163\x5\x204"+
		"\x103\x2\x115F\x1160\a\x204\x2\x2\x1160\x1162\x5\x204\x103\x2\x1161\x115F"+
		"\x3\x2\x2\x2\x1162\x1165\x3\x2\x2\x2\x1163\x1161\x3\x2\x2\x2\x1163\x1164"+
		"\x3\x2\x2\x2\x1164\x1167\x3\x2\x2\x2\x1165\x1163\x3\x2\x2\x2\x1166\x1168"+
		"\x5\x26C\x137\x2\x1167\x1166\x3\x2\x2\x2\x1167\x1168\x3\x2\x2\x2\x1168"+
		"\x116A\x3\x2\x2\x2\x1169\x116B\x5\x264\x133\x2\x116A\x1169\x3\x2\x2\x2"+
		"\x116A\x116B\x3\x2\x2\x2\x116B\x116C\x3\x2\x2\x2\x116C\x116D\a\x1FF\x2"+
		"\x2\x116D\x1236\x3\x2\x2\x2\x116E\x116F\a\xE9\x2\x2\x116F\x1170\a\x1FE"+
		"\x2\x2\x1170\x1171\x5\x202\x102\x2\x1171\x1172\a\x204\x2\x2\x1172\x1173"+
		"\x5\x202\x102\x2\x1173\x1174\a\x1FF\x2\x2\x1174\x1236\x3\x2\x2\x2\x1175"+
		"\x1176\a\x199\x2\x2\x1176\x1177\a\x1FE\x2\x2\x1177\x117A\x5\x204\x103"+
		"\x2\x1178\x1179\a\x1AC\x2\x2\x1179\x117B\t\x38\x2\x2\x117A\x1178\x3\x2"+
		"\x2\x2\x117A\x117B\x3\x2\x2\x2\x117B\x1180\x3\x2\x2\x2\x117C\x117D\a\x204"+
		"\x2\x2\x117D\x117F\x5\x204\x103\x2\x117E\x117C\x3\x2\x2\x2\x117F\x1182"+
		"\x3\x2\x2\x2\x1180\x117E\x3\x2\x2\x2\x1180\x1181\x3\x2\x2\x2\x1181\x1183"+
		"\x3\x2\x2\x2\x1182\x1180\x3\x2\x2\x2\x1183\x1184\a\x1FF\x2\x2\x1184\x1236"+
		"\x3\x2\x2\x2\x1185\x1186\a\x19A\x2\x2\x1186\x1187\a\x1FE\x2\x2\x1187\x1188"+
		"\x5\x204\x103\x2\x1188\x118A\a\x15\x2\x2\x1189\x118B\a\x13E\x2\x2\x118A"+
		"\x1189\x3\x2\x2\x2\x118A\x118B\x3\x2\x2\x2\x118B\x118C\x3\x2\x2\x2\x118C"+
		"\x118D\x5\x2E6\x174\x2\x118D\x118E\a\x1FF\x2\x2\x118E\x1236\x3\x2\x2\x2"+
		"\x118F\x1190\a\x19C\x2\x2\x1190\x1198\a\x1FE\x2\x2\x1191\x1193\t\x39\x2"+
		"\x2\x1192\x1191\x3\x2\x2\x2\x1192\x1193\x3\x2\x2\x2\x1193\x1195\x3\x2"+
		"\x2\x2\x1194\x1196\x5\x204\x103\x2\x1195\x1194\x3\x2\x2\x2\x1195\x1196"+
		"\x3\x2\x2\x2\x1196\x1197\x3\x2\x2\x2\x1197\x1199\a\xA0\x2\x2\x1198\x1192"+
		"\x3\x2\x2\x2\x1198\x1199\x3\x2\x2\x2\x1199\x119A\x3\x2\x2\x2\x119A\x119B"+
		"\x5\x204\x103\x2\x119B\x119C\a\x1FF\x2\x2\x119C\x1236\x3\x2\x2\x2\x119D"+
		"\x119E\a\x1C3\x2\x2\x119E\x119F\a\x1FE\x2\x2\x119F\x11A1\x5\x204\x103"+
		"\x2\x11A0\x11A2\x5\x1A8\xD5\x2\x11A1\x11A0\x3\x2\x2\x2\x11A1\x11A2\x3"+
		"\x2\x2\x2\x11A2\x11A3\x3\x2\x2\x2\x11A3\x11A6\a\x1FF\x2\x2\x11A4\x11A5"+
		"\a\x1F7\x2\x2\x11A5\x11A7\x5\x2F2\x17A\x2\x11A6\x11A4\x3\x2\x2\x2\x11A6"+
		"\x11A7\x3\x2\x2\x2\x11A7\x1236\x3\x2\x2\x2\x11A8\x11A9\t:\x2\x2\x11A9"+
		"\x11AA\a\x1FE\x2\x2\x11AA\x11AF\x5\x278\x13D\x2\x11AB\x11AC\a\x204\x2"+
		"\x2\x11AC\x11AE\x5\x278\x13D\x2\x11AD\x11AB\x3\x2\x2\x2\x11AE\x11B1\x3"+
		"\x2\x2\x2\x11AF\x11AD\x3\x2\x2\x2\x11AF\x11B0\x3\x2\x2\x2\x11B0\x11B2"+
		"\x3\x2\x2\x2\x11B1\x11AF\x3\x2\x2\x2\x11B2\x11B5\a\x1FF\x2\x2\x11B3\x11B4"+
		"\a\x1F7\x2\x2\x11B4\x11B6\x5\x2F2\x17A\x2\x11B5\x11B3\x3\x2\x2\x2\x11B5"+
		"\x11B6\x3\x2\x2\x2\x11B6\x1236\x3\x2\x2\x2\x11B7\x11B8\a\x1C7\x2\x2\x11B8"+
		"\x11BA\a\x1FE\x2\x2\x11B9\x11BB\t;\x2\x2\x11BA\x11B9\x3\x2\x2\x2\x11BA"+
		"\x11BB\x3\x2\x2\x2\x11BB\x11BD\x3\x2\x2\x2\x11BC\x11BE\t<\x2\x2\x11BD"+
		"\x11BC\x3\x2\x2\x2\x11BD\x11BE\x3\x2\x2\x2\x11BE\x11BF\x3\x2\x2\x2\x11BF"+
		"\x11C2\x5\x204\x103\x2\x11C0\x11C1\a\x204\x2\x2\x11C1\x11C3\x5\x270\x139"+
		"\x2\x11C2\x11C0\x3\x2\x2\x2\x11C2\x11C3\x3\x2\x2\x2\x11C3\x11CB\x3\x2"+
		"\x2\x2\x11C4\x11C5\a\x204\x2\x2\x11C5\x11C7\x5\x204\x103\x2\x11C6\x11C8"+
		"\x5\x28C\x147\x2\x11C7\x11C6\x3\x2\x2\x2\x11C7\x11C8\x3\x2\x2\x2\x11C8"+
		"\x11CA\x3\x2\x2\x2\x11C9\x11C4\x3\x2\x2\x2\x11CA\x11CD\x3\x2\x2\x2\x11CB"+
		"\x11C9\x3\x2\x2\x2\x11CB\x11CC\x3\x2\x2\x2\x11CC\x11CE\x3\x2\x2\x2\x11CD"+
		"\x11CB\x3\x2\x2\x2\x11CE\x11D1\a\x1FF\x2\x2\x11CF\x11D0\a\x1F7\x2\x2\x11D0"+
		"\x11D2\x5\x2F2\x17A\x2\x11D1\x11CF\x3\x2\x2\x2\x11D1\x11D2\x3\x2\x2\x2"+
		"\x11D2\x1236\x3\x2\x2\x2\x11D3\x11D4\a\x1C8\x2\x2\x11D4\x11D5\a\x1FE\x2"+
		"\x2\x11D5\x11D7\x5\x204\x103\x2\x11D6\x11D8\x5\x26E\x138\x2\x11D7\x11D6"+
		"\x3\x2\x2\x2\x11D7\x11D8\x3\x2\x2\x2\x11D8\x11D9\x3\x2\x2\x2\x11D9\x11DA"+
		"\a\x1FF\x2\x2\x11DA\x1236\x3\x2\x2\x2\x11DB\x11DC\a\x1CB\x2\x2\x11DC\x11DD"+
		"\a\x1FE\x2\x2\x11DD\x11DE\t=\x2\x2\x11DE\x11E0\x5\x220\x111\x2\x11DF\x11E1"+
		"\a\x1B9\x2\x2\x11E0\x11DF\x3\x2\x2\x2\x11E0\x11E1\x3\x2\x2\x2\x11E1\x11E2"+
		"\x3\x2\x2\x2\x11E2\x11E5\a\x1FF\x2\x2\x11E3\x11E4\a\x1F7\x2\x2\x11E4\x11E6"+
		"\x5\x2F2\x17A\x2\x11E5\x11E3\x3\x2\x2\x2\x11E5\x11E6\x3\x2\x2\x2\x11E6"+
		"\x1236\x3\x2\x2\x2\x11E7\x11E8\a\x1CC\x2\x2\x11E8\x11ED\a\x1FE\x2\x2\x11E9"+
		"\x11EA\a\xEF\x2\x2\x11EA\x11EE\x5\x2FC\x17F\x2\x11EB\x11EC\a\x87\x2\x2"+
		"\x11EC\x11EE\x5\x220\x111\x2\x11ED\x11E9\x3\x2\x2\x2\x11ED\x11EB\x3\x2"+
		"\x2\x2\x11EE\x11F1\x3\x2\x2\x2\x11EF\x11F0\a\x204\x2\x2\x11F0\x11F2\x5"+
		"\x220\x111\x2\x11F1\x11EF\x3\x2\x2\x2\x11F1\x11F2\x3\x2\x2\x2\x11F2\x11F3"+
		"\x3\x2\x2\x2\x11F3\x11F6\a\x1FF\x2\x2\x11F4\x11F5\a\x1F7\x2\x2\x11F5\x11F7"+
		"\x5\x2F2\x17A\x2\x11F6\x11F4\x3\x2\x2\x2\x11F6\x11F7\x3\x2\x2\x2\x11F7"+
		"\x1236\x3\x2\x2\x2\x11F8\x11F9\a\x1CD\x2\x2\x11F9\x11FA\a\x1FE\x2\x2\x11FA"+
		"\x11FC\x5\x220\x111\x2\x11FB\x11FD\x5\x26E\x138\x2\x11FC\x11FB\x3\x2\x2"+
		"\x2\x11FC\x11FD\x3\x2\x2\x2\x11FD\x11FE\x3\x2\x2\x2\x11FE\x11FF\a\x14A"+
		"\x2\x2\x11FF\x1203\aN\x2\x2\x1200\x1201\a\x107\x2\x2\x1201\x1202\a\x111"+
		"\x2\x2\x1202\x1204\a\x7F\x2\x2\x1203\x1200\x3\x2\x2\x2\x1203\x1204\x3"+
		"\x2\x2\x2\x1204\x1205\x3\x2\x2\x2\x1205\x1208\a\x1FF\x2\x2\x1206\x1207"+
		"\a\x1F7\x2\x2\x1207\x1209\x5\x2F2\x17A\x2\x1208\x1206\x3\x2\x2\x2\x1208"+
		"\x1209\x3\x2\x2\x2\x1209\x1236\x3\x2\x2\x2\x120A\x120B\a\x1CE\x2\x2\x120B"+
		"\x120C\a\x1FE\x2\x2\x120C\x120F\x5\x220\x111\x2\x120D\x120E\a\x204\x2"+
		"\x2\x120E\x1210\x5\x27A\x13E\x2\x120F\x120D\x3\x2\x2\x2\x120F\x1210\x3"+
		"\x2\x2\x2\x1210\x1213\x3\x2\x2\x2\x1211\x1212\a\x204\x2\x2\x1212\x1214"+
		"\x5\x27C\x13F\x2\x1213\x1211\x3\x2\x2\x2\x1213\x1214\x3\x2\x2\x2\x1214"+
		"\x1215\x3\x2\x2\x2\x1215\x1218\a\x1FF\x2\x2\x1216\x1217\a\x1F7\x2\x2\x1217"+
		"\x1219\x5\x2F2\x17A\x2\x1218\x1216\x3\x2\x2\x2\x1218\x1219\x3\x2\x2\x2"+
		"\x1219\x1236\x3\x2\x2\x2\x121A\x121B\a\x1CF\x2\x2\x121B\x121C\a\x1FE\x2"+
		"\x2\x121C\x121D\t=\x2\x2\x121D\x1220\x5\x220\x111\x2\x121E\x121F\a\x15"+
		"\x2\x2\x121F\x1221\x5\x2E6\x174\x2\x1220\x121E\x3\x2\x2\x2\x1220\x1221"+
		"\x3\x2\x2\x2\x1221\x1223\x3\x2\x2\x2\x1222\x1224\x5\x27E\x140\x2\x1223"+
		"\x1222\x3\x2\x2\x2\x1223\x1224\x3\x2\x2\x2\x1224\x1226\x3\x2\x2\x2\x1225"+
		"\x1227\x5\x280\x141\x2\x1226\x1225\x3\x2\x2\x2\x1226\x1227\x3\x2\x2\x2"+
		"\x1227\x1229\x3\x2\x2\x2\x1228\x122A\x5\x282\x142\x2\x1229\x1228\x3\x2"+
		"\x2\x2\x1229\x122A\x3\x2\x2\x2\x122A\x122D\x3\x2\x2\x2\x122B\x122C\t>"+
		"\x2\x2\x122C\x122E\al\x2\x2\x122D\x122B\x3\x2\x2\x2\x122D\x122E\x3\x2"+
		"\x2\x2\x122E\x122F\x3\x2\x2\x2\x122F\x1232\a\x1FF\x2\x2\x1230\x1231\a"+
		"\x1F7\x2\x2\x1231\x1233\x5\x2F2\x17A\x2\x1232\x1230\x3\x2\x2\x2\x1232"+
		"\x1233\x3\x2\x2\x2\x1233\x1236\x3\x2\x2\x2\x1234\x1236\x5\x252\x12A\x2"+
		"\x1235\x1115\x3\x2\x2\x2\x1235\x111A\x3\x2\x2\x2\x1235\x111F\x3\x2\x2"+
		"\x2\x1235\x112C\x3\x2\x2\x2\x1235\x112D\x3\x2\x2\x2\x1235\x1134\x3\x2"+
		"\x2\x2\x1235\x113F\x3\x2\x2\x2\x1235\x1146\x3\x2\x2\x2\x1235\x114E\x3"+
		"\x2\x2\x2\x1235\x1155\x3\x2\x2\x2\x1235\x115C\x3\x2\x2\x2\x1235\x116E"+
		"\x3\x2\x2\x2\x1235\x1175\x3\x2\x2\x2\x1235\x1185\x3\x2\x2\x2\x1235\x118F"+
		"\x3\x2\x2\x2\x1235\x119D\x3\x2\x2\x2\x1235\x11A8\x3\x2\x2\x2\x1235\x11B7"+
		"\x3\x2\x2\x2\x1235\x11D3\x3\x2\x2\x2\x1235\x11DB\x3\x2\x2\x2\x1235\x11E7"+
		"\x3\x2\x2\x2\x1235\x11F8\x3\x2\x2\x2\x1235\x120A\x3\x2\x2\x2\x1235\x121A"+
		"\x3\x2\x2\x2\x1235\x1234\x3\x2\x2\x2\x1236\x255\x3\x2\x2\x2\x1237\x1238"+
		"\t?\x2\x2\x1238\x257\x3\x2\x2\x2\x1239\x123A\t@\x2\x2\x123A\x259\x3\x2"+
		"\x2\x2\x123B\x123C\t\x41\x2\x2\x123C\x25B\x3\x2\x2\x2\x123D\x123E\a\x11C"+
		"\x2\x2\x123E\x1240\a\x1FE\x2\x2\x123F\x1241\x5\x164\xB3\x2\x1240\x123F"+
		"\x3\x2\x2\x2\x1240\x1241\x3\x2\x2\x2\x1241\x1246\x3\x2\x2\x2\x1242\x1244"+
		"\x5\x1A8\xD5\x2\x1243\x1245\x5\x25E\x130\x2\x1244\x1243\x3\x2\x2\x2\x1244"+
		"\x1245\x3\x2\x2\x2\x1245\x1247\x3\x2\x2\x2\x1246\x1242\x3\x2\x2\x2\x1246"+
		"\x1247\x3\x2\x2\x2\x1247\x1248\x3\x2\x2\x2\x1248\x1249\a\x1FF\x2\x2\x1249"+
		"\x25D\x3\x2\x2\x2\x124A\x1251\x5\x260\x131\x2\x124B\x124C\a#\x2\x2\x124C"+
		"\x124D\x5\x262\x132\x2\x124D\x124E\a\x12\x2\x2\x124E\x124F\x5\x262\x132"+
		"\x2\x124F\x1252\x3\x2\x2\x2\x1250\x1252\x5\x262\x132\x2\x1251\x124B\x3"+
		"\x2\x2\x2\x1251\x1250\x3\x2\x2\x2\x1252\x25F\x3\x2\x2\x2\x1253\x1254\t"+
		"\x42\x2\x2\x1254\x261\x3\x2\x2\x2\x1255\x1256\a\x1A0\x2\x2\x1256\x125D"+
		"\a\x133\x2\x2\x1257\x1258\aY\x2\x2\x1258\x125D\a\x151\x2\x2\x1259\x125A"+
		"\x5\x220\x111\x2\x125A\x125B\t\x43\x2\x2\x125B\x125D\x3\x2\x2\x2\x125C"+
		"\x1255\x3\x2\x2\x2\x125C\x1257\x3\x2\x2\x2\x125C\x1259\x3\x2\x2\x2\x125D"+
		"\x263\x3\x2\x2\x2\x125E\x1268\a\x1AC\x2\x2\x125F\x1269\a\x201\x2\x2\x1260"+
		"\x1265\x5\x266\x134\x2\x1261\x1262\a\x204\x2\x2\x1262\x1264\x5\x266\x134"+
		"\x2\x1263\x1261\x3\x2\x2\x2\x1264\x1267\x3\x2\x2\x2\x1265\x1263\x3\x2"+
		"\x2\x2\x1265\x1266\x3\x2\x2\x2\x1266\x1269\x3\x2\x2\x2\x1267\x1265\x3"+
		"\x2\x2\x2\x1268\x125F\x3\x2\x2\x2\x1268\x1260\x3\x2\x2\x2\x1269\x265\x3"+
		"\x2\x2\x2\x126A\x126C\a\xAE\x2\x2\x126B\x126D\a\x11A\x2\x2\x126C\x126B"+
		"\x3\x2\x2\x2\x126C\x126D\x3\x2\x2\x2\x126D\x1270\x3\x2\x2\x2\x126E\x1270"+
		"\a\x11A\x2\x2\x126F\x126A\x3\x2\x2\x2\x126F\x126E\x3\x2\x2\x2\x126F\x1270"+
		"\x3\x2\x2\x2\x1270\x1271\x3\x2\x2\x2\x1271\x1273\x5\x154\xAB\x2\x1272"+
		"\x1274\x5\x28C\x147\x2\x1273\x1272\x3\x2\x2\x2\x1273\x1274\x3\x2\x2\x2"+
		"\x1274\x267\x3\x2\x2\x2\x1275\x1276\a\x117\x2\x2\x1276\x1277\a/\x2\x2"+
		"\x1277\x1278\x5\x220\x111\x2\x1278\x269\x3\x2\x2\x2\x1279\x127A\a\x1BF"+
		"\x2\x2\x127A\x127B\a\xA5\x2\x2\x127B\x127C\a\x1FE\x2\x2\x127C\x127D\x5"+
		"\x1A8\xD5\x2\x127D\x127E\a\x1FF\x2\x2\x127E\x1281\x3\x2\x2\x2\x127F\x1281"+
		"\x5\x25C\x12F\x2\x1280\x1279\x3\x2\x2\x2\x1280\x127F\x3\x2\x2\x2\x1281"+
		"\x26B\x3\x2\x2\x2\x1282\x1294\aT\x2\x2\x1283\x1285\a\xEB\x2\x2\x1284\x1286"+
		"\a\x1D\x2\x2\x1285\x1284\x3\x2\x2\x2\x1285\x1286\x3\x2\x2\x2\x1286\x1295"+
		"\x3\x2\x2\x2\x1287\x1288\a\x1FE\x2\x2\x1288\x128D\x5\x29C\x14F\x2\x1289"+
		"\x128A\a\x204\x2\x2\x128A\x128C\x5\x29C\x14F\x2\x128B\x1289\x3\x2\x2\x2"+
		"\x128C\x128F\x3\x2\x2\x2\x128D\x128B\x3\x2\x2\x2\x128D\x128E\x3\x2\x2"+
		"\x2\x128E\x1290\x3\x2\x2\x2\x128F\x128D\x3\x2\x2\x2\x1290\x1291\a\x1FF"+
		"\x2\x2\x1291\x1292\a\x1AF\x2\x2\x1292\x1293\x5\x1FC\xFF\x2\x1293\x1295"+
		"\x3\x2\x2\x2\x1294\x1283\x3\x2\x2\x2\x1294\x1287\x3\x2\x2\x2\x1295\x26D"+
		"\x3\x2\x2\x2\x1296\x1299\a\x123\x2\x2\x1297\x1298\a/\x2\x2\x1298\x129A"+
		"\a\x1AE\x2\x2\x1299\x1297\x3\x2\x2\x2\x1299\x129A\x3\x2\x2\x2\x129A\x129B"+
		"\x3\x2\x2\x2\x129B\x129D\x5\x204\x103\x2\x129C\x129E\x5\x28C\x147\x2\x129D"+
		"\x129C\x3\x2\x2\x2\x129D\x129E\x3\x2\x2\x2\x129E\x12A6\x3\x2\x2\x2\x129F"+
		"\x12A0\a\x204\x2\x2\x12A0\x12A2\x5\x204\x103\x2\x12A1\x12A3\x5\x28C\x147"+
		"\x2\x12A2\x12A1\x3\x2\x2\x2\x12A2\x12A3\x3\x2\x2\x2\x12A3\x12A5\x3\x2"+
		"\x2\x2\x12A4\x129F\x3\x2\x2\x2\x12A5\x12A8\x3\x2\x2\x2\x12A6\x12A4\x3"+
		"\x2\x2\x2\x12A6\x12A7\x3\x2\x2\x2\x12A7\x26F\x3\x2\x2\x2\x12A8\x12A6\x3"+
		"\x2\x2\x2\x12A9\x12AA\a\x1C4\x2\x2\x12AA\x12AC\a\x1FE\x2\x2\x12AB\x12AD"+
		"\t;\x2\x2\x12AC\x12AB\x3\x2\x2\x2\x12AC\x12AD\x3\x2\x2\x2\x12AD\x12AF"+
		"\x3\x2\x2\x2\x12AE\x12B0\t\x44\x2\x2\x12AF\x12AE\x3\x2\x2\x2\x12AF\x12B0"+
		"\x3\x2\x2\x2\x12B0\x12B1\x3\x2\x2\x2\x12B1\x12B6\x5\x278\x13D\x2\x12B2"+
		"\x12B3\a\x204\x2\x2\x12B3\x12B5\x5\x278\x13D\x2\x12B4\x12B2\x3\x2\x2\x2"+
		"\x12B5\x12B8\x3\x2\x2\x2\x12B6\x12B4\x3\x2\x2\x2\x12B6\x12B7\x3\x2\x2"+
		"\x2\x12B7\x12B9\x3\x2\x2\x2\x12B8\x12B6\x3\x2\x2\x2\x12B9\x12BA\a\x1FF"+
		"\x2\x2\x12BA\x271\x3\x2\x2\x2\x12BB\x12BC\a\x1CA\x2\x2\x12BC\x12C8\a\x1FE"+
		"\x2\x2\x12BD\x12BE\x5\x220\x111\x2\x12BE\x12C5\x5\x28C\x147\x2\x12BF\x12C0"+
		"\a\x204\x2\x2\x12C0\x12C1\x5\x220\x111\x2\x12C1\x12C2\x5\x28C\x147\x2"+
		"\x12C2\x12C4\x3\x2\x2\x2\x12C3\x12BF\x3\x2\x2\x2\x12C4\x12C7\x3\x2\x2"+
		"\x2\x12C5\x12C3\x3\x2\x2\x2\x12C5\x12C6\x3\x2\x2\x2\x12C6\x12C9\x3\x2"+
		"\x2\x2\x12C7\x12C5\x3\x2\x2\x2\x12C8\x12BD\x3\x2\x2\x2\x12C8\x12C9\x3"+
		"\x2\x2\x2\x12C9\x12CB\x3\x2\x2\x2\x12CA\x12CC\x5\x276\x13C\x2\x12CB\x12CA"+
		"\x3\x2\x2\x2\x12CB\x12CC\x3\x2\x2\x2\x12CC\x12CD\x3\x2\x2\x2\x12CD\x12CE"+
		"\a\x1FF\x2\x2\x12CE\x273\x3\x2\x2\x2\x12CF\x12DA\x5\x29A\x14E\x2\x12D0"+
		"\x12D1\a\x9D\x2\x2\x12D1\x12DB\a\x118\x2\x2\x12D2\x12D5\x5\x2E6\x174\x2"+
		"\x12D3\x12D4\a\x124\x2\x2\x12D4\x12D6\x5\x220\x111\x2\x12D5\x12D3\x3\x2"+
		"\x2\x2\x12D5\x12D6\x3\x2\x2\x2\x12D6\x12D8\x3\x2\x2\x2\x12D7\x12D9\x5"+
		"\x276\x13C\x2\x12D8\x12D7\x3\x2\x2\x2\x12D8\x12D9\x3\x2\x2\x2\x12D9\x12DB"+
		"\x3\x2\x2\x2\x12DA\x12D0\x3\x2\x2\x2\x12DA\x12D2\x3\x2\x2\x2\x12DB\x275"+
		"\x3\x2\x2\x2\x12DC\x12DD\ak\x2\x2\x12DD\x12DE\x5\x220\x111\x2\x12DE\x277"+
		"\x3\x2\x2\x2\x12DF\x12E8\x5\x202\x102\x2\x12E0\x12E2\a\x15\x2\x2\x12E1"+
		"\x12E0\x3\x2\x2\x2\x12E1\x12E2\x3\x2\x2\x2\x12E2\x12E6\x3\x2\x2\x2\x12E3"+
		"\x12E7\x5\x2FE\x180\x2\x12E4\x12E5\a\x87\x2\x2\x12E5\x12E7\x5\x21E\x110"+
		"\x2\x12E6\x12E3\x3\x2\x2\x2\x12E6\x12E4\x3\x2\x2\x2\x12E7\x12E9\x3\x2"+
		"\x2\x2\x12E8\x12E1\x3\x2\x2\x2\x12E8\x12E9\x3\x2\x2\x2\x12E9\x279\x3\x2"+
		"\x2\x2\x12EA\x12EE\a\x1B5\x2\x2\x12EB\x12EC\a\xFA\x2\x2\x12EC\x12EF\a"+
		"\x1AE\x2\x2\x12ED\x12EF\x5\x204\x103\x2\x12EE\x12EB\x3\x2\x2\x2\x12EE"+
		"\x12ED\x3\x2\x2\x2\x12EF\x27B\x3\x2\x2\x2\x12F0\x12F6\a\x17A\x2\x2\x12F1"+
		"\x12F7\a\x1D2\x2\x2\x12F2\x12F4\a\xFA\x2\x2\x12F3\x12F5\a\x1AE\x2\x2\x12F4"+
		"\x12F3\x3\x2\x2\x2\x12F4\x12F5\x3\x2\x2\x2\x12F5\x12F7\x3\x2\x2\x2\x12F6"+
		"\x12F1\x3\x2\x2\x2\x12F6\x12F2\x3\x2\x2\x2\x12F7\x27D\x3\x2\x2\x2\x12F8"+
		"\x12F9\a\x81\x2\x2\x12F9\x12FA\x5\x220\x111\x2\x12FA\x27F\x3\x2\x2\x2"+
		"\x12FB\x12FC\a\x1B5\x2\x2\x12FC\x12FD\x5\x220\x111\x2\x12FD\x281\x3\x2"+
		"\x2\x2\x12FE\x12FF\a\xFA\x2\x2\x12FF\x1307\a\xB2\x2\x2\x1300\x1304\a\xB2"+
		"\x2\x2\x1301\x1302\a\x171\x2\x2\x1302\x1303\a\x215\x2\x2\x1303\x1305\x5"+
		"\x220\x111\x2\x1304\x1301\x3\x2\x2\x2\x1304\x1305\x3\x2\x2\x2\x1305\x1307"+
		"\x3\x2\x2\x2\x1306\x12FE\x3\x2\x2\x2\x1306\x1300\x3\x2\x2\x2\x1307\x283"+
		"\x3\x2\x2\x2\x1308\x1309\x5\x202\x102\x2\x1309\x285\x3\x2\x2\x2\x130A"+
		"\x130C\x5\xC4\x63\x2\x130B\x130A\x3\x2\x2\x2\x130C\x130D\x3\x2\x2\x2\x130D"+
		"\x130B\x3\x2\x2\x2\x130D\x130E\x3\x2\x2\x2\x130E\x1312\x3\x2\x2\x2\x130F"+
		"\x1312\x5\xE4s\x2\x1310\x1312\x5\x6\x4\x2\x1311\x130B\x3\x2\x2\x2\x1311"+
		"\x130F\x3\x2\x2\x2\x1311\x1310\x3\x2\x2\x2\x1312\x287\x3\x2\x2\x2\x1313"+
		"\x1314\a\x4\x2\x2\x1314\x1315\x5\x284\x143\x2\x1315\x1316\a\x5\x2\x2\x1316"+
		"\x131E\x5\x286\x144\x2\x1317\x1318\a\a\x2\x2\x1318\x1319\x5\x284\x143"+
		"\x2\x1319\x131A\a\x5\x2\x2\x131A\x131B\x5\x286\x144\x2\x131B\x131D\x3"+
		"\x2\x2\x2\x131C\x1317\x3\x2\x2\x2\x131D\x1320\x3\x2\x2\x2\x131E\x131C"+
		"\x3\x2\x2\x2\x131E\x131F\x3\x2\x2\x2\x131F\x1323\x3\x2\x2\x2\x1320\x131E"+
		"\x3\x2\x2\x2\x1321\x1322\a\x6\x2\x2\x1322\x1324\x5\x286\x144\x2\x1323"+
		"\x1321\x3\x2\x2\x2\x1323\x1324\x3\x2\x2\x2\x1324\x1325\x3\x2\x2\x2\x1325"+
		"\x1326\a\b\x2\x2\x1326\x289\x3\x2\x2\x2\x1327\x1329\t\x45\x2\x2\x1328"+
		"\x132A\a\x9D\x2\x2\x1329\x1328\x3\x2\x2\x2\x1329\x132A\x3\x2\x2\x2\x132A"+
		"\x132B\x3\x2\x2\x2\x132B\x132C\x5\x1FC\xFF\x2\x132C\x28B\x3\x2\x2\x2\x132D"+
		"\x132F\a\x15\x2\x2\x132E\x132D\x3\x2\x2\x2\x132E\x132F\x3\x2\x2\x2\x132F"+
		"\x1332\x3\x2\x2\x2\x1330\x1333\x5\x2FC\x17F\x2\x1331\x1333\x5\x290\x149"+
		"\x2\x1332\x1330\x3\x2\x2\x2\x1332\x1331\x3\x2\x2\x2\x1333\x28D\x3\x2\x2"+
		"\x2\x1334\x1337\x5\x2FC\x17F\x2\x1335\x1337\x5\x290\x149\x2\x1336\x1334"+
		"\x3\x2\x2\x2\x1336\x1335\x3\x2\x2\x2\x1337\x28F\x3\x2\x2\x2\x1338\x1339"+
		"\x5\x2FA\x17E\x2\x1339\x291\x3\x2\x2\x2\x133A\x133D\a\x1BC\x2\x2\x133B"+
		"\x133E\x5\x294\x14B\x2\x133C\x133E\x5\x200\x101\x2\x133D\x133B\x3\x2\x2"+
		"\x2\x133D\x133C\x3\x2\x2\x2\x133E\x293\x3\x2\x2\x2\x133F\x1340\aY\x2\x2"+
		"\x1340\x1341\a\x10D\x2\x2\x1341\x1342\x5\x2CC\x167\x2\x1342\x295\x3\x2"+
		"\x2\x2\x1343\x1346\x5\x2C8\x165\x2\x1344\x1346\x5\x1F8\xFD\x2\x1345\x1343"+
		"\x3\x2\x2\x2\x1345\x1344\x3\x2\x2\x2\x1346\x297\x3\x2\x2\x2\x1347\x1348"+
		"\a\xC2\x2\x2\x1348\x134D\x5\x296\x14C\x2\x1349\x134A\a\x204\x2\x2\x134A"+
		"\x134C\x5\x296\x14C\x2\x134B\x1349\x3\x2\x2\x2\x134C\x134F\x3\x2\x2\x2"+
		"\x134D\x134B\x3\x2\x2\x2\x134D\x134E\x3\x2\x2\x2\x134E\x135C\x3\x2\x2"+
		"\x2\x134F\x134D\x3\x2\x2\x2\x1350\x1351\a.\x2\x2\x1351\x1352\a@\x2\x2"+
		"\x1352\x1353\a\xC2\x2\x2\x1353\x1358\x5\x296\x14C\x2\x1354\x1355\a\x204"+
		"\x2\x2\x1355\x1357\x5\x296\x14C\x2\x1356\x1354\x3\x2\x2\x2\x1357\x135A"+
		"\x3\x2\x2\x2\x1358\x1356\x3\x2\x2\x2\x1358\x1359\x3\x2\x2\x2\x1359\x135C"+
		"\x3\x2\x2\x2\x135A\x1358\x3\x2\x2\x2\x135B\x1347\x3\x2\x2\x2\x135B\x1350"+
		"\x3\x2\x2\x2\x135C\x299\x3\x2\x2\x2\x135D\x1360\x5\x2FC\x17F\x2\x135E"+
		"\x1360\x5\x2FA\x17E\x2\x135F\x135D\x3\x2\x2\x2\x135F\x135E\x3\x2\x2\x2"+
		"\x1360\x29B\x3\x2\x2\x2\x1361\x1362\x5\x2FC\x17F\x2\x1362\x29D\x3\x2\x2"+
		"\x2\x1363\x1364\x5\x2FC\x17F\x2\x1364\x29F\x3\x2\x2\x2\x1365\x1366\x5"+
		"\x2FC\x17F\x2\x1366\x2A1\x3\x2\x2\x2\x1367\x1368\x5\x2FC\x17F\x2\x1368"+
		"\x2A3\x3\x2\x2\x2\x1369\x136A\x5\x2FC\x17F\x2\x136A\x2A5\x3\x2\x2\x2\x136B"+
		"\x136C\x5\x2FC\x17F\x2\x136C\x2A7\x3\x2\x2\x2\x136D\x1372\x5\x2FC\x17F"+
		"\x2\x136E\x136F\a\x1F7\x2\x2\x136F\x1371\x5\x2FE\x180\x2\x1370\x136E\x3"+
		"\x2\x2\x2\x1371\x1374\x3\x2\x2\x2\x1372\x1370\x3\x2\x2\x2\x1372\x1373"+
		"\x3\x2\x2\x2\x1373\x1377\x3\x2\x2\x2\x1374\x1372\x3\x2\x2\x2\x1375\x1376"+
		"\a\x206\x2\x2\x1376\x1378\x5\x2D2\x16A\x2\x1377\x1375\x3\x2\x2\x2\x1377"+
		"\x1378\x3\x2\x2\x2\x1378\x2A9\x3\x2\x2\x2\x1379\x137A\x5\x2A6\x154\x2"+
		"\x137A\x137B\a\x1F7\x2\x2\x137B\x137D\x3\x2\x2\x2\x137C\x1379\x3\x2\x2"+
		"\x2\x137C\x137D\x3\x2\x2\x2\x137D\x137E\x3\x2\x2\x2\x137E\x137F\x5\x2FC"+
		"\x17F\x2\x137F\x2AB\x3\x2\x2\x2\x1380\x1383\x5\x2FC\x17F\x2\x1381\x1382"+
		"\a\x1F7\x2\x2\x1382\x1384\x5\x2FE\x180\x2\x1383\x1381\x3\x2\x2\x2\x1383"+
		"\x1384\x3\x2\x2\x2\x1384\x2AD\x3\x2\x2\x2\x1385\x1386\x5\x2FC\x17F\x2"+
		"\x1386\x2AF\x3\x2\x2\x2\x1387\x1388\x5\x2FC\x17F\x2\x1388\x2B1\x3\x2\x2"+
		"\x2\x1389\x138A\x5\x2FC\x17F\x2\x138A\x2B3\x3\x2\x2\x2\x138B\x1390\x5"+
		"\x2FC\x17F\x2\x138C\x138D\a\x1F7\x2\x2\x138D\x138F\x5\x2FE\x180\x2\x138E"+
		"\x138C\x3\x2\x2\x2\x138F\x1392\x3\x2\x2\x2\x1390\x138E\x3\x2\x2\x2\x1390"+
		"\x1391\x3\x2\x2\x2\x1391\x2B5\x3\x2\x2\x2\x1392\x1390\x3\x2\x2\x2\x1393"+
		"\x1394\x5\x2FC\x17F\x2\x1394\x2B7\x3\x2\x2\x2\x1395\x139A\x5\x2FC\x17F"+
		"\x2\x1396\x1397\a\x1F7\x2\x2\x1397\x1399\x5\x2FE\x180\x2\x1398\x1396\x3"+
		"\x2\x2\x2\x1399\x139C\x3\x2\x2\x2\x139A\x1398\x3\x2\x2\x2\x139A\x139B"+
		"\x3\x2\x2\x2\x139B\x139F\x3\x2\x2\x2\x139C\x139A\x3\x2\x2\x2\x139D\x139E"+
		"\a\x206\x2\x2\x139E\x13A0\x5\x2D2\x16A\x2\x139F\x139D\x3\x2\x2\x2\x139F"+
		"\x13A0\x3\x2\x2\x2\x13A0\x2B9\x3\x2\x2\x2\x13A1\x13A2\x5\x2FE\x180\x2"+
		"\x13A2\x2BB\x3\x2\x2\x2\x13A3\x13A8\x5\x2FE\x180\x2\x13A4\x13A5\a\x1F7"+
		"\x2\x2\x13A5\x13A7\x5\x2FE\x180\x2\x13A6\x13A4\x3\x2\x2\x2\x13A7\x13AA"+
		"\x3\x2\x2\x2\x13A8\x13A6\x3\x2\x2\x2\x13A8\x13A9\x3\x2\x2\x2\x13A9\x2BD"+
		"\x3\x2\x2\x2\x13AA\x13A8\x3\x2\x2\x2\x13AB\x13B0\x5\x2FE\x180\x2\x13AC"+
		"\x13AD\a\x1F7\x2\x2\x13AD\x13AF\x5\x2FE\x180\x2\x13AE\x13AC\x3\x2\x2\x2"+
		"\x13AF\x13B2\x3\x2\x2\x2\x13B0\x13AE\x3\x2\x2\x2\x13B0\x13B1\x3\x2\x2"+
		"\x2\x13B1\x2BF\x3\x2\x2\x2\x13B2\x13B0\x3\x2\x2\x2\x13B3\x13B8\x5\x2FC"+
		"\x17F\x2\x13B4\x13B5\a\x1F7\x2\x2\x13B5\x13B7\x5\x2FE\x180\x2\x13B6\x13B4"+
		"\x3\x2\x2\x2\x13B7\x13BA\x3\x2\x2\x2\x13B8\x13B6\x3\x2\x2\x2\x13B8\x13B9"+
		"\x3\x2\x2\x2\x13B9\x2C1\x3\x2\x2\x2\x13BA\x13B8\x3\x2\x2\x2\x13BB\x13BE"+
		"\x5\x2FC\x17F\x2\x13BC\x13BD\a\x1F7\x2\x2\x13BD\x13BF\x5\x2FE\x180\x2"+
		"\x13BE\x13BC\x3\x2\x2\x2\x13BE\x13BF\x3\x2\x2\x2\x13BF\x2C3\x3\x2\x2\x2"+
		"\x13C0\x13C3\x5\x2FC\x17F\x2\x13C1\x13C2\a\x1F7\x2\x2\x13C2\x13C4\x5\x2FE"+
		"\x180\x2\x13C3\x13C1\x3\x2\x2\x2\x13C3\x13C4\x3\x2\x2\x2\x13C4\x2C5\x3"+
		"\x2\x2\x2\x13C5\x13C8\x5\x2FC\x17F\x2\x13C6\x13C7\a\x1F7\x2\x2\x13C7\x13C9"+
		"\x5\x2FE\x180\x2\x13C8\x13C6\x3\x2\x2\x2\x13C8\x13C9\x3\x2\x2\x2\x13C9"+
		"\x2C7\x3\x2\x2\x2\x13CA\x13CB\a\x218\x2\x2\x13CB\x13CD\x5\x2D8\x16D\x2"+
		"\x13CC\x13CA\x3\x2\x2\x2\x13CC\x13CD\x3\x2\x2\x2\x13CD\x13CE\x3\x2\x2"+
		"\x2\x13CE\x13D1\x5\x2FE\x180\x2\x13CF\x13D0\a\x1F7\x2\x2\x13D0\x13D2\x5"+
		"\x2FE\x180\x2\x13D1\x13CF\x3\x2\x2\x2\x13D1\x13D2\x3\x2\x2\x2\x13D2\x13D5"+
		"\x3\x2\x2\x2\x13D3\x13D5\x5\x2EE\x178\x2\x13D4\x13CC\x3\x2\x2\x2\x13D4"+
		"\x13D3\x3\x2\x2\x2\x13D5\x2C9\x3\x2\x2\x2\x13D6\x13D7\x5\x2FC\x17F\x2"+
		"\x13D7\x2CB\x3\x2\x2\x2\x13D8\x13DB\x5\x2FC\x17F\x2\x13D9\x13DB\x5\x2EE"+
		"\x178\x2\x13DA\x13D8\x3\x2\x2\x2\x13DA\x13D9\x3\x2\x2\x2\x13DB\x2CD\x3"+
		"\x2\x2\x2\x13DC\x13DF\x5\x2FC\x17F\x2\x13DD\x13DF\x5\x2EE\x178\x2\x13DE"+
		"\x13DC\x3\x2\x2\x2\x13DE\x13DD\x3\x2\x2\x2\x13DF\x2CF\x3\x2\x2\x2\x13E0"+
		"\x13E3\x5\x2FC\x17F\x2\x13E1\x13E2\a\x1F7\x2\x2\x13E2\x13E4\x5\x2FE\x180"+
		"\x2\x13E3\x13E1\x3\x2\x2\x2\x13E3\x13E4\x3\x2\x2\x2\x13E4\x2D1\x3\x2\x2"+
		"\x2\x13E5\x13EA\x5\x2FC\x17F\x2\x13E6\x13E7\a\x1F7\x2\x2\x13E7\x13E9\x5"+
		"\x2FC\x17F\x2\x13E8\x13E6\x3\x2\x2\x2\x13E9\x13EC\x3\x2\x2\x2\x13EA\x13E8"+
		"\x3\x2\x2\x2\x13EA\x13EB\x3\x2\x2\x2\x13EB\x2D3\x3\x2\x2\x2\x13EC\x13EA"+
		"\x3\x2\x2\x2\x13ED\x13F2\x5\x2FC\x17F\x2\x13EE\x13EF\a\x1F7\x2\x2\x13EF"+
		"\x13F1\x5\x2FE\x180\x2\x13F0\x13EE\x3\x2\x2\x2\x13F1\x13F4\x3\x2\x2\x2"+
		"\x13F2\x13F0\x3\x2\x2\x2\x13F2\x13F3\x3\x2\x2\x2\x13F3\x2D5\x3\x2\x2\x2"+
		"\x13F4\x13F2\x3\x2\x2\x2\x13F5\x13F8\x5\x2FC\x17F\x2\x13F6\x13F7\a\x1F7"+
		"\x2\x2\x13F7\x13F9\x5\x2FE\x180\x2\x13F8\x13F6\x3\x2\x2\x2\x13F8\x13F9"+
		"\x3\x2\x2\x2\x13F9\x13FD\x3\x2\x2\x2\x13FA\x13FB\a\x206\x2\x2\x13FB\x13FE"+
		"\x5\x2D2\x16A\x2\x13FC\x13FE\x5\x28A\x146\x2\x13FD\x13FA\x3\x2\x2\x2\x13FD"+
		"\x13FC\x3\x2\x2\x2\x13FD\x13FE\x3\x2\x2\x2\x13FE\x2D7\x3\x2\x2\x2\x13FF"+
		"\x1404\x5\x2FE\x180\x2\x1400\x1401\a\x1F7\x2\x2\x1401\x1403\x5\x2FE\x180"+
		"\x2\x1402\x1400\x3\x2\x2\x2\x1403\x1406\x3\x2\x2\x2\x1404\x1402\x3\x2"+
		"\x2\x2\x1404\x1405\x3\x2\x2\x2\x1405\x2D9\x3\x2\x2\x2\x1406\x1404\x3\x2"+
		"\x2\x2\x1407\x1408\a\xC9\x2\x2\x1408\x1409\a\x1FE\x2\x2\x1409\x140A\a"+
		"\x1DC\x2\x2\x140A\x140B\t)\x2\x2\x140B\x140C\x5\x1A8\xD5\x2\x140C\x140E"+
		"\a\x1FF\x2\x2\x140D\x140F\x5\x25C\x12F\x2\x140E\x140D\x3\x2\x2\x2\x140E"+
		"\x140F\x3\x2\x2\x2\x140F\x2DB\x3\x2\x2\x2\x1410\x1412\a\x1FE\x2\x2\x1411"+
		"\x1413\x5\x2E4\x173\x2\x1412\x1411\x3\x2\x2\x2\x1412\x1413\x3\x2\x2\x2"+
		"\x1413\x1418\x3\x2\x2\x2\x1414\x1415\a\x204\x2\x2\x1415\x1417\x5\x2E4"+
		"\x173\x2\x1416\x1414\x3\x2\x2\x2\x1417\x141A\x3\x2\x2\x2\x1418\x1416\x3"+
		"\x2\x2\x2\x1418\x1419\x3\x2\x2\x2\x1419\x141B\x3\x2\x2\x2\x141A\x1418"+
		"\x3\x2\x2\x2\x141B\x141D\a\x1FF\x2\x2\x141C\x141E\x5\x2DA\x16E\x2\x141D"+
		"\x141C\x3\x2\x2\x2\x141D\x141E\x3\x2\x2\x2\x141E\x2DD\x3\x2\x2\x2\x141F"+
		"\x1424\a\x1FE\x2\x2\x1420\x1422\x5\x2E4\x173\x2\x1421\x1423\x5\x2E2\x172"+
		"\x2\x1422\x1421\x3\x2\x2\x2\x1422\x1423\x3\x2\x2\x2\x1423\x1425\x3\x2"+
		"\x2\x2\x1424\x1420\x3\x2\x2\x2\x1424\x1425\x3\x2\x2\x2\x1425\x142D\x3"+
		"\x2\x2\x2\x1426\x1427\a\x204\x2\x2\x1427\x1429\x5\x2E4\x173\x2\x1428\x142A"+
		"\x5\x2E2\x172\x2\x1429\x1428\x3\x2\x2\x2\x1429\x142A\x3\x2\x2\x2\x142A"+
		"\x142C\x3\x2\x2\x2\x142B\x1426\x3\x2\x2\x2\x142C\x142F\x3\x2\x2\x2\x142D"+
		"\x142B\x3\x2\x2\x2\x142D\x142E\x3\x2\x2\x2\x142E\x1430\x3\x2\x2\x2\x142F"+
		"\x142D\x3\x2\x2\x2\x1430\x1432\a\x1FF\x2\x2\x1431\x1433\x5\x2DA\x16E\x2"+
		"\x1432\x1431\x3\x2\x2\x2\x1432\x1433\x3\x2\x2\x2\x1433\x2DF\x3\x2\x2\x2"+
		"\x1434\x1435\a\x1FE\x2\x2\x1435\x1442\x5\x2D4\x16B\x2\x1436\x1439\a\x204"+
		"\x2\x2\x1437\x143A\x5\x2F8\x17D\x2\x1438\x143A\a\x107\x2\x2\x1439\x1437"+
		"\x3\x2\x2\x2\x1439\x1438\x3\x2\x2\x2\x143A\x1440\x3\x2\x2\x2\x143B\x143E"+
		"\a\x204\x2\x2\x143C\x143F\x5\x2F8\x17D\x2\x143D\x143F\a\x107\x2\x2\x143E"+
		"\x143C\x3\x2\x2\x2\x143E\x143D\x3\x2\x2\x2\x143F\x1441\x3\x2\x2\x2\x1440"+
		"\x143B\x3\x2\x2\x2\x1440\x1441\x3\x2\x2\x2\x1441\x1443\x3\x2\x2\x2\x1442"+
		"\x1436\x3\x2\x2\x2\x1442\x1443\x3\x2\x2\x2\x1443\x1444\x3\x2\x2\x2\x1444"+
		"\x1458\a\x1AC\x2\x2\x1445\x1446\x5\x2D6\x16C\x2\x1446\x1447\a\x1F7\x2"+
		"\x2\x1447\x1448\a\x201\x2\x2\x1448\x1459\x3\x2\x2\x2\x1449\x1459\a\x201"+
		"\x2\x2\x144A\x144C\x5\x202\x102\x2\x144B\x144D\x5\x28C\x147\x2\x144C\x144B"+
		"\x3\x2\x2\x2\x144C\x144D\x3\x2\x2\x2\x144D\x1455\x3\x2\x2\x2\x144E\x144F"+
		"\a\x204\x2\x2\x144F\x1451\x5\x202\x102\x2\x1450\x1452\x5\x28C\x147\x2"+
		"\x1451\x1450\x3\x2\x2\x2\x1451\x1452\x3\x2\x2\x2\x1452\x1454\x3\x2\x2"+
		"\x2\x1453\x144E\x3\x2\x2\x2\x1454\x1457\x3\x2\x2\x2\x1455\x1453\x3\x2"+
		"\x2\x2\x1455\x1456\x3\x2\x2\x2\x1456\x1459\x3\x2\x2\x2\x1457\x1455\x3"+
		"\x2\x2\x2\x1458\x1445\x3\x2\x2\x2\x1458\x1449\x3\x2\x2\x2\x1458\x144A"+
		"\x3\x2\x2\x2\x1459\x145A\x3\x2\x2\x2\x145A\x145C\a\x1FF\x2\x2\x145B\x145D"+
		"\x5\x2DA\x16E\x2\x145C\x145B\x3\x2\x2\x2\x145C\x145D\x3\x2\x2\x2\x145D"+
		"\x2E1\x3\x2\x2\x2\x145E\x145F\t\x46\x2\x2\x145F\x1460\a\x108\x2\x2\x1460"+
		"\x2E3\x3\x2\x2\x2\x1461\x1462\x5\x2FC\x17F\x2\x1462\x1463\a\x18\x2\x2"+
		"\x1463\x1465\x3\x2\x2\x2\x1464\x1461\x3\x2\x2\x2\x1464\x1465\x3\x2\x2"+
		"\x2\x1465\x1466\x3\x2\x2\x2\x1466\x1467\x5\x204\x103\x2\x1467\x2E5\x3"+
		"\x2\x2\x2\x1468\x1475\x5\x2E8\x175\x2\x1469\x146B\a\x13E\x2\x2\x146A\x1469"+
		"\x3\x2\x2\x2\x146A\x146B\x3\x2\x2\x2\x146B\x146C\x3\x2\x2\x2\x146C\x146F"+
		"\x5\x2BC\x15F\x2\x146D\x146E\a\x206\x2\x2\x146E\x1470\x5\x2D2\x16A\x2"+
		"\x146F\x146D\x3\x2\x2\x2\x146F\x1470\x3\x2\x2\x2\x1470\x1472\x3\x2\x2"+
		"\x2\x1471\x1473\tG\x2\x2\x1472\x1471\x3\x2\x2\x2\x1472\x1473\x3\x2\x2"+
		"\x2\x1473\x1475\x3\x2\x2\x2\x1474\x1468\x3\x2\x2\x2\x1474\x146A\x3\x2"+
		"\x2\x2\x1475\x2E7\x3\x2\x2\x2\x1476\x1478\x5\x2EC\x177\x2\x1477\x1479"+
		"\x5\x2EA\x176\x2\x1478\x1477\x3\x2\x2\x2\x1478\x1479\x3\x2\x2\x2\x1479"+
		"\x1480\x3\x2\x2\x2\x147A\x147C\a\x1BE\x2\x2\x147B\x147D\a\xD6\x2\x2\x147C"+
		"\x147B\x3\x2\x2\x2\x147C\x147D\x3\x2\x2\x2\x147D\x147E\x3\x2\x2\x2\x147E"+
		"\x147F\a\x18B\x2\x2\x147F\x1481\a\x1D4\x2\x2\x1480\x147A\x3\x2\x2\x2\x1480"+
		"\x1481\x3\x2\x2\x2\x1481\x1493\x3\x2\x2\x2\x1482\x1483\a\xC1\x2\x2\x1483"+
		"\x1488\tH\x2\x2\x1484\x1485\a\x1FE\x2\x2\x1485\x1486\x5\x204\x103\x2\x1486"+
		"\x1487\a\x1FF\x2\x2\x1487\x1489\x3\x2\x2\x2\x1488\x1484\x3\x2\x2\x2\x1488"+
		"\x1489\x3\x2\x2\x2\x1489\x148A\x3\x2\x2\x2\x148A\x148B\a\x194\x2\x2\x148B"+
		"\x1490\tI\x2\x2\x148C\x148D\a\x1FE\x2\x2\x148D\x148E\x5\x204\x103\x2\x148E"+
		"\x148F\a\x1FF\x2\x2\x148F\x1491\x3\x2\x2\x2\x1490\x148C\x3\x2\x2\x2\x1490"+
		"\x1491\x3\x2\x2\x2\x1491\x1493\x3\x2\x2\x2\x1492\x1476\x3\x2\x2\x2\x1492"+
		"\x1482\x3\x2\x2\x2\x1493\x2E9\x3\x2\x2\x2\x1494\x1495\a\x1FE\x2\x2\x1495"+
		"\x1498\x5\x2F8\x17D\x2\x1496\x1497\a\x204\x2\x2\x1497\x1499\x5\x2F8\x17D"+
		"\x2\x1498\x1496\x3\x2\x2\x2\x1498\x1499\x3\x2\x2\x2\x1499\x149B\x3\x2"+
		"\x2\x2\x149A\x149C\tJ\x2\x2\x149B\x149A\x3\x2\x2\x2\x149B\x149C\x3\x2"+
		"\x2\x2\x149C\x149D\x3\x2\x2\x2\x149D\x149E\a\x1FF\x2\x2\x149E\x2EB\x3"+
		"\x2\x2\x2\x149F\x14DC\a\'\x2\x2\x14A0\x14DC\a\x12F\x2\x2\x14A1\x14DC\a"+
		"\xF1\x2\x2\x14A2\x14DC\a&\x2\x2\x14A3\x14DC\a%\x2\x2\x14A4\x14DC\a\xF2"+
		"\x2\x2\x14A5\x14DC\a\x130\x2\x2\x14A6\x14DC\a\x131\x2\x2\x14A7\x14DC\a"+
		"\x16E\x2\x2\x14A8\x14DC\a\x16F\x2\x2\x14A9\x14DC\a\x10B\x2\x2\x14AA\x14DC"+
		"\a\x66\x2\x2\x14AB\x14DC\a\xBF\x2\x2\x14AC\x14DC\a\xBE\x2\x2\x14AD\x14DC"+
		"\a\x10A\x2\x2\x14AE\x14DC\a\x173\x2\x2\x14AF\x14DC\a\x109\x2\x2\x14B0"+
		"\x14DC\ag\x2\x2\x14B1\x14B3\ax\x2\x2\x14B2\x14B4\a\x134\x2\x2\x14B3\x14B2"+
		"\x3\x2\x2\x2\x14B3\x14B4\x3\x2\x2\x2\x14B4\x14DC\x3\x2\x2\x2\x14B5\x14DC"+
		"\a\x9A\x2\x2\x14B6\x14DC\a\x13C\x2\x2\x14B7\x14DC\a\xF4\x2\x2\x14B8\x14BA"+
		"\a\xDC\x2\x2\x14B9\x14BB\a\x13A\x2\x2\x14BA\x14B9\x3\x2\x2\x2\x14BA\x14BB"+
		"\x3\x2\x2\x2\x14BB\x14DC\x3\x2\x2\x2\x14BC\x14DC\a\x38\x2\x2\x14BD\x14DC"+
		"\a:\x2\x2\x14BE\x14DC\a\x1B1\x2\x2\x14BF\x14DC\a\x1B0\x2\x2\x14C0\x14DC"+
		"\a\x181\x2\x2\x14C1\x14DC\a\x13A\x2\x2\x14C2\x14DC\a+\x2\x2\x14C3\x14DC"+
		"\a`\x2\x2\x14C4\x14DC\a\x152\x2\x2\x14C5\x14DC\a\x1AA\x2\x2\x14C6\x14DC"+
		"\a\x1D1\x2\x2\x14C7\x14DC\a\xED\x2\x2\x14C8\x14DC\a\x61\x2\x2\x14C9\x14DC"+
		"\a\xAA\x2\x2\x14CA\x14DC\a\xE6\x2\x2\x14CB\x14DC\a\x15C\x2\x2\x14CC\x14DC"+
		"\a\x191\x2\x2\x14CD\x14DC\a\x192\x2\x2\x14CE\x14DC\a\x193\x2\x2\x14CF"+
		"\x14DC\a\x190\x2\x2\x14D0\x14DC\a\x18C\x2\x2\x14D1\x14DC\a\x18F\x2\x2"+
		"\x14D2\x14DC\a\x18E\x2\x2\x14D3\x14DC\a\x18D\x2\x2\x14D4\x14DC\a\x1D3"+
		"\x2\x2\x14D5\x14DC\az\x2\x2\x14D6\x14DC\a$\x2\x2\x14D7\x14DC\a(\x2\x2"+
		"\x14D8\x14DC\a=\x2\x2\x14D9\x14DC\a\xF6\x2\x2\x14DA\x14DC\a\xE8\x2\x2"+
		"\x14DB\x149F\x3\x2\x2\x2\x14DB\x14A0\x3\x2\x2\x2\x14DB\x14A1\x3\x2\x2"+
		"\x2\x14DB\x14A2\x3\x2\x2\x2\x14DB\x14A3\x3\x2\x2\x2\x14DB\x14A4\x3\x2"+
		"\x2\x2\x14DB\x14A5\x3\x2\x2\x2\x14DB\x14A6\x3\x2\x2\x2\x14DB\x14A7\x3"+
		"\x2\x2\x2\x14DB\x14A8\x3\x2\x2\x2\x14DB\x14A9\x3\x2\x2\x2\x14DB\x14AA"+
		"\x3\x2\x2\x2\x14DB\x14AB\x3\x2\x2\x2\x14DB\x14AC\x3\x2\x2\x2\x14DB\x14AD"+
		"\x3\x2\x2\x2\x14DB\x14AE\x3\x2\x2\x2\x14DB\x14AF\x3\x2\x2\x2\x14DB\x14B0"+
		"\x3\x2\x2\x2\x14DB\x14B1\x3\x2\x2\x2\x14DB\x14B5\x3\x2\x2\x2\x14DB\x14B6"+
		"\x3\x2\x2\x2\x14DB\x14B7\x3\x2\x2\x2\x14DB\x14B8\x3\x2\x2\x2\x14DB\x14BC"+
		"\x3\x2\x2\x2\x14DB\x14BD\x3\x2\x2\x2\x14DB\x14BE\x3\x2\x2\x2\x14DB\x14BF"+
		"\x3\x2\x2\x2\x14DB\x14C0\x3\x2\x2\x2\x14DB\x14C1\x3\x2\x2\x2\x14DB\x14C2"+
		"\x3\x2\x2\x2\x14DB\x14C3\x3\x2\x2\x2\x14DB\x14C4\x3\x2\x2\x2\x14DB\x14C5"+
		"\x3\x2\x2\x2\x14DB\x14C6\x3\x2\x2\x2\x14DB\x14C7\x3\x2\x2\x2\x14DB\x14C8"+
		"\x3\x2\x2\x2\x14DB\x14C9\x3\x2\x2\x2\x14DB\x14CA\x3\x2\x2\x2\x14DB\x14CB"+
		"\x3\x2\x2\x2\x14DB\x14CC\x3\x2\x2\x2\x14DB\x14CD\x3\x2\x2\x2\x14DB\x14CE"+
		"\x3\x2\x2\x2\x14DB\x14CF\x3\x2\x2\x2\x14DB\x14D0\x3\x2\x2\x2\x14DB\x14D1"+
		"\x3\x2\x2\x2\x14DB\x14D2\x3\x2\x2\x2\x14DB\x14D3\x3\x2\x2\x2\x14DB\x14D4"+
		"\x3\x2\x2\x2\x14DB\x14D5\x3\x2\x2\x2\x14DB\x14D6\x3\x2\x2\x2\x14DB\x14D7"+
		"\x3\x2\x2\x2\x14DB\x14D8\x3\x2\x2\x2\x14DB\x14D9\x3\x2\x2\x2\x14DB\x14DA"+
		"\x3\x2\x2\x2\x14DC\x2ED\x3\x2\x2\x2\x14DD\x14E1\a\x208\x2\x2\x14DE\x14DF"+
		"\a\x209\x2\x2\x14DF\x14E1\a\x1F8\x2\x2\x14E0\x14DD\x3\x2\x2\x2\x14E0\x14DE"+
		"\x3\x2\x2\x2\x14E1\x14EA\x3\x2\x2\x2\x14E2\x14E4\a\xB5\x2\x2\x14E3\x14E2"+
		"\x3\x2\x2\x2\x14E3\x14E4\x3\x2\x2\x2\x14E4\x14E8\x3\x2\x2\x2\x14E5\x14E9"+
		"\a\x208\x2\x2\x14E6\x14E7\a\x209\x2\x2\x14E7\x14E9\a\x1F8\x2\x2\x14E8"+
		"\x14E5\x3\x2\x2\x2\x14E8\x14E6\x3\x2\x2\x2\x14E9\x14EB\x3\x2\x2\x2\x14EA"+
		"\x14E3\x3\x2\x2\x2\x14EA\x14EB\x3\x2\x2\x2\x14EB\x14F0\x3\x2\x2\x2\x14EC"+
		"\x14ED\a\x1F7\x2\x2\x14ED\x14EF\x5\x2F2\x17A\x2\x14EE\x14EC\x3\x2\x2\x2"+
		"\x14EF\x14F2\x3\x2\x2\x2\x14F0\x14EE\x3\x2\x2\x2\x14F0\x14F1\x3\x2\x2"+
		"\x2\x14F1\x2EF\x3\x2\x2\x2\x14F2\x14F0\x3\x2\x2\x2\x14F3\x14F8\x5\x2F2"+
		"\x17A\x2\x14F4\x14F5\a\x1F7\x2\x2\x14F5\x14F7\x5\x2F2\x17A\x2\x14F6\x14F4"+
		"\x3\x2\x2\x2\x14F7\x14FA\x3\x2\x2\x2\x14F8\x14F6\x3\x2\x2\x2\x14F8\x14F9"+
		"\x3\x2\x2\x2\x14F9\x2F1\x3\x2\x2\x2\x14FA\x14F8\x3\x2\x2\x2\x14FB\x14FC"+
		"\a\x218\x2\x2\x14FC\x14FE\x5\x2D8\x16D\x2\x14FD\x14FB\x3\x2\x2\x2\x14FD"+
		"\x14FE\x3\x2\x2\x2\x14FE\x14FF\x3\x2\x2\x2\x14FF\x1504\x5\x2FE\x180\x2"+
		"\x1500\x1501\a\x1F7\x2\x2\x1501\x1503\x5\x2FE\x180\x2\x1502\x1500\x3\x2"+
		"\x2\x2\x1503\x1506\x3\x2\x2\x2\x1504\x1502\x3\x2\x2\x2\x1504\x1505\x3"+
		"\x2\x2\x2\x1505\x1508\x3\x2\x2\x2\x1506\x1504\x3\x2\x2\x2\x1507\x1509"+
		"\x5\x2DC\x16F\x2\x1508\x1507\x3\x2\x2\x2\x1508\x1509\x3\x2\x2\x2\x1509"+
		"\x2F3\x3\x2\x2\x2\x150A\x150B\a\x218\x2\x2\x150B\x150D\x5\x2D8\x16D\x2"+
		"\x150C\x150A\x3\x2\x2\x2\x150C\x150D\x3\x2\x2\x2\x150D\x150E\x3\x2\x2"+
		"\x2\x150E\x1513\x5\x2FE\x180\x2\x150F\x1510\a\x1F7\x2\x2\x1510\x1512\x5"+
		"\x2FE\x180\x2\x1511\x150F\x3\x2\x2\x2\x1512\x1515\x3\x2\x2\x2\x1513\x1511"+
		"\x3\x2\x2\x2\x1513\x1514\x3\x2\x2\x2\x1514\x2F5\x3\x2\x2\x2\x1515\x1513"+
		"\x3\x2\x2\x2\x1516\x1519\a\x18C\x2\x2\x1517\x151A\x5\x2FA\x17E\x2\x1518"+
		"\x151A\x5\x2EE\x178\x2\x1519\x1517\x3\x2\x2\x2\x1519\x1518\x3\x2\x2\x2"+
		"\x151A\x151F\x3\x2\x2\x2\x151B\x151C\a\x19\x2\x2\x151C\x151D\a\x18B\x2"+
		"\x2\x151D\x151E\a\x1D4\x2\x2\x151E\x1520\x5\x2FA\x17E\x2\x151F\x151B\x3"+
		"\x2\x2\x2\x151F\x1520\x3\x2\x2\x2\x1520\x1555\x3\x2\x2\x2\x1521\x1525"+
		"\a\xC1\x2\x2\x1522\x1526\x5\x2FA\x17E\x2\x1523\x1526\x5\x2EE\x178\x2\x1524"+
		"\x1526\x5\x2F2\x17A\x2\x1525\x1522\x3\x2\x2\x2\x1525\x1523\x3\x2\x2\x2"+
		"\x1525\x1524\x3\x2\x2\x2\x1526\x1527\x3\x2\x2\x2\x1527\x1535\tK\x2\x2"+
		"\x1528\x152B\a\x1FE\x2\x2\x1529\x152C\a\x1F8\x2\x2\x152A\x152C\x5\x2EE"+
		"\x178\x2\x152B\x1529\x3\x2\x2\x2\x152B\x152A\x3\x2\x2\x2\x152C\x1532\x3"+
		"\x2\x2\x2\x152D\x1530\a\x204\x2\x2\x152E\x1531\a\x1F8\x2\x2\x152F\x1531"+
		"\x5\x2EE\x178\x2\x1530\x152E\x3\x2\x2\x2\x1530\x152F\x3\x2\x2\x2\x1531"+
		"\x1533\x3\x2\x2\x2\x1532\x152D\x3\x2\x2\x2\x1532\x1533\x3\x2\x2\x2\x1533"+
		"\x1534\x3\x2\x2\x2\x1534\x1536\a\x1FF\x2\x2\x1535\x1528\x3\x2\x2\x2\x1535"+
		"\x1536\x3\x2\x2\x2\x1536\x1546\x3\x2\x2\x2\x1537\x1544\a\x194\x2\x2\x1538"+
		"\x1545\a\x61\x2\x2\x1539\x1545\a\xAA\x2\x2\x153A\x1545\a\xE6\x2\x2\x153B"+
		"\x1542\a\x15C\x2\x2\x153C\x153F\a\x1FE\x2\x2\x153D\x1540\a\x1F8\x2\x2"+
		"\x153E\x1540\x5\x2EE\x178\x2\x153F\x153D\x3\x2\x2\x2\x153F\x153E\x3\x2"+
		"\x2\x2\x1540\x1541\x3\x2\x2\x2\x1541\x1543\a\x1FF\x2\x2\x1542\x153C\x3"+
		"\x2\x2\x2\x1542\x1543\x3\x2\x2\x2\x1543\x1545\x3\x2\x2\x2\x1544\x1538"+
		"\x3\x2\x2\x2\x1544\x1539\x3\x2\x2\x2\x1544\x153A\x3\x2\x2\x2\x1544\x153B"+
		"\x3\x2\x2\x2\x1545\x1547\x3\x2\x2\x2\x1546\x1537\x3\x2\x2\x2\x1546\x1547"+
		"\x3\x2\x2\x2\x1547\x1555\x3\x2\x2\x2\x1548\x1555\x5\x2F8\x17D\x2\x1549"+
		"\x154A\a`\x2\x2\x154A\x1555\x5\x2FA\x17E\x2\x154B\x1555\x5\x2FA\x17E\x2"+
		"\x154C\x1555\a\x107\x2\x2\x154D\x1555\a\x19D\x2\x2\x154E\x1555\a\x95\x2"+
		"\x2\x154F\x1555\a\x63\x2\x2\x1550\x1555\a\x166\x2\x2\x1551\x1555\a\xE7"+
		"\x2\x2\x1552\x1555\a\xE1\x2\x2\x1553\x1555\ak\x2\x2\x1554\x1516\x3\x2"+
		"\x2\x2\x1554\x1521\x3\x2\x2\x2\x1554\x1548\x3\x2\x2\x2\x1554\x1549\x3"+
		"\x2\x2\x2\x1554\x154B\x3\x2\x2\x2\x1554\x154C\x3\x2\x2\x2\x1554\x154D"+
		"\x3\x2\x2\x2\x1554\x154E\x3\x2\x2\x2\x1554\x154F\x3\x2\x2\x2\x1554\x1550"+
		"\x3\x2\x2\x2\x1554\x1551\x3\x2\x2\x2\x1554\x1552\x3\x2\x2\x2\x1554\x1553"+
		"\x3\x2\x2\x2\x1555\x2F7\x3\x2\x2\x2\x1556\x1557\tL\x2\x2\x1557\x2F9\x3"+
		"\x2\x2\x2\x1558\x1559\tM\x2\x2\x1559\x2FB\x3\x2\x2\x2\x155A\x155B\a\x218"+
		"\x2\x2\x155B\x155D\x5\x2D8\x16D\x2\x155C\x155A\x3\x2\x2\x2\x155C\x155D"+
		"\x3\x2\x2\x2\x155D\x155E\x3\x2\x2\x2\x155E\x155F\x5\x2FE\x180\x2\x155F"+
		"\x2FD\x3\x2\x2\x2\x1560\x1563\x5\x30A\x186\x2\x1561\x1563\a\x1FB\x2\x2"+
		"\x1562\x1560\x3\x2\x2\x2\x1562\x1561\x3\x2\x2\x2\x1563\x2FF\x3\x2\x2\x2"+
		"\x1564\x156C\a\x20E\x2\x2\x1565\x1566\a\x20C\x2\x2\x1566\x156C\a\x212"+
		"\x2\x2\x1567\x1568\a\x211\x2\x2\x1568\x156C\a\x215\x2\x2\x1569\x156A\a"+
		"\x20F\x2\x2\x156A\x156C\a\x215\x2\x2\x156B\x1564\x3\x2\x2\x2\x156B\x1565"+
		"\x3\x2\x2\x2\x156B\x1567\x3\x2\x2\x2\x156B\x1569\x3\x2\x2\x2\x156C\x301"+
		"\x3\x2\x2\x2\x156D\x1571\a\x20D\x2\x2\x156E\x156F\a\x212\x2\x2\x156F\x1571"+
		"\a\x215\x2\x2\x1570\x156D\x3\x2\x2\x2\x1570\x156E\x3\x2\x2\x2\x1571\x303"+
		"\x3\x2\x2\x2\x1572\x1576\a\x20B\x2\x2\x1573\x1574\a\x20C\x2\x2\x1574\x1576"+
		"\a\x215\x2\x2\x1575\x1572\x3\x2\x2\x2\x1575\x1573\x3\x2\x2\x2\x1576\x305"+
		"\x3\x2\x2\x2\x1577\x157B\a\x213\x2\x2\x1578\x1579\a\x214\x2\x2\x1579\x157B"+
		"\a\x214\x2\x2\x157A\x1577\x3\x2\x2\x2\x157A\x1578\x3\x2\x2\x2\x157B\x307"+
		"\x3\x2\x2\x2\x157C\x157D\a\x1FE\x2\x2\x157D\x157E\a\x202\x2\x2\x157E\x157F"+
		"\a\x1FF\x2\x2\x157F\x309\x3\x2\x2\x2\x1580\x1581\tN\x2\x2\x1581\x30B\x3"+
		"\x2\x2\x2\x2D5\x30F\x314\x31E\x322\x325\x327\x32B\x344\x34A\x359\x35E"+
		"\x363\x36A\x36C\x378\x37D\x389\x38B\x392\x397\x399\x39F\x3AD\x3B2\x3B5"+
		"\x3BB\x3C4\x3D2\x3DA\x3E4\x3E7\x3EC\x3F1\x3F8\x3FD\x408\x40D\x410\x414"+
		"\x418\x41E\x423\x42F\x43B\x447\x44C\x451\x458\x45A\x466\x46B\x46E\x474"+
		"\x47A\x47C\x48E\x493\x498\x49A\x4A1\x4A8\x4AB\x4AE\x4B1\x4BC\x4C8\x4CC"+
		"\x4CF\x4D8\x4E0\x4E8\x4EB\x4F2\x4F6\x4FD\x503\x52C\x548\x54F\x554\x55F"+
		"\x562\x56D\x575\x579\x585\x588\x58E\x591\x596\x59B\x59F\x5A9\x5B3\x5B9"+
		"\x5C4\x5C9\x5CD\x5D5\x5DD\x5E2\x5E5\x5E7\x5EA\x5F3\x5F8\x5FF\x602\x605"+
		"\x609\x60C\x614\x619\x61E\x625\x62F\x63F\x645\x64F\x659\x662\x668\x672"+
		"\x677\x680\x686\x689\x68C\x69D\x6A2\x6AD\x6B3\x6B6\x6BD\x6C0\x6C7\x6CC"+
		"\x6D0\x6D5\x6DA\x6E4\x6EB\x6F5\x6FA\x701\x708\x70C\x70F\x712\x723\x728"+
		"\x731\x73F\x746\x756\x75F\x761\x776\x786\x78F\x794\x798\x79B\x7A5\x7B1"+
		"\x7B7\x7BF\x7C3\x7C6\x7D5\x7D9\x7DE\x7E1\x7EE\x7F2\x7FE\x803\x807\x80B"+
		"\x811\x814\x817\x825\x835\x83B\x83F\x845\x851\x85A\x85C\x862\x866\x869"+
		"\x86F\x874\x876\x87C\x887\x88B\x88E\x892\x89A\x8A3\x8AD\x8AF\x8D2\x8D7"+
		"\x8DE\x8E2\x8E6\x8EA\x8F6\x8FA\x908\x90E\x915\x91A\x924\x92A\x92C\x935"+
		"\x93F\x944\x953\x957\x95A\x95E\x963\x967\x970\x972\x975\x97E\x980\x983"+
		"\x98A\x98D\x98F\x99B\x9A3\x9AA\x9AF\x9B7\x9BE\x9C2\x9C5\x9D1\x9D7\x9DF"+
		"\x9E9\x9F4\x9FA\x9FC\x9FE\xA05\xA08\xA0F\xA1A\xA20\xA24\xA2E\xA31\xA37"+
		"\xA42\xA44\xA46\xA49\xA4D\xA50\xA54\xA58\xA5D\xA68\xA6C\xA74\xA79\xA7B"+
		"\xA84\xA8E\xA93\xA99\xA9D\xAA0\xAA8\xAAB\xAAF\xAB3\xAB8\xABB\xABF\xAC3"+
		"\xAC7\xAD3\xAE1\xAE6\xAEA\xAF3\xAF6\xAFA\xB02\xB05\xB08\xB0C\xB0F\xB12"+
		"\xB15\xB18\xB1B\xB1F\xB29\xB30\xB37\xB3C\xB41\xB48\xB4E\xB58\xB5B\xB60"+
		"\xB64\xB67\xB6A\xB6E\xB73\xB77\xB79\xB86\xB8D\xB9B\xB9E\xBA8\xBAC\xBB4"+
		"\xBC0\xBCA\xBCF\xBD9\xBE1\xBE4\xBEA\xBEE\xBF3\xBFD\xC02\xC0F\xC1B\xC20"+
		"\xC2A\xC2F\xC31\xC36\xC3A\xC40\xC44\xC51\xC55\xC5F\xC62\xC64\xC69\xC72"+
		"\xC7F\xC87\xC90\xC94\xC99\xCA4\xCA6\xCB6\xCBB\xCC1\xCC7\xCD9\xCE0\xCE3"+
		"\xCEB\xCF4\xCF6\xCFA\xCFD\xD02\xD04\xD08\xD14\xD1D\xD25\xD2A\xD2E\xD33"+
		"\xD36\xD3E\xD46\xD4C\xD4F\xD52\xD5A\xD64\xD70\xD77\xD7B\xD7F\xD82\xD85"+
		"\xD8A\xD8F\xD92\xD95\xD9B\xD9E\xDA4\xDA7\xDAA\xDAF\xDB2\xDBA\xDC0\xDCA"+
		"\xDCF\xDD5\xDDB\xDE5\xDE9\xDEB\xDEE\xDFA\xDFE\xE01\xE15\xE1A\xE1F\xE26"+
		"\xE29\xE32\xE39\xE3E\xE42\xE4A\xE50\xE58\xE5B\xE63\xE6B\xE6E\xE71\xE7A"+
		"\xE80\xE86\xE88\xE95\xE97\xEA0\xEA2\xEA6\xEAC\xEB0\xEC9\xED4\xED9\xF01"+
		"\xF05\xF0B\xF19\xF23\xF29\xF2F\xF3A\xF3E\xF45\xF4A\xF4E\xF52\xF57\xF5D"+
		"\xF62\xF66\xF6A\xF6E\xF70\xF7B\xF80\xF85\xF8E\xF90\xF92\xF95\xFA6\xFAE"+
		"\xFBA\xFC4\xFCC\xFD5\xFD8\xFDF\xFE7\xFEE\xFF2\xFF9\xFFD\x1002\x1006\x100E"+
		"\x1012\x1019\x1022\x1030\x103D\x1042\x1058\x105C\x105F\x1066\x1069\x106D"+
		"\x1070\x1077\x107A\x1080\x1083\x1087\x108A\x1091\x1096\x10A4\x10AA\x10AD"+
		"\x10B1\x10B9\x10C7\x10CC\x10D5\x10E1\x10E6\x10F0\x10F7\x10FF\x1107\x110B"+
		"\x110E\x1113\x1118\x111D\x1123\x1126\x112A\x1137\x113B\x1144\x114A\x1158"+
		"\x1163\x1167\x116A\x117A\x1180\x118A\x1192\x1195\x1198\x11A1\x11A6\x11AF"+
		"\x11B5\x11BA\x11BD\x11C2\x11C7\x11CB\x11D1\x11D7\x11E0\x11E5\x11ED\x11F1"+
		"\x11F6\x11FC\x1203\x1208\x120F\x1213\x1218\x1220\x1223\x1226\x1229\x122D"+
		"\x1232\x1235\x1240\x1244\x1246\x1251\x125C\x1265\x1268\x126C\x126F\x1273"+
		"\x1280\x1285\x128D\x1294\x1299\x129D\x12A2\x12A6\x12AC\x12AF\x12B6\x12C5"+
		"\x12C8\x12CB\x12D5\x12D8\x12DA\x12E1\x12E6\x12E8\x12EE\x12F4\x12F6\x1304"+
		"\x1306\x130D\x1311\x131E\x1323\x1329\x132E\x1332\x1336\x133D\x1345\x134D"+
		"\x1358\x135B\x135F\x1372\x1377\x137C\x1383\x1390\x139A\x139F\x13A8\x13B0"+
		"\x13B8\x13BE\x13C3\x13C8\x13CC\x13D1\x13D4\x13DA\x13DE\x13E3\x13EA\x13F2"+
		"\x13F8\x13FD\x1404\x140E\x1412\x1418\x141D\x1422\x1424\x1429\x142D\x1432"+
		"\x1439\x143E\x1440\x1442\x144C\x1451\x1455\x1458\x145C\x1464\x146A\x146F"+
		"\x1472\x1474\x1478\x147C\x1480\x1488\x1490\x1492\x1498\x149B\x14B3\x14BA"+
		"\x14DB\x14E0\x14E3\x14E8\x14EA\x14F0\x14F8\x14FD\x1504\x1508\x150C\x1513"+
		"\x1519\x151F\x1525\x152B\x1530\x1532\x1535\x153F\x1542\x1544\x1546\x1554"+
		"\x155C\x1562\x156B\x1570\x1575\x157A";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
